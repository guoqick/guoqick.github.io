<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭琪的小站</title>
  
  <subtitle>人生如逆旅，我亦是行人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-06T01:19:01.669Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭 琪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux下vi/vim常用命令大全</title>
    <link href="http://yoursite.com/2018/06/06/linux%E4%B8%8Bvivim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2018/06/06/linux下vivim常用命令大全/</id>
    <published>2018-06-06T01:15:44.226Z</published>
    <updated>2018-06-06T01:19:01.669Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vi-vim-基本使用方法"><a href="#vi-vim-基本使用方法" class="headerlink" title="vi/vim 基本使用方法"></a>vi/vim 基本使用方法</h4><p>vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。</p><h4 id="vi的基本概念"><a href="#vi的基本概念" class="headerlink" title="vi的基本概念"></a>vi的基本概念</h4><p>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p><p>1) <strong>命令行模式</strong>command mode）</p><p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p><p>2) <strong>插入模式</strong>（Insert mode）</p><p>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。</p><p>3) <strong>底行模式</strong>（last line mode）</p><p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。</p><h4 id="vi的基本操作"><a href="#vi的基本操作" class="headerlink" title="vi的基本操作"></a>vi的基本操作</h4><p>a) 进入vi</p><p>在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：</p><p><strong>$ vi myfile</strong></p><p>不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！</p><p>b) 切换至插入模式（Insert mode）编辑文件</p><p>在「命令行模式（command mode）」下<strong>按一下字母「i」</strong>就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。</p><p>c) Insert 的切换</p><p>您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要<strong>先按一下「ESC」键</strong>转到「命令行模式（command mode）」再删除文字。</p><p>d) 退出vi及保存文件</p><p>在「命令行模式（command mode）」下<strong>，按一下「：」冒号</strong>键进入「Last line mode」，例如：</p><p>: <strong>w filename</strong> （输入 「w filename」将文章以指定的文件名filename保存）</p><p>: <strong>wq</strong> (输入「wq」，存盘并退出vi)</p><p>: <strong>q!</strong> (输入q!， 不存盘强制退出vi)</p><h4 id="命令行模式（command-mode）功能键"><a href="#命令行模式（command-mode）功能键" class="headerlink" title="命令行模式（command mode）功能键"></a>命令行模式（command mode）功能键</h4><p>1）. 插入模式</p><p>按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；</p><p>按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；</p><p>按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。</p><p>2）. 从插入模式切换为命令行模式</p><p>按「ESC」键。</p><p>3）. 移动光标</p><p>vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</p><p>按「ctrl」+「b」：屏幕往“后”移动一页。</p><p>按「ctrl」+「f」：屏幕往“前”移动一页。</p><p>按「ctrl」+「u」：屏幕往“后”移动半页。</p><p>按「ctrl」+「d」：屏幕往“前”移动半页。</p><p>按数字「0」：移到文章的开头。</p><p>按「G」：移动到文章的最后。</p><p>按「$」：移动到光标所在行的“行尾”。</p><p>按「^」：移动到光标所在行的“行首”</p><p>按「w」：光标跳到下个字的开头</p><p>按「e」：光标跳到下个字的字尾</p><p>按「b」：光标回到上个字的开头</p><p>按「#l」：光标移到该行的第#个位置，如：5l,56l。</p><p>4）. 删除文字</p><p>「x」：每按一次，删除光标所在位置的“后面”一个字符。</p><p>「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符。</p><p>「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符。</p><p>「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符。</p><p>「dd」：删除光标所在行。</p><p>「#dd」：从光标所在行开始删除#行</p><p>5）. 复制</p><p>「yw」：将光标所在之处到字尾的字符复制到缓冲区中。</p><p>「#yw」：复制#个字到缓冲区</p><p>「yy」：复制光标所在行到缓冲区。</p><p>「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。</p><p>「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。</p><p>6）. 替换</p><p>「r」：替换光标所在处的字符。</p><p>「R」：替换光标所到之处的字符，直到按下「ESC」键为止。</p><p>7）. 恢复/撤消/还原上一次操作</p><p>「u」：如果误执行一个命令，可以马上按下「u」，撤消上一个操作。按多次“u”可以执行多次撤消。</p><p>8）. 更改</p><p>「cw」：更改光标所在处的字到字尾处</p><p>「c#w」：例如，「c3w」表示更改3个字</p><p>9）. 跳至指定的行</p><p>「ctrl」+「g」列出光标所在行的行号。</p><p>「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</p><h4 id="Last-line-mode下命令简介"><a href="#Last-line-mode下命令简介" class="headerlink" title="Last line mode下命令简介"></a>Last line mode下命令简介</h4><p>在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。</p><p>A) 列出行号</p><p>「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。</p><p>B) 跳到文件中的某一行</p><p>「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。</p><p>C) 查找字符</p><p>「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。</p><p>「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。</p><p>D) 保存文件</p><p>「w」：在冒号输入字母「w」就可以将文件保存起来。</p><p>E) 离开vi</p><p>「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。</p><p>「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。</p><h4 id="vi命令列表"><a href="#vi命令列表" class="headerlink" title="vi命令列表"></a>vi命令列表</h4><p>1、下表列出命令模式下的一些键的功能：</p><p>h<br>左移光标一个字符</p><p>l<br>右移光标一个字符</p><p>k<br>光标上移一行</p><p>j<br>光标下移一行</p><p>^<br>光标移动至行首</p><p>0<br>数字“0”，光标移至文章的开头</p><p>G<br>光标移至文章的最后</p><p>$<br>光标移动至行尾</p><p>Ctrl+f<br>向前翻屏</p><p>Ctrl+b<br>向后翻屏</p><p>Ctrl+d<br>向前翻半屏</p><p>Ctrl+u<br>向后翻半屏</p><p>i<br>在光标位置前插入字符</p><p>a<br>在光标所在位置的后一个字符开始增加</p><p>o<br>插入新的一行，从行首开始输入</p><p>ESC<br>从输入状态退至命令状态</p><p>x<br>删除光标后面的字符</p><p>#x<br>删除光标后的＃个字符</p><p>X<br>(大写X)，删除光标前面的字符</p><p>#X<br>删除光标前面的#个字符</p><p>dd<br>删除光标所在的行</p><p>#dd<br>删除从光标所在行数的#行</p><p>yw<br>复制光标所在位置的一个字</p><p>#yw<br>复制光标所在位置的#个字</p><p>yy<br>复制光标所在位置的一行</p><p>#yy<br>复制从光标所在行数的#行</p><p>p<br>粘贴</p><p>u<br>取消操作</p><p>cw<br>更改光标所在位置的一个字</p><p>#cw<br>更改光标所在位置的#个字</p><p>下表列出行命令模式下的一些指令<br>w filename<br>储存正在编辑的文件为filename</p><p>wq filename<br>储存正在编辑的文件为filename，并退出vi</p><p>q!<br>放弃所有修改，退出vi</p><p>set nu<br>显示行号</p><p>/或?<br>查找，在/后输入要查找的内容</p><p>n<br>与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;vi-vim-基本使用方法&quot;&gt;&lt;a href=&quot;#vi-vim-基本使用方法&quot; class=&quot;headerlink&quot; title=&quot;vi/vim 基本使用方法&quot;&gt;&lt;/a&gt;vi/vim 基本使用方法&lt;/h4&gt;&lt;p&gt;vi编辑器是所有Unix及Linux系统下标准的编辑
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap HashTable HashSet三者区别</title>
    <link href="http://yoursite.com/2018/06/05/HashMap%20HashTable%20HashSet%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/06/05/HashMap HashTable HashSet三者区别/</id>
    <published>2018-06-05T11:46:20.639Z</published>
    <updated>2018-06-05T11:49:19.449Z</updated>
    
    <content type="html"><![CDATA[<p> HashMap、HashSet、HashTable之间的区别是Java程序员的一个常见面试题目，在此仅以此博客记录，并深入源代码进行分析：</p><p>在分析之前，先将其区别列于下面：</p><ol><li>1、HashSet底层采用的是HashMap进行实现的，但是没有key-value，只有HashMap的key set的视图，HashSet不容许重复的对象</li><li>Hashtable是基于Dictionary类的，而HashMap是基于Map接口的一个实现</li><li>Hashtable里默认的方法是同步的，而HashMap则是非同步的，因此Hashtable是多线程安全的</li><li>HashMap可以将空值作为一个表的条目的key或者value,HashMap中由于键不能重复，因此只有一条记录的Key可以是空值，而value可以有多个为空，但HashTable不允许null值(键与值均不行)</li><li>内存初始大小不同，HashTable初始大小是11，而HashMap初始大小是16</li><li>内存扩容时采取的方式也不同，Hashtable采用的是2<em>old+1,而HashMap是2</em>old。</li><li>哈希值的计算方法不同，Hashtable直接使用的是对象的hashCode,而HashMap则是在对象的hashCode的基础上还进行了一些变化</li></ol><p>源代码分析：</p><p><strong>对于区别1，看下面的源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//HashSet类的部份源代码  </span><br><span class="line">public class HashSet&lt;E&gt;  </span><br><span class="line">    extends AbstractSet&lt;E&gt;  </span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  </span><br><span class="line">&#123;   //用于类的序列化，可以不用管它  </span><br><span class="line">    static final long serialVersionUID = -5024744406713321676L;  </span><br><span class="line">    //从这里可以看出HashSet类里面真的是采用HashMap来实现的  </span><br><span class="line">    private transient HashMap&lt;E,Object&gt; map;  </span><br><span class="line">  </span><br><span class="line">    // Dummy value to associate with an Object in the backing Map  </span><br><span class="line">    //这里是生成一个对象，生成这个对象的作用是将每一个键的值均关联于此对象，以满足HashMap的键值对  </span><br><span class="line">    private static final Object PRESENT = new Object();  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has </span><br><span class="line">     * default initial capacity (16) and load factor (0.75). </span><br><span class="line">     */  </span><br><span class="line">    //这里是一个构造函数，开构生成一个HashMap对象，用来存放数据  </span><br><span class="line">    public HashSet() &#123;  </span><br><span class="line">    map = new HashMap&lt;E,Object&gt;();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中得出的结论是HashSet的确是采用HashMap来实现的，而且每一个键都关键同一个Object类的对象，因此键所关联的值没有意义，真正有意义的是键。而HashMap里的键是不允许重复的，因此1也就很容易明白了。 </p><p><strong>对于区别2，继续看源代码如下</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从这里可以看得出Hashtable是继承于Dictionary,实现了Map接口  </span><br><span class="line">public class Hashtable&lt;K,V&gt;  </span><br><span class="line">    extends Dictionary&lt;K,V&gt;  </span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//这里可以看出的是HashMap是继承于AbstractMap类，实现了Map接口  </span><br><span class="line">//因此与Hashtable继承的父类不同  </span><br><span class="line">public class HashMap&lt;K,V&gt;  </span><br><span class="line">    extends AbstractMap&lt;K,V&gt;  </span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><p><strong>区别3，找一个具有针对性的方法看看，这个方法就是put</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Hashtable里的向集体增加键值对的方法，从这里可以明显看到的是  </span><br><span class="line">//采用了synchronized关键字，这个关键字的作用就是用于线程的同步操作  </span><br><span class="line">//因此下面这个方法对于多线程来说是安全的，但这会影响效率     </span><br><span class="line">public synchronized V put(K key, V value) &#123;  </span><br><span class="line">    // Make sure the value is not null  </span><br><span class="line">    //如果值为空的，则会抛出异常  </span><br><span class="line">    if (value == null) &#123;  </span><br><span class="line">        throw new NullPointerException();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Makes sure the key is not already in the hashtable.  </span><br><span class="line">    Entry tab[] = table;  </span><br><span class="line">    //获得键值的hashCode,从这里也可以看得出key!=null,否则的话会抛出异常的呦  </span><br><span class="line">    int hash = key.hashCode();  </span><br><span class="line">    //获取键据所在的哈希表的位置  </span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;  </span><br><span class="line">    //从下面这个循环中可以看出的是，内部实现采用了链表，即桶状结构  </span><br><span class="line">    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;  </span><br><span class="line">        //如果向Hashtable中增加同一个元素时，则会重新更新元素的值   </span><br><span class="line">        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class="line">                V old = e.value;  </span><br><span class="line">                e.value = value;  </span><br><span class="line">                return old;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //后面的暂时不用管它，大概的意思就是内存的个数少于某个阀值时，进行重新分配内存  </span><br><span class="line">    modCount++;  </span><br><span class="line">    if (count &gt;= threshold) &#123;  </span><br><span class="line">        // Rehash the table if the threshold is exceeded  </span><br><span class="line">        rehash();  </span><br><span class="line">  </span><br><span class="line">            tab = table;  </span><br><span class="line">            index = (hash &amp; 0x7FFFFFFF) % tab.length;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//HashMap中的实现则相对来说要简单的很多了，如下代码  </span><br><span class="line">//这里的代码中没有synchronize关键字，即可以看出，这个关键函数不是线程安全的  </span><br><span class="line">    public V put(K key, V value) &#123;  </span><br><span class="line">    //对于键是空时，将向Map中放值一个null-value构成的键值对  </span><br><span class="line">    //对值却没有进行判空处理，意味着可以有多个具有键，键所对应的值却为空的元素。  </span><br><span class="line">        if (key == null)  </span><br><span class="line">            return putForNullKey(value);  </span><br><span class="line">    //算出键所在的哈希表的位置  </span><br><span class="line">        int hash = hash(key.hashCode());  </span><br><span class="line">        int i = indexFor(hash, table.length);  </span><br><span class="line">    //同样从这里可以看得出来的是采用的是链表结构，采用的是桶状  </span><br><span class="line">        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </span><br><span class="line">            Object k;  </span><br><span class="line">            //对于向集体中增加具有相同键的情况时，这里可以看出，并不增加进去，而是进行更新操作  </span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">                V oldValue = e.value;  </span><br><span class="line">                e.value = value;  </span><br><span class="line">                e.recordAccess(this);  </span><br><span class="line">                return oldValue;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        //开始增加元素  </span><br><span class="line">        modCount++;  </span><br><span class="line">        addEntry(hash, key, value, i);  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>区别4在上面的代码中，已经分析了，可以再细看一下</strong></p><p><strong>区别5内存初化大小不同，看看两者的源代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable() &#123;  </span><br><span class="line">   //从这里可以看出，默认的初始化大小11，这里的11并不是11个字节，而是11个Entry,这个Entry是  </span><br><span class="line">   //实现链表的关键结构  </span><br><span class="line">   //这里的0.75代表的是装载因子  </span><br><span class="line">this(11, 0.75f);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//这里均是一些定义  </span><br><span class="line"> public HashMap() &#123;  </span><br><span class="line"> //这个默认的装载因子也是0.75  </span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;  </span><br><span class="line"> //默认的痤为0.75*16  </span><br><span class="line">     threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);  </span><br><span class="line"> //这里开始是默认的初始化大小，这里大小是16  </span><br><span class="line">     table = new Entry[DEFAULT_INITIAL_CAPACITY];  </span><br><span class="line">     init();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，可以看出的是两者的默认大小是不同的，一个是11，一个是16</p><p><strong>区别6内存的扩容方式，</strong>看一看源代码也是很清楚的，其实区别是不大的，一个是2<em>oldCapacity+1, 一个是2</em>oldCapacity,你说大吗:）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Hashtable中调整内存的函数，这个函数没有synchronize关键字，但是protected呦  </span><br><span class="line">protected void rehash() &#123;  </span><br><span class="line">    //获取原来的表大小  </span><br><span class="line">    int oldCapacity = table.length;  </span><br><span class="line">    Entry[] oldMap = table;  </span><br><span class="line">  //设置新的大小为2*oldCapacity+1  </span><br><span class="line">    int newCapacity = oldCapacity * 2 + 1;  </span><br><span class="line">    //开设空间  </span><br><span class="line">    Entry[] newMap = new Entry[newCapacity];  </span><br><span class="line">  //以下就不用管了。。。  </span><br><span class="line">    modCount++;  </span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);  </span><br><span class="line">    table = newMap;  </span><br><span class="line">  </span><br><span class="line">    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;  </span><br><span class="line">        for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123;  </span><br><span class="line">        Entry&lt;K,V&gt; e = old;  </span><br><span class="line">        old = old.next;  </span><br><span class="line">  </span><br><span class="line">        int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;  </span><br><span class="line">        e.next = newMap[index];  </span><br><span class="line">        newMap[index] = e;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//HashMap中要简单的多了，看看就知道了  </span><br><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;  </span><br><span class="line">Entry&lt;K,V&gt; e = table[bucketIndex];  </span><br><span class="line">       table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);  </span><br><span class="line">       //如果超过了阀值  </span><br><span class="line">       if (size++ &gt;= threshold)  </span><br><span class="line">       //就将大小设置为原来的2倍  </span><br><span class="line">           resize(2 * table.length);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对于区别7的哈希值计算方法的不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Hashtable中可以看出的是直接采用关键字的hashcode作为哈希值  </span><br><span class="line">int hash = key.hashCode();  </span><br><span class="line">//然后进行模运算，求出所在哗然表的位置   </span><br><span class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//HashMap中的实现  </span><br><span class="line">//这两行代码的意思是先计算hashcode,然后再求其在哈希表的相应位置        </span><br><span class="line">int hash = hash(key.hashCode());  </span><br><span class="line">int i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure><p>上面的HashMap中可以看出关键在两个函数hash与indexFor</p><p>源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int hash(int h) &#123;  </span><br><span class="line">    // This function ensures that hashCodes that differ only by  </span><br><span class="line">    // constant multiples at each bit position have a bounded  </span><br><span class="line">    // number of collisions (approximately 8 at default load factor).  </span><br><span class="line">    //这个我就不多说了，&gt;&gt;&gt;这个是无符号右移运算符，可以理解为无符号整型  </span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//求位于哈希表中的位置  </span><br><span class="line"> static int indexFor(int h, int length) &#123;  </span><br><span class="line">     return h &amp; (length-1);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; HashMap、HashSet、HashTable之间的区别是Java程序员的一个常见面试题目，在此仅以此博客记录，并深入源代码进行分析：&lt;/p&gt;
&lt;p&gt;在分析之前，先将其区别列于下面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1、HashSet底层采用的是HashMap进行实现的，但
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashSet学习笔记</title>
    <link href="http://yoursite.com/2018/06/05/HashSet%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/05/HashSet学习笔记/</id>
    <published>2018-06-05T11:45:43.802Z</published>
    <updated>2018-06-05T11:43:32.104Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇详细总结了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet的原理应该很好理解!</p><p> 一.HsahSet概述</p><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;  </span><br><span class="line">    extends AbstractSet&lt;E&gt;  </span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable  123</span><br></pre></td></tr></table></figure><p>HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。<br><strong>基本属性：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 底层使用HashMap来保存HashSet中所有元素。</span><br><span class="line">    private transient HashMap&lt;E, Object&gt; map;</span><br><span class="line"></span><br><span class="line">    // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。</span><br><span class="line">    private static final Object PRESENT = new Object();12345</span><br></pre></td></tr></table></figure><p><strong>构造函数：</strong><br>从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。</p><h2 id="二-HsahSet实现"><a href="#二-HsahSet实现" class="headerlink" title="二.HsahSet实现"></a>二.HsahSet实现</h2><p>因为HashSet是基于HashMap，所以对于HashSet，其方法的实现过程是非常简单的。<br>\1. iterator()<br>iterator()方法 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层实际调用底层HashMap的keySet来返回所有的key。 可见HashSet中的元素，只是存放在了底层HashMap的key上， value使用一个static final的Object对象标识。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return map.keySet().iterator();</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>2.size()<br>返回此set中的元素的数量（set的容量）。底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数,即HashMap容器的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">        return map.size();</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>3.isEmpty()<br>isEmpty()判断HashSet()集合是否为空，如果此set不包含任何元素，则返回true。 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">        return map.isEmpty();</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>4.contains(Object o)<br>contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">        return map.containsKey(o);</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>5.add()<br>add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT) == null;</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>6.remove()<br>remove()如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">        return map.remove(o) == PRESENT;</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>7.clear()<br>clear()从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;123</span><br></pre></td></tr></table></figure><p>8.clone()<br>底层实际调用HashMap的clone()方法，获取HashMap的浅表副本,并没有复制这些元素本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            return newSet;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇详细总结了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet的原理应该很好理解!&lt;/p&gt;
&lt;p&gt; 一.HsahSet概述&lt;/p&gt;
&lt;p&gt;HashSet
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashTable学习笔记</title>
    <link href="http://yoursite.com/2018/06/05/HashTable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/05/HashTable学习笔记/</id>
    <published>2018-06-05T11:44:58.795Z</published>
    <updated>2018-06-05T11:42:12.029Z</updated>
    
    <content type="html"><![CDATA[<p> 有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。 </p><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>HashTable在Java中的定义如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Hashtable&lt;K,V&gt;  </span><br><span class="line">    extends Dictionary&lt;K,V&gt;  </span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 <code>Hashtable</code>）的抽象父类。每个键和每个值都是一个对象。在任何一个 <code>Dictionary</code> 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。</p><p>​        HashTable采用”拉链法”实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。</p><p>​        table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的”key-value键值对”都是存储在Entry数组中的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。</span><br><span class="line">threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。</span><br><span class="line">loadFactor：加载因子。</span><br><span class="line">modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</span><br></pre></td></tr></table></figure><h3 id="二、构造方法"><a href="#二、构造方法" class="headerlink" title="二、构造方法"></a>二、构造方法</h3><p>​        在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable() &#123;  </span><br><span class="line">        this(11, 0.75f);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  默认构造函数，容量为11，加载因子为0.75。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity) &#123;  </span><br><span class="line">        this(initialCapacity, 0.75f);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>   用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;  </span><br><span class="line">        //验证初始容量  </span><br><span class="line">        if (initialCapacity &lt; 0)  </span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+  </span><br><span class="line">                                               initialCapacity);  </span><br><span class="line">        //验证加载因子  </span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  </span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);  </span><br><span class="line">  </span><br><span class="line">        if (initialCapacity==0)  </span><br><span class="line">            initialCapacity = 1;  </span><br><span class="line">          </span><br><span class="line">        this.loadFactor = loadFactor;  </span><br><span class="line">          </span><br><span class="line">        //初始化table，获得大小为initialCapacity的table数组  </span><br><span class="line">        table = new Entry[initialCapacity];  </span><br><span class="line">        //计算阀值  </span><br><span class="line">        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  </span><br><span class="line">        //初始化HashSeed值  </span><br><span class="line">        initHashSeedAsNeeded(initialCapacity);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;  </span><br><span class="line">        return hashSeed ^ k.hashCode();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造一个与给定的 Map 具有相同映射关系的新哈希表。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123;  </span><br><span class="line">        //设置table容器大小，其值==t.size * 2 + 1  </span><br><span class="line">        this(Math.max(2*t.size(), 11), 0.75f);  </span><br><span class="line">        putAll(t);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="三、主要方法"><a href="#三、主要方法" class="headerlink" title="三、主要方法"></a>三、主要方法</h3><p>​        HashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。</p><p>​        首先我们先看put方法：将指定 <code>key</code> 映射到此哈希表中的指定 <code>value</code>。注意这里键key和值value都不可为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;  </span><br><span class="line">        // 确保value不为null  </span><br><span class="line">        if (value == null) &#123;  </span><br><span class="line">            throw new NullPointerException();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        /* </span><br><span class="line">         * 确保key在table[]是不重复的 </span><br><span class="line">         * 处理过程： </span><br><span class="line">         * 1、计算key的hash值，确认在table[]中的索引位置 </span><br><span class="line">         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 </span><br><span class="line">         */  </span><br><span class="line">        Entry tab[] = table;  </span><br><span class="line">        int hash = hash(key);    //计算key的hash值  </span><br><span class="line">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  </span><br><span class="line">        //迭代，寻找该key，替换  </span><br><span class="line">        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;  </span><br><span class="line">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class="line">                V old = e.value;  </span><br><span class="line">                e.value = value;  </span><br><span class="line">                return old;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        modCount++;  </span><br><span class="line">        if (count &gt;= threshold) &#123;  //如果容器中的元素数量已经达到阀值，则进行扩容操作  </span><br><span class="line">            rehash();  </span><br><span class="line">            tab = table;  </span><br><span class="line">            hash = hash(key);  </span><br><span class="line">            index = (hash &amp; 0x7FFFFFFF) % tab.length;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 在索引位置处插入一个新的节点  </span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];  </span><br><span class="line">        tab[index] = new Entry&lt;&gt;(hash, key, value, e);  </span><br><span class="line">        //容器中元素+1  </span><br><span class="line">        count++;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：</p><p>​        首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-28515026422c7c95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-ebe6bcbee1d46f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p> 在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。</p><p> 在HashTabled的put方法中有两个地方需要注意：</p><p>​        <strong>1、</strong>HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;  </span><br><span class="line">        int oldCapacity = table.length;  </span><br><span class="line">        //元素  </span><br><span class="line">        Entry&lt;K,V&gt;[] oldMap = table;  </span><br><span class="line">  </span><br><span class="line">        //新容量=旧容量 * 2 + 1  </span><br><span class="line">        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;  </span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;  </span><br><span class="line">            if (oldCapacity == MAX_ARRAY_SIZE)  </span><br><span class="line">                return;  </span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        //新建一个size = newCapacity 的HashTable  </span><br><span class="line">        Entry&lt;K,V&gt;[] newMap = new Entry[];  </span><br><span class="line">  </span><br><span class="line">        modCount++;  </span><br><span class="line">        //重新计算阀值  </span><br><span class="line">        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  </span><br><span class="line">        //重新计算hashSeed  </span><br><span class="line">        boolean rehash = initHashSeedAsNeeded(newCapacity);  </span><br><span class="line">  </span><br><span class="line">        table = newMap;  </span><br><span class="line">        //将原来的元素拷贝到新的HashTable中  </span><br><span class="line">        for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;  </span><br><span class="line">            for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123;  </span><br><span class="line">                Entry&lt;K,V&gt; e = old;  </span><br><span class="line">                old = old.next;  </span><br><span class="line">  </span><br><span class="line">                if (rehash) &#123;  </span><br><span class="line">                    e.hash = hash(e.key);  </span><br><span class="line">                &#125;  </span><br><span class="line">                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;  </span><br><span class="line">                e.next = newMap[index];  </span><br><span class="line">                newMap[index] = e;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 11 <em> 2 + 1 =23，而阀值threshold=23</em>0.75 = 17，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。 </p><p> <strong>2、</strong>其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash &amp; 0x7FFFFFFF）。下面是计算key的hash值，这里hashSeed发挥了作用。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Object k) &#123;  </span><br><span class="line">        return hashSeed ^ k.hashCode();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;  </span><br><span class="line">        Entry tab[] = table;  </span><br><span class="line">        int hash = hash(key);  </span><br><span class="line">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;  </span><br><span class="line">        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123;  </span><br><span class="line">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;  </span><br><span class="line">                return e.value;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return null;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四、HashTable与HashMap的区别"><a href="#四、HashTable与HashMap的区别" class="headerlink" title="四、HashTable与HashMap的区别"></a>四、HashTable与HashMap的区别</h3><p>​        HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。</p><p>​        <strong>第一：</strong>我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。</p><p>​        <strong>第二：</strong>HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：</p><p>​        当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (key == null)  </span><br><span class="line">            return putForNullKey(value);</span><br></pre></td></tr></table></figure><p>而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (value == null) &#123;  </span><br><span class="line">            throw new NullPointerException();  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p> <strong>第三：</strong>Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以同步访问潜在的HashMap。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashT
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap原理及实现学习总结</title>
    <link href="http://yoursite.com/2018/06/05/HashMap%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/05/HashMap原理及实现学习总结/</id>
    <published>2018-06-05T11:43:55.434Z</published>
    <updated>2018-06-05T11:49:30.491Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap是Java中最常用的集合类框架之一，是Java语言中非常典型的数据结构。本篇主要是从HashMap的工作原理，数据结构分析，HashMap存储和读取几个方面对其进行学习总结。 </p><h2 id="一-HashMap的工作原理"><a href="#一-HashMap的工作原理" class="headerlink" title="一. HashMap的工作原理"></a>一. HashMap的工作原理</h2><p>HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。<br>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的LinkedList中。键对象的equals()方法用来找到键值对。</p><h2 id="二-HashMap的定义"><a href="#二-HashMap的定义" class="headerlink" title="二.HashMap的定义"></a>二.HashMap的定义</h2><p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt;  </span><br><span class="line">    extends AbstractMap&lt;K,V&gt;  </span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable  123</span><br></pre></td></tr></table></figure><h2 id="三-HashMap的数据结构"><a href="#三-HashMap的数据结构" class="headerlink" title="三.HashMap的数据结构"></a>三.HashMap的数据结构</h2><p>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-cb0a6e8005bc2bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。 </p><h2 id="四-HashMap的构造函数"><a href="#四-HashMap的构造函数" class="headerlink" title="四.HashMap的构造函数"></a>四.HashMap的构造函数</h2><p>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。<br>HashMap一共重载了4个构造方法，分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap();//构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</span><br><span class="line">HashMap(int initialCapacity);//构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</span><br><span class="line">HashMap(int initialCapacity, float loadFactor);//构造一个带指定初始容量和加载因子的空 HashMap。</span><br><span class="line">HashMap(Map&lt;? extendsK,? extendsV&gt; m); //构造一个映射关系与指定 Map 相同的 HashMap。1234</span><br></pre></td></tr></table></figure><p>下面是第三个构造方法源码，其它构造方法最终调用的都是它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个带指定初始容量和加载因子的空 HashMap。</span><br><span class="line">    public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        // 如果指定初始容量小于0，抛错</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);</span><br><span class="line">        // 如果初始容量大于系统默认最大容量，则初始容量为最大容量</span><br><span class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        // 如果loadFactor小于0，或loadFactor是NaN，则抛错</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);</span><br><span class="line"></span><br><span class="line">        // 寻找一个2的k次幂capacity恰好大于initialCapacity</span><br><span class="line">        int capacity = 1;</span><br><span class="line">        while (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        // 设置加载因子</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        // 设置阈值为capacity * loadFactor，实际上当HashMap当前size到达这个阈值时，HashMap就需要扩大一倍了。</span><br><span class="line">        threshold = (int) (capacity * loadFactor);</span><br><span class="line">        // 创建一个capacity长度的数组用于保存数据</span><br><span class="line">        table = new Entry[capacity];</span><br><span class="line">        // 开始初始化</span><br><span class="line">        init();</span><br><span class="line">    &#125;1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure><p>从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 内置class输入对象，也就是我们说的桶</span><br><span class="line">    static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K, V&gt; next;</span><br><span class="line">        final int hash;</span><br><span class="line"></span><br><span class="line">        // 构造函数</span><br><span class="line">        Entry(int h, K k, V v, Entry&lt;K, V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回key</span><br><span class="line">        public final K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回value</span><br><span class="line">        public final V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置value</span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 是否相同</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            // 如果o不是Map.Entry的实例，那么肯定不相同了</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            // 将o转成Map.Entry</span><br><span class="line">            Map.Entry e = (Map.Entry) o;</span><br><span class="line">            // 得到key和value对比是否相同，相同则为true</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则为false</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // hashCode</span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 返回String</span><br><span class="line">        public final String toString() &#123;</span><br><span class="line">            return getKey() + &quot;=&quot; + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 使用该方法证明该key已经在该map中</span><br><span class="line">        void recordAccess(HashMap&lt;K, V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 该方法记录该key已经被移除了</span><br><span class="line">        void recordRemoval(HashMap&lt;K, V&gt; m) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。</p><h2 id="五-HashMap的存储实现"><a href="#五-HashMap的存储实现" class="headerlink" title="五.HashMap的存储实现"></a>五.HashMap的存储实现</h2><p>HashMap中我们最长用的就是put(K, V)和get(K)。我们都知道，HashMap的K值是唯一的，那如何保证唯一性呢？我们首先想到的是用equals比较，没错，这样可以实现，但随着内部元素的增多，put和get的效率将越来越低，这里的时间复杂度是O(n)，假如有1000个元素，put时需要比较1000次。实际上，HashMap很少会用到equals方法，因为其内通过一个哈希表管理所有元素，哈希是通过hash单词音译过来的，也可以称为散列表，哈希算法可以快速的存取元素，当我们调用put存值时，HashMap首先会调用K的hashCode方法，获取哈希码，通过哈希码快速找到某个存放位置，这个位置可以被称之为bucketIndex，通过上面所述hashCode的协定可以知道，如果hashCode不同，equals一定为false，如果hashCode相同，equals不一定为true。所以理论上，hashCode可能存在冲突的情况，有个专业名词叫碰撞，当碰撞发生时，计算出的bucketIndex也是相同的，这时会取到bucketIndex位置已存储的元素，最终通过equals来比较，equals方法就是哈希码碰撞时才会执行的方法，所以前面说HashMap很少会用到equals。HashMap通过hashCode和equals最终判断出K是否已存在，如果已存在，则使用新V值替换旧V值，并返回旧V值，如果不存在 ，则存放新的键值对到bucketIndex位置。整个put过程的流程图如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-17e797425f9b3d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        // 当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因 </span><br><span class="line">        if (key == null)</span><br><span class="line">            return putForNullKey(value);</span><br><span class="line">        // 使用hash函数预处理hashCode，计算key的hash值  </span><br><span class="line">        int hash = hash(key.hashCode());//-------（1）</span><br><span class="line">        // 计算key hash 值在 table 数组中的位置 </span><br><span class="line">        int i = indexFor(hash, table.length);//------(2)</span><br><span class="line">        // 从i出开始迭代 e,找到 key 保存的位置</span><br><span class="line">        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            // 判断该条链上是否有hash值相同的(key相同) </span><br><span class="line">            // 若存在相同，则直接覆盖value，返回旧value </span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                // 旧值 = 新值  </span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                // 将要存储的value存进去</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                // 返回旧的value</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 修改次数增加1 </span><br><span class="line">        modCount++;</span><br><span class="line">        // 将key、value添加至i位置处 </span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure><p>通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：<br>1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。<br>2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int hash(int h) &#123;  </span><br><span class="line">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);  </span><br><span class="line">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);  </span><br><span class="line">    &#125;  1234</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。</span><br><span class="line">12</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int h, int length) &#123;  </span><br><span class="line">        return h &amp; (length-1);  </span><br><span class="line">    &#125; 123</span><br></pre></td></tr></table></figure><p>HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。<br>这里再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个新的桶来保存该key和value</span><br><span class="line">    void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">        // 获取bucketIndex处的Entry </span><br><span class="line">        Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">        // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry  </span><br><span class="line">        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);</span><br><span class="line">        // 若HashMap中元素的个数超过极限了，则容量扩大两倍 </span><br><span class="line">        if (size++ &gt;= threshold)</span><br><span class="line">            // 调整容量</span><br><span class="line">            resize(2 * table.length);</span><br><span class="line">    &#125;1234567891011</span><br></pre></td></tr></table></figure><p>这个方法中有两点需要注意：<br>一是链的产生：系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。<br>二是扩容问题：随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h2 id="六-HashMap的读取实现"><a href="#六-HashMap的读取实现" class="headerlink" title="六.HashMap的读取实现"></a>六.HashMap的读取实现</h2><p>通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 返回指定键所映射的值；如果对于该键来说，此映射不包含任何映射关系，则返回 null</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        // 若为null，调用getForNullKey方法返回相对应的value </span><br><span class="line">        if (key == null)</span><br><span class="line">            return getForNullKey();</span><br><span class="line">        // 根据该 key 的 hashCode 值计算它的 hash 码  </span><br><span class="line">        int hash = hash(key.hashCode());</span><br><span class="line">        // 取出 table 数组中指定索引处的值</span><br><span class="line">        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            // 如果hash值相等，并且key相等则证明这个桶里的东西是我们想要的</span><br><span class="line">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        // 所有桶都找遍了，没找到想要的，所以返回null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;1234567891011121314151617</span><br></pre></td></tr></table></figure><p>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</p><h2 id="七-HashMap和多线程相关的问题"><a href="#七-HashMap和多线程相关的问题" class="headerlink" title="七.HashMap和多线程相关的问题"></a>七.HashMap和多线程相关的问题</h2><p>HashMap是线程不安全的实现，而HashTable是线程安全的实现。所谓线程不安全，就是在多线程情况下直接使用HashMap会出现一些莫名其妙不可预知的问题，多线程和单线程的区别：单线程只有一条执行路径，而多线程是并发执行(非并行)，会有多条执行路径。如果HashMap是只读的(加载一次，以后只有读取，不会发生结构上的修改)，那使用没有问题。那如果HashMap是可写的(会发生结构上的修改)，则会引发诸多问题，如上面的fail-fast，也可以看下这里，这里就不去研究了。<br>那在多线程下使用HashMap我们需要怎么做，几种方案：<br>1.在外部包装HashMap，实现同步机制<br>2.使用Map m = Collections.synchronizedMap(new HashMap(…));，这里就是对HashMap做了一次包装<br>3.使用java.util.HashTable，效率最低<br>4.使用java.util.concurrent.ConcurrentHashMap，相对安全，效率较高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashMap是Java中最常用的集合类框架之一，是Java语言中非常典型的数据结构。本篇主要是从HashMap的工作原理，数据结构分析，HashMap存储和读取几个方面对其进行学习总结。 &lt;/p&gt;
&lt;h2 id=&quot;一-HashMap的工作原理&quot;&gt;&lt;a href=&quot;#一-H
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSH项目技术点总结</title>
    <link href="http://yoursite.com/2018/06/05/SSH%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/05/SSH项目技术点总结/</id>
    <published>2018-06-05T08:36:47.418Z</published>
    <updated>2018-06-05T08:50:52.523Z</updated>
    
    <content type="html"><![CDATA[<p>分享一下总结的去年做过的一个传统ssh项目所用到的一些技术点，准备面试换工作的小伙伴们可以看看。</p><p><strong>1.什么是git，和svn的区别</strong></p><blockquote><p>git是一个分布式的版本控制系统,一般用于代码的版本控制,类似于svn,区别在于git可以在建立本地仓库，这样代码可以提交到本地，这样可以断网提交，可以查找本地的代码提交历史记录。git有像github,码云这样的代码托管网站(我们项目就放在github上),下代码很方便。</p></blockquote><p><strong>2.什么是maven, maven中的依赖范围，依赖传递是什么意思</strong></p><blockquote><p>maven是一个软件项目管理工具,一般用它的配置文件pom来加载jar包,也可以用来编译工程发布工程<br>安装一个外包maven并整合到eclipse中，通过配置文件指定jar包的本地仓库，私服，和中央仓库，镜像等。<br>通过maven引入jar包，也通过maven将工程发布出去给其它工程引用。<br>依赖范围是用来控制打jar包的范围。<br>compile 编译、测试、运行<br>provided 编译、和测试有效<br>runtime：测试、运行有效。<br>test：只是测试有效，只在单元测试类中用。<br>依赖传递 就近原则<br>坐标 </p></blockquote><p><strong>3.spring的原理，它是如何整合其它框架的</strong></p><blockquote><p>AOP(面向切面编程) 对指定的业务进行统一的增强，如事务处理，日志记录，性能统计，将这些代码从业务逻辑代码中抽取出来。<br>IOC(控制反转)DI(依赖注入)<br>(1)项目引入的bean对象不用我们从bean工厂取，而是通过sring里的配置文件得到<br>（2）web层调service,service调dao都是通过加注解的方式，让spring注入进来，不用我们new出来<br>spring一般通过配置文件将其它框架整合进来，在配置文件中配置bean工厂或模板和相关的属性，这样我们就不需要自己new出来bean工厂而是由spring统一得到</p></blockquote><p><strong>4.什么是模型驱动，什么是领域驱动建模，有什么好处</strong></p><blockquote><p>模型驱动是使用javaBean对象来封装请求参数，在整个MVC流程中可以直接使用这个对象,用起来方便（对比属性驱动，对比servlet中request.getParameter）</p><p>领域驱动建模是对业务对象的的抽取，就程序来说领域模型就是java里面的实体bean(domain),我们将这些实体bean抽取出来，通过maven配置引入，不同的工程就都可以使用这些模型。</p></blockquote><p><strong>5.什么是jpa,springdatajpa和hibernate之间的关系</strong></p><blockquote><p>jpa是sun公司定义的一套数据持久层的标准，是一种规范 hibernate是具体的技术实现 还有别的技术（Toplink等）但不流行了。类似于接口和实现类的关系<br>jpa定义的是一系列的接口和注解。Spring Data JPA 是在JPA规范的基础下提供了Repository层的实现<br>好处 用jpa方式 开发者面向JPA规范的接口 不必关注底层的JPA实现 哪种好用哪个 不用再去学习一套新的技术<br>减少学习成本。</p></blockquote><p><strong>6.用springdatajpa有什么好处,为什么</strong></p><blockquote><p>对于Oracle数据库，我们自己编写的dao 继承了jparepository接口 在具体实用时由 sprinrg容器给我们注入进一个实现类，<br>使用springdatajpa抽象了具体的数据库操作，项目中用的redis,elasticsearch和ehcache都可以通过springdatajpa来操作</p></blockquote><p><strong>7.webservice是干什么的</strong></p><blockquote><p>webservice就是多项目，多平台之间进行方法调用的一种技术，现在工作中用cxf框架通过spring配置进项目来，用起来很简单的，只要在普通的服务上加上对应的注解就可以发布出去了。<br>webservice分成两种方式，一种是传统的基于sopa协议的方式，一种是rest的方式，传统的ws的方式不太常用了,我们项目中是用的就是rest的方式</p></blockquote><p><strong>8.webservice的两种实现方式rs和ws的区别</strong></p><blockquote><p>rs和ws的最主要的是rest是用的http协议，传统ws用的是soap协议，一般ws用的是xml格式而rs用的多是json格式，如果是完全基于restful风格，那么发布的服务就是一个资源,具体的增删改查方式是通过请求方式post,delete,put,get的方式来确定的。<br>rs更方便，更流行一些，因为它是返回json格式 访问服务的客户端只用通过工具webClient或者httpclient就可以访问了。</p></blockquote><p><strong>9.分页查询的参数，及查询后的数据是如何返回的</strong></p><blockquote><p>请求参数页码，每页记录数<br>返回总记录数和当前页数据记录 一般返回的当前页数据是一个list集合, 我们要把list和总记录数封装到一个对象中返回前端页面</p></blockquote><p><strong>10.AngularJS的几个特性,什么是路由</strong></p><blockquote><p>MVC,（模仿后台框架的MVC Controller就是js代码，Model）<br>双向数据绑定(更新模型，视图会自动更新，更新视图，模型会自动更新)<br>模块化设计<br>官方提供的模块 ng、ngRoute<br>用户自定义的模块 angular.module(‘模块名’,[ ])<br>angularJs实现单页面多视图的页面跳转效果 类似于url跳转</p></blockquote><p><strong>11.什么是消息队列(mq) 消息服务器的应用场景和队列的两种方式</strong></p><blockquote><p>消息队列中间件是分布式系统中的一种的组件，主要解决应用服务之间耦合,异步消息，流量削锋,等问题实现提高系统性能的一种架构<br>2、ActiveMQ 应用场景分析<br>1）用户注册，重点用户信息数据库保存，发短信、发邮件，增加业务处理复杂度，这时候用MQ，将发短信、发邮箱，通知MQ，由另外服务平台完成<br>2）搜索平台、缓存平台<br>查询数据，建立缓存、索引，不从数据库查询，从缓存或者索引库查询<br>当增加、修改，删除数据时，发送消息给MQ，缓存平台、索引平台从MQ获取到这个消息，更新缓存或者索引<br>1）Queue队列，生产者生产了一个消息，只能由一个消费者进行消费<br>2）Topic话题，生产者生产了一个消息，可以由多个消费者进行消费</p></blockquote><p><strong>12.什么是页面静态化，如何实现,有什么好处</strong></p><blockquote><p>Freemarker</p><p>将动态数据访问，生成为一个静态html页面，提高查询效率<br>页面静态化，其实就是将动态生成的jsp页面，变成静态的HTML页面，让用户直接访问。有一下几方面好处：<br>1，首先就是访问速度，不需要去访问数据库，或者缓存来获取哪些数据，浏览器直接加载渲染html页即可。所以可以大大的提高访问效率；<br>2，从网站优化来分析，搜索引擎更喜欢静态的网页，静态网页与动态网页相比，搜索引擎更喜欢静的，更便于抓取，搜索引擎SEO排名更容易提高。<br>3，从安全角度讲，静态网页不宜遭到黑客攻击，如果黑客不知道你网站的后台、网站采用程序、数据库的地址，静态网页， 更不容易受到黑客的攻击。<br>4，从网站稳定性来讲，如果程序、数据库出了问题，会直接影响网站的访问，而静态网页就避免了如此情况，不会因为程序等，而损失网站数据，影响正常打开，损失用户体验，影响网站信任度。<br>注意问题：<br>1，随着项目的扩大，静态html页面将会不断的增大，增多，所以要注意管理这些静态页面。例如路径的管理,及时更新的管理等等。<br>2，有些页面并不一定非要来静态化，但是为了避免地址暴露过多的信息，也可以用URL伪静态，使页面看起来就像静态页面一样，原理只是一个Filter。</p></blockquote><p><strong>13.Quartz是什么，应用场景</strong></p><blockquote><p>定时任务框架<br>用户解冻：比如用户在登录的时候，连续输错3次密码后，系统会将该用户冻结，不再允许该用户登录系统，等到了晚上零晨时分，再为所有被冻结的用户解冻，这样，用户在第二天又可以正常登录系统<br>抓取日志:比如需要在每天凌晨时候，分析一次前一天的日志信息<br>sheduler</p><p>job jobFactory</p><p>trigger</p></blockquote><p><strong>14.elasticserach是什么，原理, 如何使用，和lucene的关系</strong></p><blockquote><p>1、Lucene就是一套全文检索编程API，基于Lucene对数据建立索引，进行查询。<br>2、现代企业开发中，更常用的是solr搜索服务器和ElasticSearch搜索服务器。<br>主要概念<br>索引 文档 文档类型 映射<br>1）索引对象（数据存在哪？）：存储数据的表结构，任何搜索数据，存放在索引对象上<br>2）映射（数据怎么存？）：数据如何存放到索引对象上，需要有一个映射配置，数据类型、是否存储、是否分词…<br>3）文档（存什么数据？）：一条数据记录，存在索引对象上<br>4）文档类型（数据有哪些类型？）：一个索引对象，存放多种类型数据，数据用文档类型进行标识<br>编程步骤</p><p>1）建立索引对象</p><p>2）建立映射</p><p>3）存储数据【文档】</p><p>4）指定文档类型进行搜索数据【文档】</p><p>5）查询数据【文档】</p></blockquote><p><strong>15.缓存的原理，redis和ehcache的比较</strong></p><blockquote><p>缓存可以提高查询性能，对同一批数据进行多次查询时，第一次查询走数据库，查询数据后，将数据保存在内存中，第二次以后查询可以直接从内存获取数据，而不需要和数据库进行交互.<br>最简单的缓存实现可以用一个map实现，map的键存查询语句，map的值存对应查询到的数据。<br>ehcahe和redis的比较<br>ehcache直接在本机jvm虚拟机中缓存，速度快，效率高，本机速度自然是最快的，但重启web容器会一起消亡掉，只能当前web应用访问操作, 做缓存共享麻烦，集群分布式应用不方便。ehcahe可做hibernate的二级缓存。<br>redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。<br>如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。<br>ehcache也有缓存共享方案，不过是通过RMI或者Jgroup多播方式进行广播缓存通知更新，缓存共享复杂，维护不方便；简单的共享可以，但是涉及到缓存恢复，大数据缓存，则不合适。总之ehcache能干的活redis都能干，redis能干的，ehcache不一定。</p></blockquote><p><strong>16.权限控制的几种方式, Shiro如何实现权限控制</strong></p><blockquote><p>第一种：URL级别粗粒度权限控制（重点）<br>配置web.xml的shiroFilter拦截 /<em><br>在spring的applicationContext</em>.xml配置文件中配置同名的bean，配置filterChainDefinitions拦截控制规则<br>xxx.html<em>=anon（未登录可以访问）<br>xxx.html</em>=authc（必须登录才能访问）<br>xxx.html<em>=perms[权限]（需要特定权限才能访问 ）<br>xxx.html</em>=roles[角色]（需要特定角色才能访问）<br>第二种：方法级别细粒度权限控制<br>在spring的applicationContext*.xml配置spring aop对spring管理bean对象开启shiro注解支持<br>@RequiresPermissions(权限) 需要特定权限才能访问<br>@RequiresRoles(角色) 需要特定角色才能访问<br>@RequiresAuthentication 需要认证才能访问<br>Shiro执行流程<br>应用程序—&gt;Subject—&gt;SecurityManager—&gt;Realm—&gt;安全数据</p></blockquote><p><strong>17.延迟加载是什么问题，如何解决</strong></p><blockquote><p>查询数据时当对象中有一对多的关联属性 当要在view层获取数据时比如将对象转化成json，由于session已关闭造成无法读取数据<br>要看实际业务需不需要展示多方数据<br>如果不需要直接加载<br>则在相关属性的get方法上加@JSON(serialize=false)注解<br>如果需要立即加载则有三种方式 效率由底到高<br>1 service中手动查询出来<br>2 加注解 @OneToMany(fetch=FetchType.EAGER)<br>3 配OpenEntityManagerInView filter</p></blockquote><p><strong>18.什么是报表,如何生成报表</strong></p><blockquote><p>报表就是数据的呈现,对于程序员来说就是复杂SQL查询语句，可以生成excel(poi)格式，pdf(ireport)格式或前端highcharts生成图表</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分享一下总结的去年做过的一个传统ssh项目所用到的一些技术点，准备面试换工作的小伙伴们可以看看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.什么是git，和svn的区别&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git是一个分布式的版本控制系统,一般用于代码的版本控
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angularjs前端页面跳转与参数传递</title>
    <link href="http://yoursite.com/2018/06/05/angularjs%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/06/05/angularjs前端页面跳转与参数传递/</id>
    <published>2018-06-05T06:25:03.629Z</published>
    <updated>2018-06-05T06:29:12.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法一：location-href"><a href="#方法一：location-href" class="headerlink" title="方法一：location.href"></a><strong>方法一：location.href</strong></h2><p>第一个界面:布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> &lt;li ng-repeat=&quot;remindItemData in remindListData&quot; ng-click=&quot;goto(remindItemData)&quot;&gt;</span><br><span class="line"> //do somgthing</span><br><span class="line">&lt;/li&gt;123</span><br></pre></td></tr></table></figure><p>第一个界面:js跳转方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$scope.goto=function (msg) &#123;</span><br><span class="line">    var hre = &apos;remind_info.html?msg=&apos; + angular.toJson(msg);</span><br><span class="line">    //传递对象：先将对象转成字符串（序列化）</span><br><span class="line">    location.href = hre;</span><br><span class="line">&#125;;12345</span><br></pre></td></tr></table></figure><p>第二个界面:js获取参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var urlValue=&apos;&apos;;</span><br><span class="line">var href = location.href; //取得整个地址栏</span><br><span class="line">urlValue = href.substr(href.indexOf(&quot;=&quot;) + 1);</span><br><span class="line">//此处只有一个参数，先截取参数值（等号后的值）。</span><br><span class="line">message=angular.fromJson(decodeURI(urlValue));</span><br><span class="line">//传参会转码，所以先解码，再把字符串string转对象</span><br><span class="line"></span><br><span class="line">if(message.picUrl.length&gt;0)&#123;</span><br><span class="line">    for (var i = 0; i &lt; message.picUrl.length; i++)&#123;</span><br><span class="line">        message.picUrl[i] = decodeURIComponent(message.picUrl[i]);</span><br><span class="line">        //接收的参数在解码转对象时，参数里的MP3或者图片的url未被解码，</span><br><span class="line">        //所以继续decodeURIComponent解码，并重新赋值。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;1234567891011121314</span><br></pre></td></tr></table></figure><h2 id="方法二：标签a-href"><a href="#方法二：标签a-href" class="headerlink" title="方法二：标签a href"></a><strong>方法二：标签a href</strong></h2><p>第一个界面的布局：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;news_detail.html?id=&#123;&#123;items.id&#125;&#125;&quot; ng-cloak&gt;</span><br><span class="line">//do something</span><br><span class="line">&lt;/a&gt;123</span><br></pre></td></tr></table></figure><p>第二个界面的js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var noticeId = &quot;&quot;;</span><br><span class="line">if ($location.search().id) &#123;</span><br><span class="line">    noticeId = $location.search().id;</span><br><span class="line">&#125;1234</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://blog.csdn.net/xuexiiphone/article/details/51822962" target="_blank" rel="noopener">angularjs页面带参跳转以及参数解析</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 带#号的url，看？号的url，见下面  </span><br><span class="line">url = http://qiaole.sinaapp.com?#name=cccccc  </span><br><span class="line"></span><br><span class="line">$location.absUrl();  </span><br><span class="line">// http://qiaole.sinaapp.com?#name=cccccc  </span><br><span class="line"></span><br><span class="line">$location.host();  </span><br><span class="line">// qiaole.sinaapp.com  </span><br><span class="line"></span><br><span class="line">$location.port();  </span><br><span class="line">// 80  </span><br><span class="line"></span><br><span class="line">$location.protocol();  </span><br><span class="line">// http  </span><br><span class="line"></span><br><span class="line">$location.url();  </span><br><span class="line">// ?#name=cccccc  </span><br><span class="line"></span><br><span class="line">// 获取url参数  </span><br><span class="line">$location.search().name;  </span><br><span class="line">// or  </span><br><span class="line">$location.search()[&apos;name&apos;];  </span><br><span class="line"></span><br><span class="line">// 注：如果是这样的地址：http://qiaole.sinaapp.com?name=cccccc  </span><br><span class="line"></span><br><span class="line">var searchApp = angular.module(&apos;searchApp&apos;, []);  </span><br><span class="line">searchApp.config([&apos;$locationProvider&apos;, function($locationProvider) &#123;  </span><br><span class="line">  $locationProvider.html5Mode(true);  </span><br><span class="line">&#125;]);  </span><br><span class="line">searchApp.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$location&apos;, function($scope, $location) &#123;  </span><br><span class="line">  if ($location.search().keyword) &#123;  </span><br><span class="line">    $scope.keyword = $location.search().keyword;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;]);  12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://qiaolevip.iteye.com/blog/2154955" target="_blank" rel="noopener">AngularJs $location获取url参数</a></p><h2 id="angularjs中的location简介"><a href="#angularjs中的location简介" class="headerlink" title="angularjs中的location简介"></a><strong>angularjs中的location简介</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$location服务解析在浏览器地址栏中的URL（基于window.location）并且让URL在你的应用中可用。</span><br><span class="line">改变在地址栏中的URL会作用到$location服务，同样的，改变$location服务也会改变浏览器的地址栏。</span><br><span class="line">（可以使用$location进行重定向等操作）</span><br><span class="line"></span><br><span class="line">$location服务：</span><br><span class="line">暴露浏览器地址栏中的URL，让你可以：</span><br><span class="line"></span><br><span class="line">监察URL。</span><br><span class="line">改变URL。</span><br><span class="line">与浏览器同步URL，当：</span><br><span class="line"></span><br><span class="line">改变地址栏。</span><br><span class="line">单击『前进』『后退』或一个历史记录中的链接。</span><br><span class="line">打开一个链接。</span><br><span class="line">将URL对象表示为一个方法集。 (protocol, host, port, path, search, hash)</span><br><span class="line"></span><br><span class="line">服务依赖：</span><br><span class="line">$browser</span><br><span class="line">$sniffer</span><br><span class="line">$rootElement</span><br><span class="line"></span><br><span class="line">内置方法：</span><br><span class="line">absUrl( )：只读；根据在RFC 3986中指定的规则，返回url，带有所有的片段。</span><br><span class="line"></span><br><span class="line">hash( )：读、写；当带有参数时，返回哈希碎片；当在带有参数的情况下，改变哈希碎片时，返回$location。</span><br><span class="line"></span><br><span class="line">host( )：只读；返回url中的主机路径。</span><br><span class="line"></span><br><span class="line">path( )：读、写；当没有任何参数时，返回当前url的路径；</span><br><span class="line">当带有参数时，改变路径，并返回$location。（返回的路径永远会带有/）</span><br><span class="line"></span><br><span class="line">port( )：只读；返回当前路径的端口号。</span><br><span class="line"></span><br><span class="line">protocol( )：只读；返回当前url的协议。</span><br><span class="line"></span><br><span class="line">replace( )：如果被调用，就会用改变后的URL直接替换浏览器中的历史记录，</span><br><span class="line">而不是在历史记录中新建一条信息，这样可以阻止『后退』。</span><br><span class="line"></span><br><span class="line">search( )：读、写；当不带参数调用的时候，以对象形式返回当前url的搜索部分。</span><br><span class="line"></span><br><span class="line">url( )：读、写；当不带参数时，返回url；当带有参数时，返回$location。</span><br><span class="line"></span><br><span class="line">内置事件：</span><br><span class="line">$locationChangeStart：在URL改变前发生。</span><br><span class="line">这种改变可以通过调用事件的preventDefault方法为阻止。</span><br><span class="line">查看ng.$rootScope.Scope#$on获得更多的细节。成功时触发$locationChangeSuccess事件。</span><br><span class="line"></span><br><span class="line">$locationChangeSuccess：当URL改变后发生。</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">何时使用$location</span><br><span class="line">任何你想要改变当前URL的时候，都可以使用$location。</span><br><span class="line"></span><br><span class="line">$location不会做</span><br><span class="line">当浏览器的URL改变时，不会重新加载整个页面。</span><br><span class="line">如果想要重新加载整个页面，需要使用$window.location.href。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.cnblogs.com/sitemanager/p/3513619.html" target="_blank" rel="noopener">$location 服务</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法一：location-href&quot;&gt;&lt;a href=&quot;#方法一：location-href&quot; class=&quot;headerlink&quot; title=&quot;方法一：location.href&quot;&gt;&lt;/a&gt;&lt;strong&gt;方法一：location.href&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LinkedList原理总结</title>
    <link href="http://yoursite.com/2018/06/04/LinkedList%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/04/LinkedList原理总结/</id>
    <published>2018-06-04T08:26:13.215Z</published>
    <updated>2018-06-05T03:48:24.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、LinkedList实现原理概述"><a href="#一、LinkedList实现原理概述" class="headerlink" title="一、LinkedList实现原理概述"></a>一、LinkedList实现原理概述</h2><p>LinkedList 和 ArrayList 一样，都实现了 List 接口，但其内部的数据结构有本质的不同。LinkedList 是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比 ArrayList 差。</p><h2 id="二、LinkedList类定义"><a href="#二、LinkedList类定义" class="headerlink" title="二、LinkedList类定义"></a>二、LinkedList类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">     extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">     implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable123</span><br></pre></td></tr></table></figure><ol><li>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行队列操作。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</li><li>LinkedList 是非同步的。</li></ol><p>为什么要继承自AbstractSequentialList ?<br>AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些骨干性函数。降低了List接口的复杂度。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。<br>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p><p>LinkedList的类图关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-1f1f512b93b66733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="三、LinkedList数据结构原理"><a href="#三、LinkedList数据结构原理" class="headerlink" title="三、LinkedList数据结构原理"></a>三、LinkedList数据结构原理</h2><p>LinkedList底层的数据结构是基于双向循环链表的，且头结点中不存放数据,如下：<br><img src="https://upload-images.jianshu.io/upload_images/12434140-94eb491c19114c90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12434140-6504efac8e4613f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="四、私有属性"><a href="#四、私有属性" class="headerlink" title="四、私有属性"></a>四、私有属性</h2><p>LinkedList中之定义了两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);2 private transient int size = 0;1</span><br></pre></td></tr></table></figure><p>header是双向链表的头节点，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。<br>　　size是双向链表中节点实例的个数。<br>首先来了解节点类Entry类的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Entry&lt;E&gt; &#123;</span><br><span class="line">    E element;</span><br><span class="line">     Entry&lt;E&gt; next;</span><br><span class="line">     Entry&lt;E&gt; previous;</span><br><span class="line"></span><br><span class="line">     Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">         this.element = element;</span><br><span class="line">         this.next = next;</span><br><span class="line">        this.previous = previous;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;1234567891011</span><br></pre></td></tr></table></figure><p>节点类很简单，element存放业务数据，previous与next分别存放前后节点的信息（在数据结构中我们通常称之为前后节点的指针）。</p><p>}</p><h2 id="五、构造方法"><a href="#五、构造方法" class="headerlink" title="五、构造方法"></a>五、构造方法</h2><p>LinkedList提供了两个构造方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;    </span><br><span class="line"> header.next = header.previous = header;</span><br><span class="line"> &#125;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     this();</span><br><span class="line">   addAll(c);123456</span><br></pre></td></tr></table></figure><p>第一个构造方法不接受参数，将header实例的previous和next全部指向header实例（注意，这个是一个双向循环链表，如果不是循环链表，空链表的情况应该是header节点的前一节点和后一节点均为null），这样整个链表其实就只有header一个节点，用于表示一个空的链表。<br>执行完构造函数后，header实例自身形成一个闭环，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/12434140-ab19724dde45d023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二个构造方法接收一个Collection参数c，调用第一个构造方法构造一个空的链表，之后通过addAll将c中的元素全部添加到链表中。</p><h2 id="六、元素添加"><a href="#六、元素添加" class="headerlink" title="六、元素添加"></a>六、元素添加</h2><p>下面说明双向链表添加元素add()的原理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> // 将元素(E)添加到LinkedList中</span><br><span class="line">     public boolean add(E e) &#123;</span><br><span class="line">         // 将节点(节点数据是e)添加到表头(header)之前。</span><br><span class="line">         // 即，将节点添加到双向链表的末端。         addBefore(e, header);</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public void add(int index, E element) &#123;</span><br><span class="line">         addBefore(element, (index==size ? header : entry(index)));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123;</span><br><span class="line">         Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">         newEntry.previous.next = newEntry;</span><br><span class="line">         newEntry.next.previous = newEntry;</span><br><span class="line">         size++;</span><br><span class="line">         modCount++;</span><br><span class="line">         return newEntry;</span><br><span class="line">&#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure><p>addBefore(E e,Entry entry)方法是个私有方法，所以无法在外部程序中调用（当然，这是一般情况，你可以通过反射上面的还是能调用到的）。<br>addBefore(E e,Entry entry)先通过Entry的构造方法创建e的节点newEntry（包含了将其下一个节点设置为entry，上一个节点设置为entry.previous的操作，相当于修改newEntry的“指针”），之后修改插入位置后newEntry的前一节点的next引用和后一节点的previous引用，使链表节点间的引用关系保持正确。之后修改和size大小和记录modCount，然后返回新插入的节点。<br>下面分解“添加第一个数据”的步骤：<br>第一步：初始化后LinkedList实例的情况：<br><img src="https://upload-images.jianshu.io/upload_images/12434140-09e617b557475eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二步：初始化一个预添加的Entry实例（newEntry）。<br>Entry newEntry = newEntry(e, entry, entry.previous);<br><img src="https://upload-images.jianshu.io/upload_images/12434140-f728853fbad4548c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>第三步：调整新加入节点和头结点（header）的前后指针。<br>newEntry.previous.next = newEntry;<br>newEntry.previous即header，newEntry.previous.next即header的next指向newEntry实例。在上图中应该是“4号线”指向newEntry。<br>newEntry.next.previous = newEntry;<br>newEntry.next即header，newEntry.next.previous即header的previous指向newEntry实例。在上图中应该是“3号线”指向newEntry。<br>调整后如下图所示：<br>图——加入第一个节点后LinkedList示意图<br><img src="https://upload-images.jianshu.io/upload_images/12434140-9fa43ef1334b5238.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>下面分解“添加第二个数据”的步骤：<br>第一步：新建节点。<br>图——添加第二个节点<br> <img src="https://upload-images.jianshu.io/upload_images/12434140-8ed465a32e3a4b22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>第二步：调整新节点和头结点的前后指针信息。<br>图——调整前后指针信息<br><img src="https://upload-images.jianshu.io/upload_images/12434140-bffac2e652fefd0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>添加后续数据情况和上述一致，LinkedList实例是没有容量限制的。</p><p>总结，addBefore(E e,Entry entry)实现在entry之前插入由e构造的新节点。而add(E e)实现在header节点之前插入由e构造的新节点。为了便于理解，下面给出插入节点的示意图。 <img src="https://upload-images.jianshu.io/upload_images/12434140-14c14a9434edce14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">     addBefore(e, header.next);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">     addBefore(e, header);</span><br><span class="line"> &#125;1234567</span><br></pre></td></tr></table></figure><p>看上面的示意图，结合addBefore(E e,Entry entry)方法，很容易理解addFrist(E e)只需实现在header元素的下一个元素之前插入，即示意图中的一号之前。addLast(E e)只需在实现在header节点前（因为是循环链表，所以header的前一个节点就是链表的最后一个节点）插入节点（插入后在2号节点之后）。</p><h2 id="七、删除数据remove"><a href="#七、删除数据remove" class="headerlink" title="七、删除数据remove()"></a>七、删除数据remove()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        Entry e = get(index);</span><br><span class="line">        remove(e);</span><br><span class="line">        return e.element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void remove(E e) &#123;</span><br><span class="line">        if (e == header)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        // 将前一节点的next引用赋值为e的下一节点</span><br><span class="line">        e.previous.next = e.next;</span><br><span class="line">        // 将e的下一节点的previous赋值为e的上一节点</span><br><span class="line">        e.next.previous = e.previous;</span><br><span class="line">        // 上面两条语句的执行已经导致了无法在链表中访问到e节点，而下面解除了e节点对前后节点的引用</span><br><span class="line">        e.next = e.previous = null;</span><br><span class="line">        // 将被移除的节点的内容设为null</span><br><span class="line">        e.element = null;</span><br><span class="line">        // 修改size大小</span><br><span class="line">        size--;</span><br><span class="line">    &#125;1234567891011121314151617181920</span><br></pre></td></tr></table></figure><p>由于删除了某一节点因此调整相应节点的前后指针信息，如下：<br>e.previous.next = e.next;//预删除节点的前一节点的后指针指向预删除节点的后一个节点。<br>e.next.previous = e.previous;//预删除节点的后一节点的前指针指向预删除节点的前一个节点。<br>清空预删除节点：<br>e.next = e.previous = null;<br>e.element = null;<br>交给gc完成资源回收，删除操作结束。<br>与ArrayList比较而言，LinkedList的删除动作不需要“移动”很多数据，从而效率更高。</p><h2 id="八、数据获取get"><a href="#八、数据获取get" class="headerlink" title="八、数据获取get()"></a>八、数据获取get()</h2><p>Get(int)方法的实现在remove(int)中已经涉及过了。首先判断位置信息是否合法（大于等于0，小于当前LinkedList实例的Size），然后遍历到具体位置，获得节点的业务数据（element）并返回。<br>注意：为了提高效率，需要根据获取的位置判断是从头还是从尾开始遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 获取双向链表中指定位置的节点    </span><br><span class="line">    private Entry&lt;E&gt; entry(int index) &#123;    </span><br><span class="line">        if (index &lt; 0 || index &gt;= size)    </span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+    </span><br><span class="line">                                                &quot;, Size: &quot;+size);    </span><br><span class="line">        Entry&lt;E&gt; e = header;    </span><br><span class="line">        // 获取index处的节点。    </span><br><span class="line">        // 若index &lt; 双向链表长度的1/2,则从前先后查找;    </span><br><span class="line">        // 否则，从后向前查找。    </span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;    </span><br><span class="line">            for (int i = 0; i &lt;= index; i++)    </span><br><span class="line">                e = e.next;    </span><br><span class="line">        &#125; else &#123;    </span><br><span class="line">            for (int i = size; i &gt; index; i--)    </span><br><span class="line">                e = e.previous;    </span><br><span class="line">        &#125;    </span><br><span class="line">        return e;    </span><br><span class="line">    &#125;123456789101112131415161718</span><br></pre></td></tr></table></figure><p>注意细节：位运算与直接做除法的区别。先将index与长度size的一半比较，如果index</p><h2 id="九、-清除数据clear"><a href="#九、-清除数据clear" class="headerlink" title="九、 清除数据clear()"></a>九、 清除数据clear()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">      Entry&lt;E&gt; e = header.next;</span><br><span class="line">      // e可以理解为一个移动的“指针”，因为是循环链表，所以回到header的时候说明已经没有节点了</span><br><span class="line">      while (e != header) &#123;</span><br><span class="line">         // 保留e的下一个节点的引用</span><br><span class="line">          Entry&lt;E&gt; next = e.next;</span><br><span class="line">          // 解除节点e对前后节点的引用</span><br><span class="line">         e.next = e.previous = null;</span><br><span class="line">          // 将节点e的内容置空</span><br><span class="line">         e.element = null;</span><br><span class="line">         // 将e移动到下一个节点</span><br><span class="line">         e = next;</span><br><span class="line">  &#125;</span><br><span class="line">     // 将header构造成一个循环链表，同构造方法构造一个空的LinkedList</span><br><span class="line">     header.next = header.previous = header;</span><br><span class="line">     // 修改size</span><br><span class="line">     size = 0;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;12345678910111213141516171819</span><br></pre></td></tr></table></figure><h2 id="十、数据包含-contains-Object-o"><a href="#十、数据包含-contains-Object-o" class="headerlink" title="十、数据包含 contains(Object o)"></a>十、数据包含 contains(Object o)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">     return indexOf(o) != -1;</span><br><span class="line"> &#125;</span><br><span class="line"> // 从前向后查找，返回“值为对象(o)的节点对应的索引”  不存在就返回-1 </span><br><span class="line"> public int indexOf(Object o) &#123;</span><br><span class="line">      int index = 0;</span><br><span class="line">      if (o==null) &#123;</span><br><span class="line">          for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">              if (e.element==null)</span><br><span class="line">                  return index;</span><br><span class="line">              index++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         for (Entry e = header.next; e != header; e = e.next) &#123;</span><br><span class="line">             if (o.equals(e.element))</span><br><span class="line">                 return index;</span><br><span class="line">             index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     return -1;</span><br><span class="line"> &#125;123456789101112131415161718192021</span><br></pre></td></tr></table></figure><p>indexOf(Object o)判断o链表中是否存在节点的element和o相等，若相等则返回该节点在链表中的索引位置，若不存在则放回-1。<br>contains(Object o)方法通过判断indexOf(Object o)方法返回的值是否是-1来判断链表中是否包含对象o。</p><h2 id="十一、数据复制clone-与toArray"><a href="#十一、数据复制clone-与toArray" class="headerlink" title="十一、数据复制clone()与toArray()"></a>十一、数据复制clone()与toArray()</h2><p>clone()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">      LinkedList&lt;E&gt; clone = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          clone = (LinkedList&lt;E&gt;) super.clone();</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          throw new InternalError();</span><br><span class="line">    &#125;</span><br><span class="line">      clone.header = new Entry&lt;E&gt;(null, null, null);</span><br><span class="line">      clone.header.next = clone.header.previous = clone.header;</span><br><span class="line">     clone.size = 0;</span><br><span class="line">     clone.modCount = 0;</span><br><span class="line">     for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">        clone.add(e.element);</span><br><span class="line">     return clone;</span><br><span class="line"> &#125;123456789101112131415</span><br></pre></td></tr></table></figure><p>调用父类的clone()方法初始化对象链表clone，将clone构造成一个空的双向循环链表，之后将header的下一个节点开始将逐个节点添加到clone中。最后返回克隆的clone对象。<br>toArray()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">     Object[] result = new Object[size];</span><br><span class="line">     int i = 0;</span><br><span class="line">     for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">         result[i++] = e.element;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;1234567</span><br></pre></td></tr></table></figure><p>创建大小和LinkedList相等的数组result，遍历链表，将每个节点的元素element复制到数组中，返回数组。<br>toArray(T[] a)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">      if (a.length &lt; size)</span><br><span class="line">          a = (T[])java.lang.reflect.Array.newInstance(</span><br><span class="line">                                 a.getClass().getComponentType(), size);</span><br><span class="line">      int i = 0;</span><br><span class="line">      Object[] result = a;</span><br><span class="line">      for (Entry&lt;E&gt; e = header.next; e != header; e = e.next)</span><br><span class="line">          result[i++] = e.element;</span><br><span class="line">      if (a.length &gt; size)</span><br><span class="line">         a[size] = null;</span><br><span class="line">     return a;</span><br><span class="line"> &#125;123456789101112</span><br></pre></td></tr></table></figure><p>先判断出入的数组a的大小是否足够，若大小不够则拓展。这里用到了发射的方法，重新实例化了一个大小为size的数组。之后将数组a赋值给数组result，遍历链表向result中添加的元素。最后判断数组a的长度是否大于size，若大于则将size位置的内容设置为null。返回a。<br>从代码中可以看出，数组a的length小于等于size时，a中所有元素被覆盖，被拓展来的空间存储的内容都是null；若数组a的length的length大于size，则0至size-1位置的内容被覆盖，size位置的元素被设置为null，size之后的元素不变。<br>为什么不直接对数组a进行操作，要将a赋值给result数组之后对result数组进行操作？</p><h2 id="十二、遍历数据：Iterator"><a href="#十二、遍历数据：Iterator" class="headerlink" title="十二、遍历数据：Iterator()"></a>十二、遍历数据：Iterator()</h2><p>LinkedList的Iterator<br>除了Entry，LinkedList还有一个内部类：ListItr。<br>ListItr实现了ListIterator接口，可知它是一个迭代器，通过它可以遍历修改LinkedList。<br>在LinkedList中提供了获取ListItr对象的方法：listIterator(int index)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;123</span><br></pre></td></tr></table></figure><p>该方法只是简单的返回了一个ListItr对象。<br>LinkedList中还有通过集成获得的listIterator()方法，该方法只是调用了listIterator(int index)并且传入0。</p><p>十三、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、LinkedList实现原理概述&quot;&gt;&lt;a href=&quot;#一、LinkedList实现原理概述&quot; class=&quot;headerlink&quot; title=&quot;一、LinkedList实现原理概述&quot;&gt;&lt;/a&gt;一、LinkedList实现原理概述&lt;/h2&gt;&lt;p&gt;Linked
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>链表的原理总结</title>
    <link href="http://yoursite.com/2018/06/04/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/04/链表的原理总结/</id>
    <published>2018-06-04T08:20:12.425Z</published>
    <updated>2018-06-04T08:19:49.488Z</updated>
    
    <content type="html"><![CDATA[<h4 id="单向链表基本介绍"><a href="#单向链表基本介绍" class="headerlink" title="单向链表基本介绍"></a>单向链表基本介绍</h4><p>链表是一种数据结构，和数组同级。比如，Java中我们使用的ArrayList，其实现原理是数组。而LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p><p>单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-14ccf68f9dde4375.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以头节点就可以操作所有节点了。  下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-30d81ef577dbca98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明： </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-5a1a91e332d560a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="单项链表的实现"><a href="#单项链表的实现" class="headerlink" title="单项链表的实现"></a>单项链表的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package com.zjn.LinkAndQueue;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义链表设计</span><br><span class="line"> * </span><br><span class="line"> * @author zjn</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyLink &#123;</span><br><span class="line">    Node head = null; // 头节点</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表中的节点，data代表节点的值，next是指向下一个节点的引用</span><br><span class="line">     * </span><br><span class="line">     * @author zjn</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    class Node &#123;</span><br><span class="line">        Node next = null;// 节点的引用，指向下一个节点</span><br><span class="line">        int data;// 节点的对象，即内容</span><br><span class="line"></span><br><span class="line">        public Node(int data) &#123;</span><br><span class="line">            this.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向链表中插入数据</span><br><span class="line">     * </span><br><span class="line">     * @param d</span><br><span class="line">     */</span><br><span class="line">    public void addNode(int d) &#123;</span><br><span class="line">        Node newNode = new Node(d);// 实例化一个节点</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            head = newNode;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        while (tmp.next != null) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param index:删除第index个节点</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean deleteNode(int index) &#123;</span><br><span class="line">        if (index &lt; 1 || index &gt; length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (index == 1) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 1;</span><br><span class="line">        Node preNode = head;</span><br><span class="line">        Node curNode = preNode.next;</span><br><span class="line">        while (curNode != null) &#123;</span><br><span class="line">            if (i == index) &#123;</span><br><span class="line">                preNode.next = curNode.next;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            preNode = curNode;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @return 返回节点长度</span><br><span class="line">     */</span><br><span class="line">    public int length() &#123;</span><br><span class="line">        int length = 0;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        while (tmp != null) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在不知道头指针的情况下删除指定节点</span><br><span class="line">     * </span><br><span class="line">     * @param n</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean deleteNode11(Node n) &#123;</span><br><span class="line">        if (n == null || n.next == null)</span><br><span class="line">            return false;</span><br><span class="line">        int tmp = n.data;</span><br><span class="line">        n.data = n.next.data;</span><br><span class="line">        n.next.data = tmp;</span><br><span class="line">        n.next = n.next.next;</span><br><span class="line">        System.out.println(&quot;删除成功！&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printList() &#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        while (tmp != null) &#123;</span><br><span class="line">            System.out.println(tmp.data);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyLink list = new MyLink();</span><br><span class="line">        list.addNode(5);</span><br><span class="line">        list.addNode(3);</span><br><span class="line">        list.addNode(1);</span><br><span class="line">        list.addNode(2);</span><br><span class="line">        list.addNode(55);</span><br><span class="line">        list.addNode(36);</span><br><span class="line">        System.out.println(&quot;linkLength:&quot; + list.length());</span><br><span class="line">        System.out.println(&quot;head.data:&quot; + list.head.data);</span><br><span class="line">        list.printList();</span><br><span class="line">        list.deleteNode(4);</span><br><span class="line">        System.out.println(&quot;After deleteNode(4):&quot;);</span><br><span class="line">        list.printList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="链表相关的常用操作实现方法"><a href="#链表相关的常用操作实现方法" class="headerlink" title="链表相关的常用操作实现方法"></a>链表相关的常用操作实现方法</h4><h5 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a><strong>链表反转</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 链表反转</span><br><span class="line">     * </span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Node ReverseIteratively(Node head) &#123;</span><br><span class="line">        Node pReversedHead = head;</span><br><span class="line">        Node pNode = head;</span><br><span class="line">        Node pPrev = null;</span><br><span class="line">        while (pNode != null) &#123;</span><br><span class="line">            Node pNext = pNode.next;</span><br><span class="line">            if (pNext == null) &#123;</span><br><span class="line">                pReversedHead = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode.next = pPrev;</span><br><span class="line">            pPrev = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        this.head = pReversedHead;</span><br><span class="line">        return this.head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="查找单链表的中间节点"><a href="#查找单链表的中间节点" class="headerlink" title="查找单链表的中间节点"></a><strong>查找单链表的中间节点</strong></h5><p>采用快慢指针的方式查找单链表的中间节点，快指针一次走两步，慢指针一次走一步，当快指针走完时，慢指针刚好到达中间节点。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查找单链表的中间节点</span><br><span class="line">     * </span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Node SearchMid(Node head) &#123;</span><br><span class="line">        Node p = this.head, q = this.head;</span><br><span class="line">        while (p != null &amp;&amp; p.next != null &amp;&amp; p.next.next != null) &#123;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Mid:&quot; + q.data);</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="查找倒数第k个元素"><a href="#查找倒数第k个元素" class="headerlink" title="查找倒数第k个元素"></a><strong>查找倒数第k个元素</strong></h5><p>采用两个指针P1,P2，P1先前移K步，然后P1、P2同时移动，当p1移动到尾部时，P2所指位置的元素即倒数第k个元素 。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 查找倒数 第k个元素</span><br><span class="line">     * </span><br><span class="line">     * @param head</span><br><span class="line">     * @param k</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Node findElem(Node head, int k) &#123;</span><br><span class="line">        if (k &lt; 1 || k &gt; this.length()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node p1 = head;</span><br><span class="line">        Node p2 = head;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)// 前移k步</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        while (p1 != null) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="对链表进行排序"><a href="#对链表进行排序" class="headerlink" title="对链表进行排序"></a><strong>对链表进行排序</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 排序</span><br><span class="line">     * </span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Node orderList() &#123;</span><br><span class="line">        Node nextNode = null;</span><br><span class="line">        int tmp = 0;</span><br><span class="line">        Node curNode = head;</span><br><span class="line">        while (curNode.next != null) &#123;</span><br><span class="line">            nextNode = curNode.next;</span><br><span class="line">            while (nextNode != null) &#123;</span><br><span class="line">                if (curNode.data &gt; nextNode.data) &#123;</span><br><span class="line">                    tmp = curNode.data;</span><br><span class="line">                    curNode.data = nextNode.data;</span><br><span class="line">                    nextNode.data = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                nextNode = nextNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="删除链表中的重复节点"><a href="#删除链表中的重复节点" class="headerlink" title="删除链表中的重复节点"></a><strong>删除链表中的重复节点</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 删除重复节点</span><br><span class="line">     */</span><br><span class="line">    public void deleteDuplecate(Node head) &#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            Node q = p;</span><br><span class="line">            while (q.next != null) &#123;</span><br><span class="line">                if (p.data == q.next.data) &#123;</span><br><span class="line">                    q.next = q.next.next;</span><br><span class="line">                &#125; else</span><br><span class="line">                    q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="从尾到头输出单链表，采用递归方式实现"><a href="#从尾到头输出单链表，采用递归方式实现" class="headerlink" title="从尾到头输出单链表，采用递归方式实现"></a><strong>从尾到头输出单链表，采用递归方式实现</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 从尾到头输出单链表，采用递归方式实现</span><br><span class="line">     * </span><br><span class="line">     * @param pListHead</span><br><span class="line">     */</span><br><span class="line">    public void printListReversely(Node pListHead) &#123;</span><br><span class="line">        if (pListHead != null) &#123;</span><br><span class="line">            printListReversely(pListHead.next);</span><br><span class="line">            System.out.println(&quot;printListReversely:&quot; + pListHead.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="判断链表是否有环，有环情况下找出环的入口节点"><a href="#判断链表是否有环，有环情况下找出环的入口节点" class="headerlink" title="判断链表是否有环，有环情况下找出环的入口节点"></a><strong>判断链表是否有环，有环情况下找出环的入口节点</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 判断链表是否有环，单向链表有环时，尾节点相同</span><br><span class="line">     * </span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean IsLoop(Node head) &#123;</span><br><span class="line">        Node fast = head, slow = head;</span><br><span class="line">        if (fast == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                System.out.println(&quot;该链表有环&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return !(fast == null || fast.next == null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 找出链表环的入口</span><br><span class="line">     * </span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Node FindLoopPort(Node head) &#123;</span><br><span class="line">        Node fast = head, slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            if (slow == fast)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fast == null || fast.next == null)</span><br><span class="line">            return null;</span><br><span class="line">        slow = head;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;单向链表基本介绍&quot;&gt;&lt;a href=&quot;#单向链表基本介绍&quot; class=&quot;headerlink&quot; title=&quot;单向链表基本介绍&quot;&gt;&lt;/a&gt;单向链表基本介绍&lt;/h4&gt;&lt;p&gt;链表是一种数据结构，和数组同级。比如，Java中我们使用的ArrayList，其实现原理是数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ArrayList原理总结</title>
    <link href="http://yoursite.com/2018/06/04/ArrayList%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/04/ArrayList原理总结/</id>
    <published>2018-06-04T08:02:08.536Z</published>
    <updated>2018-06-04T08:01:55.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ArrayList介绍"><a href="#ArrayList介绍" class="headerlink" title="ArrayList介绍"></a>ArrayList介绍</h3><p>ArrayList是一种线性数据结构，它的底层是用数组实现的，相当于动态数组。与Java中的数组相比，它的容量能动态增长。类似于C语言中的动态申请内存，动态增长内存。<br>当创建一个数组的时候，就必须确定它的大小，系统会在内存中开辟一块连续的空间，用来保存数组，因此数组容量固定且无法动态改变。ArrayList在保留数组可以快速查找的优势的基础上，弥补了数组在创建后，要往数组添加元素的弊端。实现的基本方法如下：<br>\1. 快速查找：在物理内存上采用顺序存储结构，因此可根据索引快速的查找元素。<br>\2. 容量动态增长： 当数组容量不够用时（表1），创建一个比原数组容量大的新数组（表2），将数组中的元素“搬”到新数组（表3），再将新的元素也放入新数组（表4），最后将新数组赋给原数组即可。（从左到右依次为表1，表2、表3、表4） </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-7bc58e90b0edf4aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a>ArrayList继承关系</h3><p>ArrayList继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。  实现了所有List接口的操作，并ArrayList允许存储null值。除了没有进行同步，ArrayList基本等同于Vector。在Vector中几乎对所有的方法都进行了同步，但ArrayList仅对writeObject和readObject进行了同步，其它比如add(Object)、remove(int)等都没有同步。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">     xxxxx</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ArrayList与Collection关系如下图，实线代表继承，虚线代表实现接口： </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-86e9e6a9f3489616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li><p>AbstractList提供了List接口的默认实现（个别方法为抽象方法）。</p></li><li><p>List接口定义了列表必须实现的方法。</p></li><li><p>实现了RandomAccess接口：提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</p></li><li><p>实现了Cloneable接口：可以调用Object.clone方法返回该对象的浅拷贝。</p></li><li><p>实现了 java.io.Serializable 接口：可以启用其序列化功能，能通过序列化去传输。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p><h3 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h3><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面进行具体的介绍 :</p><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 保存ArrayList中数据的数组</span><br><span class="line">private transient Object[] elementData;</span><br><span class="line">// ArrayList中实际数据的数量</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><p>很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。  有个关键字需要解释：transient。  Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 </p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>ArrayList提供了三种方式的构造器，可以构造一个指定初始容量的空列表、构造一个默认初始容量为10的空列表以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// ArrayList带容量大小的构造函数。</span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        super();</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; + initialCapacity);</span><br><span class="line">        // 新建一个数组</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ArrayList构造函数。默认容量是10。</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个包含collection的ArrayList</span><br><span class="line">    public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        size = elementData.length;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="元素存储"><a href="#元素存储" class="headerlink" title="元素存储"></a>元素存储</h4><p>ArrayList是基于数组实现的，当添加元素的时候，如果数组大，则在将某个位置的值设置为指定元素即可，如果数组容量不够了，以add（E e）为例，可以看到add(E e)中先调用了ensureCapacity(size+1)方法，之后将元素的索引赋给elementData[size]，而后size自增。例如初次添加时，size为0，add将elementData[0]赋值为e，然后size设置为1（类似执行以下两条语句elementData[0]=e;size=1）。将元素的索引赋给elementData[size]不是会出现数组越界的情况吗？这里关键就在ensureCapacity(size+1)中了。  具体实现如下：  </p><p><strong>(1)</strong> 当调用下面这两个方法向数组中添加元素时，默认是添加到数组中最后一个元素的后面。内存结构变化如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-dfc4b47a943ee46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 添加元素e</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        // 确定ArrayList的容量大小</span><br><span class="line">        ensureCapacity(size + 1); // Increments modCount!!</span><br><span class="line">        // 添加e到ArrayList中</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">// 将集合c追加到ArrayList中</span><br><span class="line">    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacity(size + numNew); // Increments modCount</span><br><span class="line">        System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        return numNew != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>（2）</strong>当调用下面这两个方法向数组中添加元素或集合时，会先查找索引位置，然后将元素添加到索引处，最后把添加前索引后面的元素追加到新元素的后面。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-51d75aa7eaf7701b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 将e添加到ArrayList的指定位置</span><br><span class="line">    public void add(int index, E element) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);</span><br><span class="line">        ensureCapacity(size + 1); // Increments modCount!!</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1, size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从index位置开始，将集合c添加到ArrayList</span><br><span class="line">    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        if (index &gt; size || index &lt; 0)</span><br><span class="line">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        ensureCapacity(size + numNew); // Increments modCount</span><br><span class="line">        int numMoved = size - index;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">        System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>（3）</strong>调用该方法会将index位置的元素用新元素替代  </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-eb2524d458837ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设置index位置的值为element</span><br><span class="line">    public E set(int index, E element) &#123;</span><br><span class="line">        RangeCheck(index);</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="元素读取"><a href="#元素读取" class="headerlink" title="元素读取"></a>元素读取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 返回此列表中指定位置上的元素。</span><br><span class="line">    public E get(int index) &#123;</span><br><span class="line">        RangeCheck(index);</span><br><span class="line">        return (E) elementData[index];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。如下：  romove(int index)，首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。  </p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-8be4b0ecd79f603d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 删除ArrayList指定位置的元素</span><br><span class="line">    public E remove(int index) &#123;</span><br><span class="line">        RangeCheck(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = (E) elementData[index];</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index + 1, elementData, index, numMoved);</span><br><span class="line">        elementData[--size] = null; // Let gc do its work</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="调整数组容量ensureCapacity"><a href="#调整数组容量ensureCapacity" class="headerlink" title="调整数组容量ensureCapacity"></a>调整数组容量ensureCapacity</h4><p><strong>（1）</strong>从上面介绍的向ArrayList中存储元素的代码中，我们看到，每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 确定ArrarList的容量。</span><br><span class="line">    // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”</span><br><span class="line">    public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">        // 将“修改统计数”+1</span><br><span class="line">        modCount++;</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”</span><br><span class="line">        if (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">            Object oldData[] = elementData;</span><br><span class="line">            int newCapacity = (oldCapacity * 3) / 2 + 1;</span><br><span class="line">            if (newCapacity &lt; minCapacity)</span><br><span class="line">                newCapacity = minCapacity;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。  </p><p><strong>(2)</strong> ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 将当前容量值设为 =实际元素个数</span><br><span class="line">    public void trimToSize() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        if (size &lt; oldCapacity) &#123;</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间 </p><h4 id="转为静态数组toArray的两种方法"><a href="#转为静态数组toArray的两种方法" class="headerlink" title="转为静态数组toArray的两种方法"></a>转为静态数组toArray的两种方法</h4><p><strong>（1）</strong>调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回ArrayList的Object数组</span><br><span class="line">    public Object[] toArray() &#123;</span><br><span class="line">        return Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>（2）</strong>如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型</span><br><span class="line">    public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        // 若数组a的大小 &lt; ArrayList的元素个数；</span><br><span class="line">        // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中</span><br><span class="line">        if (a.length &lt; size)</span><br><span class="line">            return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        // 若数组a的大小 &gt;= ArrayList的元素个数；</span><br><span class="line">        // 则将ArrayList的全部元素都拷贝到数组a中。</span><br><span class="line">        System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">        if (a.length &gt; size)</span><br><span class="line">            a[size] = null;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="实现了Cloneable接口，进行数据浅拷贝"><a href="#实现了Cloneable接口，进行数据浅拷贝" class="headerlink" title="实现了Cloneable接口，进行数据浅拷贝"></a>实现了Cloneable接口，进行数据浅拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 克隆函数</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();</span><br><span class="line">            // 将当前ArrayList的全部元素拷贝到v中</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = 0;</span><br><span class="line">            return v;</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="实现Serializable-接口，启用其序列化功能"><a href="#实现Serializable-接口，启用其序列化功能" class="headerlink" title="实现Serializable 接口，启用其序列化功能"></a>实现Serializable 接口，启用其序列化功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// java.io.Serializable的写入函数</span><br><span class="line">    // 将ArrayList的“容量，所有的元素值”都写入到输出流中</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123;</span><br><span class="line">        // Write out element count, and any hidden stuff</span><br><span class="line">        int expectedModCount = modCount;</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        // 写入“数组的容量”</span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">        // 写入“数组的每一个元素”</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // java.io.Serializable的读取函数：根据写入方式读出</span><br><span class="line">    // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in size, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        // 从输入流中读取ArrayList的“容量”</span><br><span class="line">        int arrayLength = s.readInt();</span><br><span class="line">        Object[] a = elementData = new Object[arrayLength];</span><br><span class="line">        // 从输入流中将“所有的元素值”读出</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ArrayList介绍&quot;&gt;&lt;a href=&quot;#ArrayList介绍&quot; class=&quot;headerlink&quot; title=&quot;ArrayList介绍&quot;&gt;&lt;/a&gt;ArrayList介绍&lt;/h3&gt;&lt;p&gt;ArrayList是一种线性数据结构，它的底层是用数组实现的，相当于
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java内存管理与多线程</title>
    <link href="http://yoursite.com/2018/06/04/Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/04/Java内存管理与多线程/</id>
    <published>2018-06-04T06:55:32.136Z</published>
    <updated>2018-06-04T06:55:15.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线程？什么是进程？同一进程下的线程共享"><a href="#什么是线程？什么是进程？同一进程下的线程共享" class="headerlink" title="什么是线程？什么是进程？同一进程下的线程共享"></a>什么是线程？什么是进程？同一进程下的线程共享</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程:"></a>线程:</h4><p>程序在执行过程中，能够执行程序代码的一个执行单元，一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。在Java语言中有4种状态：运行、就绪、挂起、结束。</p><h4 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h4><p>指一段正在执行的程序。线程有时也被称为轻量级进程，它是程序执行的最小单元，一个进程可以拥有多个线程，各个线程之间共享程序的内存空间及一些进程级的资源，但是各个线程拥有自己的栈空间。</p><h4 id="进程的作用和定义："><a href="#进程的作用和定义：" class="headerlink" title="进程的作用和定义："></a>进程的作用和定义：</h4><p>进程是为了提高CPU的执行效率，减少因为程序等待带来的CPU空转以及其他计算机软硬件资源的浪费而提出来的。进程是为了完成用户任务所需要的程序的一次执行过程和为其分配资源的一个基本单位，是一个具有独立功能的程序段对某个数据集的一次执行活动。</p><h4 id="线程和进程的区别："><a href="#线程和进程的区别：" class="headerlink" title="线程和进程的区别："></a>线程和进程的区别：</h4><p>A. 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>B. 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>C. 调度和切换：线程上下文切换比进程上下文切换要快得多。<br>D. 在多线程OS中，进程不是一个可执行的实体。<br>E. 线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。</p><h4 id="线程与进程资源分配："><a href="#线程与进程资源分配：" class="headerlink" title="线程与进程资源分配："></a>线程与进程资源分配：</h4><p>线程共享的内容包括： 进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和、进程用户ID、进程组ID。<br>线程独有的内容包括： 线程ID 、寄存器组的值 、线程的堆栈 、错误返回码 、线程的信号屏蔽码 。</p><h3 id="Java的内存机制"><a href="#Java的内存机制" class="headerlink" title="Java的内存机制"></a>Java的内存机制</h3><p>Java 把内存划分成两种：一种是栈内存，另一种是堆内存。 </p><h4 id="堆和栈相同点："><a href="#堆和栈相同点：" class="headerlink" title="堆和栈相同点："></a>堆和栈相同点：</h4><p>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 </p><h4 id="堆和栈区别："><a href="#堆和栈区别：" class="headerlink" title="堆和栈区别："></a>堆和栈区别：</h4><p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。</p><p>堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的 首地址，栈中的这个变量就成了数组或对象的引用变量，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或者对象，引用变量就相当于是为数组或者对象 起的一个名称。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。</p><h3 id="java中变量在内存中的分配"><a href="#java中变量在内存中的分配" class="headerlink" title="java中变量在内存中的分配"></a>java中变量在内存中的分配</h3><p><strong>（1）类变量（static修饰的变量）</strong>：在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期–一直持续到整个”系统”关闭</p><p><strong>（2）实例变量：</strong>当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</p><p><strong>（3）局部变量：</strong>局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</p><h3 id="JVM内存分配"><a href="#JVM内存分配" class="headerlink" title="JVM内存分配"></a>JVM内存分配</h3><p>JVM 将内存区域划分为： Method Are（Non-Heap）（方法区）,Heap（堆）,Program Counter Register（程序计数器）,VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack（本地方法栈）。<br><strong>方法区和堆是线程共享的，虚拟机栈，程序计数器和本地方法栈是非线程共享的。</strong><br>一般性的 Java 程序的工作过程：一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。那么程序开始运行后，都是如何涉及到各内存区域的呢？<br>概括地说来，JVM初始运行的时候都会分配好方法区和堆，而JVM每遇到一个线程，就为其分配一个程序计数器,虚拟机栈和本地方法栈，当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。</p><h3 id="Java实现多线程，创建并启动线程的过程"><a href="#Java实现多线程，创建并启动线程的过程" class="headerlink" title="Java实现多线程，创建并启动线程的过程"></a>Java实现多线程，创建并启动线程的过程</h3><h4 id="（1）定义线程："><a href="#（1）定义线程：" class="headerlink" title="（1）定义线程："></a>（1）定义线程：</h4><p>1）扩展java.lang.Thread类。 2）实现java.lang.Runnable接口。</p><h4 id="（2）实例化线程："><a href="#（2）实例化线程：" class="headerlink" title="（2）实例化线程："></a>（2）实例化线程：</h4><p>1）如果是扩展java.lang.Thread类的线程，则直接new即可。<br>2）如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target) </span><br><span class="line">Thread(Runnable target, String name) </span><br><span class="line">Thread(ThreadGroup group, Runnable target) </span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name) </span><br><span class="line">Thread(ThreadGroup group, Runnable target, String name, long stackSize)</span><br></pre></td></tr></table></figure><h4 id="（3）启动线程："><a href="#（3）启动线程：" class="headerlink" title="（3）启动线程："></a>（3）启动线程：</h4><p>在线程的Thread对象上调用start()方法，而不是run()或者别的方法。</p><p><strong>通过继承Thread类创建线程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo02 extends Thread&#123; </span><br><span class="line">public void run()&#123; </span><br><span class="line">System.out.println(“线程启动！”); </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">ThreadDemo02 thread = new ThreadDemo02(); </span><br><span class="line">thread.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过实现Runnable接口创建线程：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo03 implements Runnable&#123; </span><br><span class="line">public void run() &#123; </span><br><span class="line">System.out.println(“线程启动02”); </span><br><span class="line">&#125; </span><br><span class="line">public static void main(String[] args) &#123; </span><br><span class="line">Thread thread01 = new Thread(new ThreadDemo03()); </span><br><span class="line">thread01.start(); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>start()方法和run()方法的区别：</strong><br>（1）启动一个线程是start()方法，启动线程之后start()方法会去调用run方法内容。<br>（2）start是创建并启动一个线程，而run是要运行线程中的代码。<br>（3）run()方法 : 在本线程内调用该Runnable对象的run()方法，可以重复多次调用；<br>start()方法 : 启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程；</p><h3 id="在JAVA中，有六个不同的地方可以存储数据"><a href="#在JAVA中，有六个不同的地方可以存储数据" class="headerlink" title="在JAVA中，有六个不同的地方可以存储数据"></a>在JAVA中，有六个不同的地方可以存储数据</h3><p><strong>（1） 寄存器（register）</strong>：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。<br><strong>（2） 堆栈（stack）</strong>：位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。<br><strong>（3）堆（heap）</strong>：一种通用性的内存池（也存在于RAM中），用于存放所以的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。<br><strong>（4）静态存储（static storage）</strong>：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。<br><strong>（5）常量存储（constant storage）</strong>：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中<br><strong>（6）非RAM存储</strong>：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。</p><h3 id="java-concurrent包下的4个类，选出差别最大的一个-C"><a href="#java-concurrent包下的4个类，选出差别最大的一个-C" class="headerlink" title="java concurrent包下的4个类，选出差别最大的一个 (C)"></a>java concurrent包下的4个类，选出差别最大的一个 (C)</h3><p>==A. Semaphore   B. ReentrantLock    C. Future   D. CountDownLatch== </p><p>别的类都处理线程间的关系，处理并发机制，但Future 只用于获取线程结果。<br>Future是个接口，表示获取一个正在指定的线程的结果。对该线程有取消和判断是否执行完毕等操作。<br>CountDownLatch 是个锁存器，他表示我要占用给定的多少个线程且我优先执行，我执行完之前其他要使用该资源的都要等待。<br>Semaphore，就像是一个许可证发放者，也像一个数据库连接池。证就这么多，如果池中的证没换回来，其他人就不能用。<br>ReentrantLock 和 synchronized一样，用于锁定线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是线程？什么是进程？同一进程下的线程共享&quot;&gt;&lt;a href=&quot;#什么是线程？什么是进程？同一进程下的线程共享&quot; class=&quot;headerlink&quot; title=&quot;什么是线程？什么是进程？同一进程下的线程共享&quot;&gt;&lt;/a&gt;什么是线程？什么是进程？同一进程下的线程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>排序算法之——冒泡排序</title>
    <link href="http://yoursite.com/2018/06/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E2%80%94%E2%80%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/04/排序算法之——冒泡排序/</id>
    <published>2018-06-04T06:39:00.851Z</published>
    <updated>2018-06-04T06:38:46.860Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>冒泡排序顾名思义就是整个过程像气泡一样往上升，单向冒泡排序的基本思想是（假设由小到大排序）：对于给定n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行一轮比较和换位后，n个记录的最大记录将位于第n位，然后对前（n-1）个记录进行第二轮比较；重复该过程，直到记录剩下一个为止。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>当最好的情况，也就是要排序的序列本身就是有序的，需要进行<em>（n-1）</em>次比较，没有数据交换，时间复杂度为<em>O(n)</em>. 当最坏的情况，即待排序的表是逆序的情况，此时需要比较次数为：<br>$$<br>1+2+3+…+(n-1)=n(n-1)/2<br>$$<br> 次，并作等数量级的记录移动，因此总的时间复杂度为<img src="https://upload-images.jianshu.io/upload_images/12434140-6f290d8695017850.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="排序过程如下"><a href="#排序过程如下" class="headerlink" title="排序过程如下"></a>排序过程如下</h4><p>以数组{49,38,65,97,76,13,27,49}为例，</p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-991062ec7b3a54b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-4ff065f92e772bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="Java实现如下"><a href="#Java实现如下" class="headerlink" title="Java实现如下"></a>Java实现如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a.length - <span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = a[j];</span><br><span class="line">                    a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">                    a[j - <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a[] = &#123; <span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line">        bubbleSort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h4&gt;&lt;p&gt;冒泡排序顾名思义就是整个过程像气泡一样往上升，单向冒泡排序的基本思想是（假设由小到大排序）：对于给定n个记录，从第一个记录开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring框架总结</title>
    <link href="http://yoursite.com/2018/06/04/spring%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/04/spring框架总结/</id>
    <published>2018-06-04T05:58:51.971Z</published>
    <updated>2018-06-04T05:58:35.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="spring-IOC与AOP思想的理解"><a href="#spring-IOC与AOP思想的理解" class="headerlink" title="spring IOC与AOP思想的理解"></a>spring IOC与AOP思想的理解</h4><p>控制反转（IOC）：所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。</p><p>依赖注入（DI）：在运行期，由外部容器动态地将依赖对象注入到组件中，从而创建用对象之间协作关系（也称为装配）。在代码中的展现形式是在配置文件applicationContext.xml中管理Bean。</p><p>面向切面编程被定义为促使应用程序分离关注点的一项技术。系统由许多不同组件组成，每个组件负责一块特定的功能。除了负责实现自身核心的功能之外，这些组件还承担着额外的职责。诸如日志、事务管理和安全此类的系统服务经常融入到有自身核心业务逻辑的组件中去，这些系统通常被称为横切关注点，因为它们总是跨越系统的多个组件。</p><p><strong>依赖注入让相互协作的软件组织保持松散耦合；<br>AOP编程把遍布应用各处的功能分离出来形成可重用的组件。</strong></p><h4 id="spring-aop中的propagation的7种配置的意思"><a href="#spring-aop中的propagation的7种配置的意思" class="headerlink" title="spring aop中的propagation的7种配置的意思"></a>spring aop中的propagation的7种配置的意思</h4><p>REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。<br>MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。<br>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。<br>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。<br>NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。</p><h4 id="SpringMVC与Struts2区别与比较总结"><a href="#SpringMVC与Struts2区别与比较总结" class="headerlink" title="SpringMVC与Struts2区别与比较总结"></a><strong>SpringMVC与Struts2区别与比较总结</strong></h4><p>（1）Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应。所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。<br>（2）由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量。而Struts2虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。<br>（3）由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。<br>（4）拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。<br>（5）SpringMVC的入口是servlet，而Struts2是filter（filter和servlet是不同的，以前认为filter是servlet的一种特殊）。<br>（6）SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。<br>（7）SpringMVC验证支持JSR303，处理起来相对更加灵活方便，而Struts2验证比较繁琐，感觉太烦乱。<br>（8）Spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。<br>（9）设计思想上，Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。<br>（10）SpringMVC开发效率和性能高于Struts2。<br>（11）SpringMVC可以认为已经100%零配置。</p><h4 id="Spring中bean的生命周期"><a href="#Spring中bean的生命周期" class="headerlink" title="Spring中bean的生命周期"></a>Spring中bean的生命周期</h4><p>创建：<code>&lt;bean name=”” class=”” 额外属性&gt;</code><br>初始化：配置init-method/实现接口InitializingBean<br>调用：context.getBean(),进行方法的调用<br>销毁：配置destroy-method/实现DisposableBean接口</p><h4 id="Spring注入方式"><a href="#Spring注入方式" class="headerlink" title="Spring注入方式"></a>Spring注入方式</h4><p>接口注入<br>属性注入（属性的SET/GET）<br>构造注入（构造方法注入）<br>使用构造函数依赖注入时，Spring保证所有一个对象所有依赖的对象先实例化后，才实例化这个对象。使用set方法依赖注入时，Spring首先实例化对象，然后才实例化所有依赖的对象。<br>当设值注入与构造注入同时存在时，先执行设值注入，再执行构造注入。</p><h4 id="Spring的7大核心模块"><a href="#Spring的7大核心模块" class="headerlink" title="Spring的7大核心模块"></a>Spring的7大核心模块</h4><p>（1）Spring Core：Core封装包是框架的最基础部分，提供IOC和依赖注入特性。这里的基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。<br>（2）Spring Context: 构建于Core封装包基础上的Context封装包，提供了一种框架式的对象访问方法，像JNDI注册器。 Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。<br>（3）Spring DAO: DAO(Data Access Object)提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码。并且，JDBC封装包还提供了一种比编程性更好的声明性事务管理方法，不仅仅是实现了特定接口，而且对所有的POJOs（plain old Java objects）都适用。<br>（4）Spring ORM: ORM封装包提供了常用的“对象/关系”映射APIs的集成层。其中包括JPA、JDO、Hibernate和iBatis。利用ORM封装包，可以混合使用所有Spring提供的特性进行“对象/关系”映射，如前边提到的简单声明性事务管理。<br>（5）Spring AOP: Spring的AOP封装包提供了符合AOP Alliance规范的面向方面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用source-level的元数据功能，还可以将各种行为信息合并到你的代码中。<br>（6）Spring Web: Spring中的Web包提供了基础的针对Web开发的集成特性，例如多方文件上传，利用Servlet listeners进行IOC容器初始化和针对Web的ApplicationContext。当与WebWork或Struts一起使用Spring时，这个包使Spring可与其他框架结合。<br>（7）Spring Web MVC: Spring中的MVC封装包提供了Web应用的Model-View-Controller（MVC）实现。Spring的MVC框架并不是仅仅提供一种传统的实现，它提供了一种清晰的分离模型，在领域模型代码和Web Form之间。并且，还可以借助Spring框架的其他特性。</p><h4 id="Spring框架中获取连接池的方式"><a href="#Spring框架中获取连接池的方式" class="headerlink" title="Spring框架中获取连接池的方式"></a>Spring框架中获取连接池的方式</h4><p>DBCP数据源<br>C3P0数据源<br>Spring的数据源实现类(DriverManagerDataSource)<br>获取JNDI数据源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;spring-IOC与AOP思想的理解&quot;&gt;&lt;a href=&quot;#spring-IOC与AOP思想的理解&quot; class=&quot;headerlink&quot; title=&quot;spring IOC与AOP思想的理解&quot;&gt;&lt;/a&gt;spring IOC与AOP思想的理解&lt;/h4&gt;&lt;p&gt;控制
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用sql语句大汇总</title>
    <link href="http://yoursite.com/2018/06/04/%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5%E5%A4%A7%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/06/04/常用sql语句大汇总/</id>
    <published>2018-06-04T05:53:07.038Z</published>
    <updated>2018-06-04T05:53:32.976Z</updated>
    
    <content type="html"><![CDATA[<ol><li>说明：创建数据库<br>CREATE DATABASE database-name;</li><li>说明：删除数据库<br>DROP DATABASE database-name;</li><li>说明：创建新表<br>create table <code>depart</code> (<code>dept_id</code> int(11) NOT NULL AUTO_INCREMENT,<br><code>dept_name</code> varchar(255) DEFAULT NULL, PRIMARY KEY (<code>dept_id</code>));<br>根据已有的表创建新表：<br>create table tab_new like tab_old (使用旧表B创建新表A)<br>备注：此种方式在将表B复制到A时候会将表B完整的字段结构和索引复制到表A中来<br>create table tab_new as select col1,col2… from tab_old definition only<br>备注：此种方式只会将表B的字段结构复制到表A中来，但不会复制表B中的索引到表A中来。这种方式比较灵活可以在复制原表表结构的同时指定要复制哪些字段，并且自身复制表也可以根据需要增加字段结构。<br>create table as select 会将原表中的数据完整复制一份，但表结构中的索引会丢失。<br>create table like 只会完整复制原表的建表语句，但不会复制数据。</li><li>说明：删除新表<br>drop table tabname；</li><li>说明：增加一个列<br>alter table tabname add column column_name type</li><li>说明：添加主键： Alter table tabname add primary key(col)<br>说明：删除主键： Alter table tabname drop primary key<br>一个数据表只可以有一个主键，所以不存在删除某一列的主键.</li><li>说明：创建索引：create [unique] index idxname on tabname(col….)<br>删除索引：drop index idxname<br>注：索引是不可更改的，想更改必须删除重新建。</li><li>说明：创建视图：create view viewname as select statement<br>删除视图：drop view viewname</li><li>说明：几个简单的基本的sql语句<br>选择：select <em> from table1 where 范围<br>插入：insert into table1(field1,field2) values(value1,value2)<br>删除：delete from table1 where 范围<br>更新：update table1 set field1=value1 where 范围<br>查找：select </em> from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!<br>排序：select * from table1 order by field1,field2 [desc]<br>desc：降序，asc：升序<br>总数：select count as totalcount from table1<br>求和：select sum(field1) as sumvalue from table1<br>平均：select avg(field1) as avgvalue from table1<br>最大：select max(field1) as maxvalue from table1<br>最小：select min(field1) as minvalue from table1</li><li>分组:Group by:<br>一张表，一旦分组完成后，查询后只能得到组相关的信息。<br>组相关的信息：（统计信息） count,sum,max,min,avg 分组的标准)</li><li>说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)<br>法一：select <em> into b from a where 1&lt;&gt;1（仅用于SQlServer）<br>法二：select top 0 </em> into b from a</li><li>说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)<br>insert into b(a, b, c) select d,e,f from b;</li><li>说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)<br>insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件<br>例子：..from b in ‘”&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”’ where..</li><li>说明：子查询(表名1：a 表名2：b)</li><li>select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</li><li>说明：显示文章、提交人和最后回复时间<br>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</li><li>说明：外连接查询(表名1：a 表名2：b)<br>select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</li><li>说明：在线视图查询(表名1：a )<br>select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</li><li>说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br>select * from table1 where time between time1 and time2<br>select a,b,c, from table1 where a not between 数值1 and 数值2</li><li>说明：in 的使用方法<br>select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</li><li>说明：两张关联表，删除主表中已经在副表中没有的信息<br>delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</li><li>说明：四表联查问题：<br>select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …..</li><li>说明：日程安排提前五分钟提醒<br>SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</li><li>说明：一条sql 语句搞定数据库分页<br>select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段<br>具体实现：<br>关于数据库分页：<br>declare @start int,@end int<br>@sql nvarchar(600)<br>set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’<br>exec sp_executesql @sql<br>注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）</li><li>说明：前10条记录<br>select top 10 * form table1 where 范围</li><li>说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br>select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</li><li>说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表<br>(select a from tableA ) except (select a from tableB) except (select a from tableC)</li><li>说明：随机取出10条数据<br>select top 10 * from tablename order by newid()</li><li>说明：随机选择记录<br>select newid()</li><li>说明：删除重复记录<br>1),delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)<br>2),select distinct <em> into temp from tablename<br>delete from tablename<br>insert into tablename select </em> from temp<br>评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;说明：创建数据库&lt;br&gt;CREATE DATABASE database-name;&lt;/li&gt;
&lt;li&gt;说明：删除数据库&lt;br&gt;DROP DATABASE database-name;&lt;/li&gt;
&lt;li&gt;说明：创建新表&lt;br&gt;create table &lt;code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>装饰者模式(Decorator Pattern)</title>
    <link href="http://yoursite.com/2018/06/04/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F(Decorator%20Pattern)/"/>
    <id>http://yoursite.com/2018/06/04/装饰者模式(Decorator Pattern)/</id>
    <published>2018-06-04T05:27:56.436Z</published>
    <updated>2018-06-04T05:31:27.355Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>装饰者模式（又称装饰模式、包装(Wrapper)模式）：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 </p><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><p>以下情况使用Decorator模式：</p><p>• 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p><p>• 处理那些可以撤消的职责。</p><p>• 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>——抽象构件角色(Component)</p><p>给出一个个抽象接口，以规范准备接收附加责任的对象。是被装饰类和装饰类的父接口。</p><p>——具体构建角色(Concrete Component)</p><p>定义一个将要接受附加责任的类，即被装饰的类。</p><p>——装饰角色(Decorator)</p><p>装饰者，持有一个构件(Component)对象的引用，并定义一个与抽象构件接口一致的接口。</p><p>——具体装饰角色(Concrete Decorator)</p><p>具体装饰者，负责给构件对象“贴上”附加的责任（扩展功能）</p><h4 id="结构图示"><a href="#结构图示" class="headerlink" title="结构图示"></a>结构图示</h4><p><img src="https://upload-images.jianshu.io/upload_images/12434140-e9e6cec2eabfb579.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="一个demo"><a href="#一个demo" class="headerlink" title="一个demo:"></a>一个demo:</h4><h5 id="使用场景描述"><a href="#使用场景描述" class="headerlink" title="使用场景描述"></a>使用场景描述</h5><p>用过 <code>QQ</code> 的人都知道， 它有很多特权服务，比如说 <code>Vip</code> , <code>SVip</code> 等。我们就以此为例对装饰者模式进行探索。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String des;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">        des = &quot;I am common user&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void function() &#123;</span><br><span class="line">        System.out.println(&quot;I can use common function.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，在这里我们只是一个普通用户，而且也只能使用普通用户的功能。那么接下来，我们想要将普通用户升级为会员，可以使用会员功能，怎么办呢？难道这个时候我们还要去修改 <code>function()</code> 中的代码吗？如果真是这样，工作量真是大的难以想象。而且出于让我们得代码遵守开闭原则的目的，我们不能去盲目的修改源代码。下面我们就用装饰者模式将普通用户升级为 <code>Vip/svip</code> 用户。</p><h5 id="用装饰者模式解决实际问题："><a href="#用装饰者模式解决实际问题：" class="headerlink" title="用装饰者模式解决实际问题："></a>用装饰者模式解决实际问题：</h5><p>———————————————————装饰者模式———————————————————–</p><p>首先，我们需要保证装饰者和被装饰对象有相同的超类型，所以我们现在将用户写成一个抽象类。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line">//user超类 </span><br><span class="line">public abstract class User &#123;</span><br><span class="line"></span><br><span class="line">public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return &quot;I am common user&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始书写被装饰对象 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line">//普通用户</span><br><span class="line">public class CommonUser extends User &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void function() &#123;</span><br><span class="line">System.out.println(&quot;I can use common function.&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面开始书写装饰对象，装饰者可以在被装饰者行为之前或者之后或者覆盖原功能加上自己的行为，以达到特定的目的。下面我们也为装饰者对象写一个抽象类，并让其继承自 <code>User</code> 用以保证装饰者和被装饰者拥有共同的父类。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line">//装饰者抽象类</span><br><span class="line">public abstract class Decorator extends User &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void function() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public abstract String updateTime();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面写两个具体装饰者角色，<code>vip和svip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">////vip功能，具体装饰者</span><br><span class="line">public class VipDecorator extends Decorator &#123;</span><br><span class="line">private Date mDate;</span><br><span class="line">    private User user;</span><br><span class="line">    </span><br><span class="line">    public VipDecorator(User user) &#123;</span><br><span class="line">        mDate = new Date();</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String updateTime() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">    public void function() &#123;</span><br><span class="line">        user.function();</span><br><span class="line">        System.out.println(&quot;Vip function. &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return &quot;I am vip user.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">//svip功能，具体装饰者</span><br><span class="line">public class SVipDecorator extends Decorator &#123;</span><br><span class="line"></span><br><span class="line">   private Date mDate;</span><br><span class="line">    private User user;</span><br><span class="line">    </span><br><span class="line">    public SVipDecorator(User user) &#123;</span><br><span class="line">        mDate = new Date();</span><br><span class="line">        this.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">public String updateTime() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void function() &#123;</span><br><span class="line">        user.function();</span><br><span class="line">        System.out.println(&quot;SVip function. &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDes() &#123;</span><br><span class="line">        return &quot;I am SVip user&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，写个测试类，在原来的基础上进项测试。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">User user = new CommonUser();</span><br><span class="line">        System.out.println(user.getDes());</span><br><span class="line">        user.function();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        </span><br><span class="line">        user = new VipDecorator(user);</span><br><span class="line">        System.out.println(user.getDes());</span><br><span class="line">        user.function();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        user = new SVipDecorator(user);</span><br><span class="line">        System.out.println(user.getDes());</span><br><span class="line">        user.function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">I am common user</span><br><span class="line">I can use common function.</span><br><span class="line">-------------------------</span><br><span class="line">I am vip user.</span><br><span class="line">I can use common function.</span><br><span class="line">Vip function. </span><br><span class="line">-------------------------</span><br><span class="line">I am SVip user</span><br><span class="line">I can use common function.</span><br><span class="line">Vip function. </span><br><span class="line">SVip function.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h4&gt;&lt;p&gt;装饰者模式（又称装饰模式、包装(Wrapper)模式）：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 &lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>intellij idea最常用快捷键</title>
    <link href="http://yoursite.com/2018/06/04/intellij%20idea%E6%9C%80%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/06/04/intellij idea最常用快捷键/</id>
    <published>2018-06-04T03:40:05.827Z</published>
    <updated>2018-06-04T03:40:44.525Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理以前的笔记，发现很多挺有用的东西，虽然现在看起来已经很简单了，但是毕竟是自己亲自总结的，不忍丢弃。这是一些idea最常用快捷键，虽然使用intellij idea一年多了，但偶尔还会记错，急用时就不用再去找笔记了。</p><table><thead><tr><th>方法</th><th>快捷键</th></tr></thead><tbody><tr><td>向上空一行</td><td>Ctrl+ALT+Enter</td></tr><tr><td>向下空一行</td><td>Shift+Enter</td></tr><tr><td>向上移动方法块</td><td>Ctrl+Shift+↑</td></tr><tr><td>向下移动方法块</td><td>Ctrl+Shift+↓</td></tr><tr><td>删除行</td><td>Ctrl+X</td></tr><tr><td>复制行</td><td>Ctrl+D</td></tr><tr><td>格式化代码</td><td>Ctrl+Alt+L</td></tr><tr><td>查看一个类所有方法</td><td>Ctrl+F12</td></tr><tr><td>重写接口实现类</td><td>Ctrl+I</td></tr><tr><td>导入包,自动修正</td><td>Alt+Enter</td></tr><tr><td>去除未引用的类和包</td><td>Ctrl+Alt+O</td></tr><tr><td>方法参数提示</td><td>Ctrl+P</td></tr><tr><td>显示类结构图</td><td>Ctrl+H</td></tr><tr><td>查找类</td><td>Ctrl+N</td></tr><tr><td>查找文件</td><td>Ctrl+Shift+N</td></tr><tr><td>补全代码</td><td>Ctrl+ALT+V</td></tr><tr><td>搜索</td><td>Ctrl+F</td></tr><tr><td>ry…catch..</td><td>Ctrl+Alt+T</td></tr><tr><td>快速打开或隐藏工程面板</td><td>Alt+1</td></tr><tr><td>生成get或set方法快捷键</td><td>Alt+insert</td></tr><tr><td>导入未实现的方法,强制类型转换</td><td>Alt+Enter</td></tr><tr><td>断点调式查看值</td><td>Alt+F8</td></tr><tr><td>Debug(遇到嵌套的方法会进入)</td><td>F7</td></tr><tr><td>Debug(遇到嵌套方法跳过)</td><td>F8</td></tr><tr><td>Debug(调到下一个断点)</td><td>F9</td></tr><tr><td>设置</td><td>Ctrl+Alt+S</td></tr><tr><td>替换</td><td>Ctrl+R</td></tr><tr><td>新建Modules</td><td>Ctrl+Shift+Alt+T</td></tr><tr><td>foreach 循环</td><td>Ctrl + j</td></tr><tr><td>public static void main(String[] args)</td><td>psvm</td></tr><tr><td>System.out.println()</td><td>sout</td></tr><tr><td>全文查找</td><td>Ctrl+Shift+F</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天整理以前的笔记，发现很多挺有用的东西，虽然现在看起来已经很简单了，但是毕竟是自己亲自总结的，不忍丢弃。这是一些idea最常用快捷键，虽然使用intellij idea一年多了，但偶尔还会记错，急用时就不用再去找笔记了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一种数组去重方法</title>
    <link href="http://yoursite.com/2018/06/04/%E4%B8%80%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/04/一种数组去重方法/</id>
    <published>2018-06-04T01:54:39.566Z</published>
    <updated>2018-06-04T01:53:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>数组如何去重呢？可以先转成一个list集合，然后再把这个list集合整体放入一个新的LinkedHashSet&lt;&gt;中，hashSet不会添加重复的元素，这样就去除了那些重复的；最后再把这个LinkedHashSet&lt;&gt;转换为数组就可以了。下面贴上我的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer[] array = &#123;10,10,10,5,5,5,100,20,2000,2000,20,20,80,80,80,80&#125;;</span><br><span class="line">//把数组变成集合</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">//定义一个LinkedHashSet集合,可以去重并且按照存入的顺序进行显示</span><br><span class="line">LinkedHashSet&lt;Integer&gt; lhs = new LinkedHashSet&lt;&gt;();</span><br><span class="line">//将list中的内容添加到lhs中</span><br><span class="line">lhs.addAll(list);</span><br><span class="line">//把lhs集合中的内容变成数组</span><br><span class="line">Integer[] newArray = lhs.toArray(new Integer[lhs.size()]);</span><br><span class="line">System.out.println(&quot;原数组: &quot;+Arrays.toString(array));</span><br><span class="line">System.out.println(&quot;去重后的数组: &quot;+Arrays.toString(newArray));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组如何去重呢？可以先转成一个list集合，然后再把这个list集合整体放入一个新的LinkedHashSet&amp;lt;&amp;gt;中，hashSet不会添加重复的元素，这样就去除了那些重复的；最后再把这个LinkedHashSet&amp;lt;&amp;gt;转换为数组就可以了。下面贴上我的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BIO与NIO、AIO学习笔记</title>
    <link href="http://yoursite.com/2018/06/03/BIO,NIO,AIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/03/BIO,NIO,AIO学习笔记/</id>
    <published>2018-06-03T07:03:55.435Z</published>
    <updated>2018-06-03T12:12:50.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。</p><p>java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。<a href="http://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">字符集</a>编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和<a href="http://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">内存映射文件</a>的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。</p><h6 id="大纲目录"><a href="#大纲目录" class="headerlink" title="大纲目录"></a><strong>大纲目录</strong></h6><ul><li>1.总体介绍</li><li>2.IO基础知识回顾</li><li>3.BIO编程</li><li>4.伪异步I/O编程</li><li>5.NIO 编程简单介绍</li><li>6.通道 Channel</li><li>7.缓冲区 Buffer</li><li>8.选择器 Selector</li><li>9.分散（Scatter）/聚集（Gather）</li><li>10.其他通道</li><li>11.管道（Pipe）</li><li>12.AIO编程</li></ul><h6 id="IO，NIO，JDK介绍"><a href="#IO，NIO，JDK介绍" class="headerlink" title="IO，NIO，JDK介绍**"></a>IO，NIO，JDK介绍**</h6><p>查看JDK</p><h4 id="IO基础知识回顾"><a href="#IO基础知识回顾" class="headerlink" title="IO基础知识回顾"></a><strong>IO基础知识回顾</strong></h4><h6 id="IO流类图结构"><a href="#IO流类图结构" class="headerlink" title="IO流类图结构"></a>IO流类图结构</h6><p><img src="https://upload-images.jianshu.io/upload_images/12253573-4e46ad888ecd59c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO流知识图.jpg"></p><h6 id="IO流简单例子"><a href="#IO流简单例子" class="headerlink" title="IO流简单例子"></a>IO流简单例子</h6><p>实例一：        </p><pre><code>FileInputStream fis=null;FileOutputStream fos=null;try {    fis = new FileInputStream(new File(&quot;D:\\a.txt&quot;));    fos = new FileOutputStream(new File(&quot;D:\\y.txt&quot;));    int ch;    while((ch=fis.read()) != -1){        System.out.println((char)ch);        fos.write(ch);    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}finally {    if(null != fos){        fos.close();    }    if(null != fis){        fis.close();    }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12253573-9ce8520cc3d558a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-480f7ddf1d788db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>实例二：字节流转换成字符流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:\\a.txt&quot;)));</span><br><span class="line">            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;D:\\y.txt&quot;)));</span><br><span class="line">            String s;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            while((s=br.readLine())!=null)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                bw.write(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != bw)&#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实例三：用转换流从控制台上读入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            String s=br.readLine();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h4><h5 id="传统BIO通信模型图"><a href="#传统BIO通信模型图" class="headerlink" title="传统BIO通信模型图"></a><strong>传统BIO通信模型图</strong></h5><p>​    传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行<strong>同步阻塞式</strong>通信。 服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。</p><p>​    简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。</p><p>​    传统BIO通信模型图：</p><p>​    <img src="https://upload-images.jianshu.io/upload_images/12253573-ee9dde1900e94c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>​    该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，<strong>服务端的线程个数和客户端并发访问数呈1:1的正比关系</strong>，<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p><h5 id="传统BIO编程实例"><a href="#传统BIO编程实例" class="headerlink" title="传统BIO编程实例"></a><strong>传统BIO编程实例</strong></h5><p>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">package com.evada.de;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */</span><br><span class="line">public final class AyTest extends BaseTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //启动线程，运行服务器</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ServerBetter.start();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">        //启动线程，运行客户端</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;;</span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @SuppressWarnings(&quot;static-access&quot;)</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //随机产生算术表达式</span><br><span class="line">                    String expression = random.nextInt(10) + &quot;&quot; + operators[random.nextInt(4)] + (random.nextInt(10) + 1);</span><br><span class="line">                    Client.send(expression);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.currentThread().sleep(random.nextInt(1000));</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ServerBetter&#123;</span><br><span class="line"></span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    //单例的ServerSocket</span><br><span class="line">    private static ServerSocket server;</span><br><span class="line"></span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span><br><span class="line">    public static void start() throws IOException &#123;</span><br><span class="line">        //使用默认值端口</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;</span><br><span class="line">        if(server != null) return;</span><br><span class="line">        try&#123;</span><br><span class="line">            //通过构造函数创建ServerSocket，如果端口合法且空闲，服务端就监听成功</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">            //通过无线循环监听客户端连接，如果没有客户端接入，将阻塞在accept操作上。</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码</span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路</span><br><span class="line">                new Thread(new ServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(server != null)&#123;</span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            String expression;</span><br><span class="line">            String result;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //通过BufferedReader读取一行</span><br><span class="line">                //如果已经读到输入流尾部，返回null,退出循环</span><br><span class="line">                //如果得到非空值，就尝试计算结果并返回</span><br><span class="line">                if((expression = in.readLine())==null) break;</span><br><span class="line">                System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">                try&#123;</span><br><span class="line">                    result = &quot;123&quot;;//Calculator.cal(expression).toString();</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                    result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_SERVER_PORT = 12345;</span><br><span class="line">    //默认服务器Ip</span><br><span class="line">    private static String DEFAULT_SERVER_IP = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    public static void send(String expression)&#123;</span><br><span class="line">        send(DEFAULT_SERVER_PORT,expression);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void send(int port,String expression)&#123;</span><br><span class="line">        System.out.println(&quot;算术表达式为：&quot; + expression);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(DEFAULT_SERVER_IP,port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            out.println(expression);</span><br><span class="line">            System.out.println(&quot;___结果为：&quot; + in.readLine());</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一下必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪异步I-O编程"><a href="#伪异步I-O编程" class="headerlink" title="伪异步I/O编程"></a><strong>伪异步I/O编程</strong></h4><p>我们可以使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（<strong>但是底层还是使用的同步阻塞I/O</strong>），通常被称为“伪异步I/O模型“</p><h5 id="伪异步I-O编程模型图"><a href="#伪异步I-O编程模型图" class="headerlink" title="伪异步I/O编程模型图"></a>伪异步I/O编程模型图</h5><p><img src="https://upload-images.jianshu.io/upload_images/12253573-096c246f211d008d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="伪异步io流.png"></p><p>  测试运行结果是一样的。</p><p>​    我们知道，如果使用CachedThreadPool线程池（不限制线程数量，如果不清楚请参考文首提供的文章），其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用<strong>FixedThreadPool</strong>我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型。</p><p>​    但是，正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流就行读取时，会一直阻塞，直到发生：</p><ul><li>​    有数据可读</li><li>​    可用数据以及读取完毕</li><li>​    发生空指针或I/O异常</li></ul><p>​    所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。</p><p>​    而后面即将介绍的NIO，就能解决这个难题。</p><h5 id="伪异步IO编程代码"><a href="#伪异步IO编程代码" class="headerlink" title="伪异步IO编程代码"></a><strong>伪异步IO编程代码</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.anxpp.io.calculator.bio;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">import java.util.concurrent.ExecutorService;  </span><br><span class="line">import java.util.concurrent.Executors;  </span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */ </span><br><span class="line">public final class ServerBetter &#123;  </span><br><span class="line">    //默认的端口号  </span><br><span class="line">    private static int DEFAULT_PORT = 12345;  </span><br><span class="line">    //单例的ServerSocket  </span><br><span class="line">    private static ServerSocket server;  </span><br><span class="line">    //线程池 懒汉式的单例  </span><br><span class="line">    private static ExecutorService executorService = Executors.newFixedThreadPool(60);  </span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值  </span><br><span class="line">    public static void start() throws IOException&#123;  </span><br><span class="line">        //使用默认值  </span><br><span class="line">        start(DEFAULT_PORT);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了  </span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;  </span><br><span class="line">        if(server != null) return;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            //通过构造函数创建ServerSocket  </span><br><span class="line">            //如果端口合法且空闲，服务端就监听成功  </span><br><span class="line">            server = new ServerSocket(port);  </span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);  </span><br><span class="line">            //通过无线循环监听客户端连接  </span><br><span class="line">            //如果没有客户端接入，将阻塞在accept操作上。  </span><br><span class="line">            while(true)&#123;  </span><br><span class="line">                Socket socket = server.accept();  </span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码  </span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路  </span><br><span class="line">                executorService.execute(new ServerHandler(socket));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            //一些必要的清理工作  </span><br><span class="line">            if(server != null)&#123;  </span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);  </span><br><span class="line">                server.close();  </span><br><span class="line">                server = null;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1,同步和异步是针对应用程序和内核的交互而言的。 </li><li>2,阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。  </li></ul><p>由上描述基本可以总结一句简短的话，<strong>同步和异步是目的，阻塞和非阻塞是实现方式</strong>。</p><p><strong>同步阻塞：</strong><br>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。 </p><p><strong>同步非阻塞：</strong><br>在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。<br><strong>异步：</strong><br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>如果你想吃一份宫保鸡丁盖饭： </p><p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ </p><p>同步非阻塞（NIO）：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><h4 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h5><p>Java NIO(New IO)是一个可以替代标准Java IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p><p>Java NIO 由以下几个核心部分组成： </p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件，但Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，我将集中精力在这三个组件上。其它组件会在单独的章节中讲到。 </p><p>注意（每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送响应）</p><h5 id="非常形象的实例"><a href="#非常形象的实例" class="headerlink" title="非常形象的实例"></a><strong>非常形象的实例</strong></h5><p>小量的线程如何同时为大量连接服务呢，答案就是就绪选择。这就好比到餐厅吃饭，每来一桌客人，都有一个服务员专门为你服务，从你到餐厅到结帐走人，这样方式的好处是服务质量好，一对一的服务，VIP啊，可是缺点也很明显，成本高，如果餐厅生意好，同时来100桌客人，就需要100个服务员，那老板发工资的时候得心痛死了，这就是传统的一个连接一个线程的方式。</p><p>老板是什么人啊，精着呢。这老板就得捉摸怎么能用10个服务员同时为100桌客人服务呢，老板就发现，服务员在为客人服务的过程中并不是一直都忙着，客人点完菜，上完菜，吃着的这段时间，服务员就闲下来了，可是这个服务员还是被这桌客人占用着，不能为别的客人服务，用华为领导的话说，就是工作不饱满。那怎么把这段闲着的时间利用起来呢。这餐厅老板就想了一个办法，让一个服务员（前台）专门负责收集客人的需求，登记下来，比如有客人进来了、客人点菜了，客人要结帐了，都先记录下来按顺序排好。每个服务员到这里领一个需求，比如点菜，就拿着菜单帮客人点菜去了。点好菜以后，服务员马上回来，领取下一个需求，继续为别人客人服务去了。这种方式服务质量就不如一对一的服务了，当客人数据很多的时候可能需要等待。但好处也很明显，由于在客人正吃饭着的时候服务员不用闲着了，服务员这个时间内可以为其他客人服务了，原来10个服务员最多同时为10桌客人服务，现在可能10个服务员，就可以负责50桌、100桌。。。。</p><p>这种服务方式跟传统的区别有两个：</p><p>1、增加了一个角色，要有一个专门负责收集客人需求的人。NIO里对应的就是Selector。</p><p>2、由阻塞服务方式改为非阻塞服务了，客人吃着的时候服务员不用一直侯在客人旁边了。传统的IO操作，比如read()，当没有数据可读的时候，线程一直阻塞被占用，直到数据到来。NIO中没有数据可读时，read()会立即返回0，线程不会阻塞。</p><p>NIO中，客户端创建一个连接后，先要将连接注册到Selector，相当于客人进入餐厅后，告诉前台你要用餐，前台会告诉你你的桌号是几号，然后你就可能到那张桌子坐下了，SelectionKey就是桌号。当某一桌需要服务时，前台就记录哪一桌需要什么服务，比如1号桌要点菜，2号桌要结帐，服务员从前台取一条记录，根据记录提供服务，完了再来取下一条。这样服务的时间就被最有效的利用起来了。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h5><p>原理图一：简图</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-2d7f631076e8ecd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>原理图二：详图</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-f7ae6b97e9d8158c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h5><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>Stream oriented</td><td>Buffer oriented</td></tr><tr><td>Blocking IO</td><td>Non blocking IO</td></tr><tr><td></td><td>Selectors</td></tr></tbody></table><h6 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a><strong>面向流与面向缓冲</strong></h6><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的</p><p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它<strong>不能前后移动流中的数据</strong>。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的<strong>灵活性</strong>。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 </p><h6 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a><strong>阻塞与非阻塞IO</strong></h6><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p><h5 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a><strong>NIO和IO如何影响应用程序的设计</strong></h5><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面： </p><ul><li>对NIO或IO类的API调用。</li><li>数据处理。</li><li>用来处理数据的线程数。</li></ul><h5 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h6><p>Channel 是对数据的源头和数据目标点流经途径的抽象，在这个意义上和 InputStream 和 OutputStream 类似。Channel可以译为“通道、管 道”，而传输中的数据仿佛就像是在其中流淌的水。前面也提到了Buffer，Buffer和Channel相互配合使用，才是Java的NIO。</p><h6 id="Java-NIO的通道与流区别"><a href="#Java-NIO的通道与流区别" class="headerlink" title="Java NIO的通道与流区别"></a>Java NIO的通道与流区别</h6><ul><li><p>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</p></li><li><p>通道可以异步地读写。</p></li><li><p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</p><p>​</p></li></ul><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-77cb44a820e56481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-7d7a517d14ca4b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：通道必须结合Buffer使用，不能直接向通道中读/写数据</p><h6 id="Channel主要分类"><a href="#Channel主要分类" class="headerlink" title="Channel主要分类"></a><strong>Channel主要分类</strong></h6><p>广义上来说通道可以被分为两类：File I/O和Stream I/O，也就是文件通道和套接字通道。如果分的更细致一点则是：</p><ul><li>FileChannel 从文件读写数据</li><li>SocketChannel 通过TCP读写网络数据</li><li>ServerSocketChannel 可以监听新进来的TCP连接，并对每个链接创建对应的SocketChannel</li><li>DatagramChannel 通过UDP读写网络中的数据</li><li>Pipe</li></ul><h6 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a><strong>Channel的实现</strong></h6><p>这些是Java NIO中最重要的通道的实现： </p><ul><li>FileChannel：从文件中读写数据。</li><li>DatagramChannel：能通过UDP读写网络中的数据。</li><li>SocketChannel：能通过TCP读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h6 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h6><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d://nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure><h6 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h6><p>调用多个read()方法之一从FileChannel中读取数据。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p><p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h6 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h6><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><h6 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h6><p>用完FileChannel后必须将其关闭。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h6 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h6><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p><p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p><p>这里有两个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure><p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</p><p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p><h6 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h6><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure><h6 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h6><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure><p>这个例子截取文件的前1024个字节。</p><h6 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h6><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p><p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure><p><strong>transferFrom()</strong></p><p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，</span><br><span class="line">//需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</span><br><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();  </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();   </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure><p>transferFrom 方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 </p><p>此外要注意，在 SoketChannel 的实现中，SocketChannel 只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel 可能不会将请求的所有数据(count个字节)全部传输到 FileChannel 中。 </p><p><strong>transferTo()</strong></p><p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();    </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();  </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。 </p><p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。 </p><h6 id="Channel简单实例"><a href="#Channel简单实例" class="headerlink" title="Channel简单实例"></a><strong>Channel简单实例</strong></h6><p>下面是Channel的一个简单的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h5 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h5><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。 </p><h6 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a><strong>Buffer的基本用法</strong></h6><p>使用Buffer读写数据一般遵循以下四个步骤： </p><ul><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ul><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从<strong>写模式切换到读模式</strong>。在读模式下，可以读取之前写入到buffer的所有数据。 </p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 <strong>clear() 或 compact() 方法</strong>。clear() 方法会清空整个缓冲区。compact() <strong>方法只会清除已经读过的数据</strong>。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h6 id="Buffer的三个属性"><a href="#Buffer的三个属性" class="headerlink" title="Buffer的三个属性"></a><strong>Buffer的三个属性</strong></h6><p>为了理解Buffer的工作原理，需要熟悉它的三个属性： </p><ul><li><strong>capacity</strong>：作为一个内存块，Buffer 有一个固定的大小值，也叫 “capacity”. 你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。 </li><li><strong>position</strong>：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity – 1。 当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position会被重置为 0。当从Buffer的 position 处读取数据时，position 向前移动到下一个可读的位置。 </li><li><strong>limit</strong>：在写模式下，Buffer的limit表示你最多能往 Buffer 里写多少数据。 <strong>写模式下</strong>，limit 等于 Buffer 的 capacity 。 当切换Buffer到读模式时， limit 表示你<strong>最多</strong>能读到多少数据。因此，当切换Buffer到读模式时，limit 会被设置成写模式下的 position 值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是 position ）。 </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12253573-4f05e0bf6b4092fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buffers-modes.png"></p><h6 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a><strong>Buffer的类型</strong></h6><p>Java NIO 有以下Buffer类型： </p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h6 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a><strong>Buffer的分配</strong></h6><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储1024个字符的CharBuffer： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure><h6 id="Buffer写数据"><a href="#Buffer写数据" class="headerlink" title="Buffer写数据"></a><strong>Buffer写数据</strong></h6><p>写数据到Buffer有两种方式： </p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的put()方法写到Buffer里。</li></ul><p>从Channel写到Buffer，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer</span><br></pre></td></tr></table></figure><p>通过put方法写Buffer的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure><p>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。 </p><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><strong>flip()方法</strong></h5><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。 </p><p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。 </p><h6 id="Buffer中读取数据"><a href="#Buffer中读取数据" class="headerlink" title="Buffer中读取数据"></a><strong>Buffer中读取数据</strong></h6><p>从Buffer中读取数据有两种方式： </p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><p>从Buffer读取数据到Channel的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//read from buffer into channel.  </span><br><span class="line">int bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>使用get()方法从Buffer中读取数据的例子 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte = buf.get();</span><br></pre></td></tr></table></figure><p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。</p><p><strong>rewind()方法</strong> </p><p>Buffer.rewind()将 position 设回0，所以你可以重读Buffer中的所有数据。limit 保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</p><p><strong>clear()与compact()方法</strong></p><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。 </p><p>如果调用的是 clear() 方法，position将被设回 0，limit被设置成 capacity 的值。换句话说，Buffer 被清空了。</p><p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。 </p><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p><p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。 </p><p><strong>mark()与reset()方法</strong></p><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();  </span><br><span class="line">//set position back to mark.  </span><br><span class="line">buffer.reset();  </span><br><span class="line">equals()与compareTo()方法</span><br></pre></td></tr></table></figure><p>可以使用equals()和compareTo()方法两个Buffer。 </p><p><strong>equals()</strong></p><p>当满足下列条件时，表示两个Buffer相等： </p><ul><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的 byte、char 等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ul><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 </p><p><strong>compareTo()方法</strong></p><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer “小于” 另一个Buffer： </p><ul><li>第一个不相等的元素小于另一个Buffer中对应的元素。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li></ul><h5 id="选择器（-Selector）"><a href="#选择器（-Selector）" class="headerlink" title="选择器（ Selector）"></a>选择器（ Selector）</h5><h6 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h6><p>Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。Selector提供选择<strong>已经就绪的任务的能力</strong>：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过<strong>SelectionKey</strong>可以获取就绪Channel的集合，进行后续的I/O操作。</p><p>一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-6c12c7fbdf8b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>要使用Selector，得向 Selector 注册 Channel ，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子比如新连接进来，数据接收等。 </p><h6 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a><strong>Selector的创建</strong></h6><p>通过调用Selector.open()方法创建一个Selector，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h6 id="Selector注册通道"><a href="#Selector注册通道" class="headerlink" title="Selector注册通道"></a><strong>Selector注册通道</strong></h6><p>为了将 Channel 和 Selector 配合使用，必须将 channel 注册到 selector 上。通过 SelectableChannel.register() 方法来实现，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);  </span><br><span class="line">SelectionKey key = channel.register(selector,  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式。而套接字通道都可以。 </p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件： </p><ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个 server socket channel 准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。 </p><p>这四种事件用 SelectionKey 的四个常量来表示： </p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣，那么可以用 “ 位 或 ” 操作符将常量连接起来，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h6 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a><strong>SelectionKey</strong></h6><p>在上一小节中，当向Selector注册Channel时，register() 方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性： </p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><p>下面我会描述这些属性。</p><p><strong>interest集合</strong></p><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过 SelectionKey 读写 interest 集合，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line">boolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>可以看到，用“位与”操作interest 集合和给定的 SelectionKey 常量，<strong>可以确定某个确定的事件是否在 interest 集合中</strong>。</p><p><strong>ready集合</strong></p><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个readySet。Selection将在下一小节进行解释。可以这样访问ready集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用像检测 interest 集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel + Selector</strong></p><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><p><strong>附加的对象</strong></p><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><p><strong>通过Selector选择通道</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p><p>select(long timeout) 和 select() 一样，除了最长会阻塞 timeout 毫秒(参数)。</p><p>selectNow() 不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><p><strong>selectedKeys()</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当向 Selector 注册 Channel 时，Channel.register() 方法会返回一个 SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的 keyIterator.remove() 调用。Selector不会自己从已选择键集中移除 SelectionKey 实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel() 方法返回的通道需要转型成你要处理的类型，如 ServerSocketChannel 或 SocketChannel 等。</p><p><strong>wakeUp()</strong></p><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p><strong>close()</strong></p><p>用完 Selector 后调用其 close() 方法会关闭该 Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p><p>完整的示例</p><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p><pre><code>Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) {  int readyChannels = selector.select();  if(readyChannels == 0) continue;  Set selectedKeys = selector.selectedKeys();  Iterator keyIterator = selectedKeys.iterator();  while(keyIterator.hasNext()) {  SelectionKey key = keyIterator.next();  if(key.isAcceptable()) {    // a connection was accepted by a ServerSocketChannel.  } else if (key.isConnectable()) {    // a connection was established with a remote server.  } else if (key.isReadable()) {    // a channel is ready for reading  } else if (key.isWritable()) {    // a channel is ready for writing  }    keyIterator.remove();  }}</code></pre><h5 id="分散（Scatter）-聚集（Gather）"><a href="#分散（Scatter）-聚集（Gather）" class="headerlink" title="分散（Scatter）/聚集（Gather）"></a>分散（Scatter）/聚集（Gather）</h5><h6 id="分散概念"><a href="#分散概念" class="headerlink" title="分散概念"></a><strong>分散概念</strong></h6><p>分散（scatter）：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-bc98928415f0e3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure><p>注意buffer首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。read() 方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到buffer，当一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。 </p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。 </p><h6 id="聚集概念"><a href="#聚集概念" class="headerlink" title="聚集概念"></a><strong>聚集概念</strong></h6><p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-cae64631861a6ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">//write data into buffers  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>buffer的一个数组被传递给了 write() 方法，这个方法写他们在数组中遇到的接下来的 buffer 的内容。只是这些数据在 buffer 的 position 和 limit 直接被写。因此，如果一个buffer有一个128字节的容量，但是只包含了58个字节，只有58个字节可以从 buffer 中写到 channel 。因此，一个聚集写操作通过动态可变大小的消息部分会工作的很好，跟分散读取正好相反。</p><h6 id="分散-聚集的应用"><a href="#分散-聚集的应用" class="headerlink" title="分散/聚集的应用"></a><strong>分散/聚集的应用</strong></h6><p>scatter / gather经常用于需要将传输的数据分开处理的场合。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容纳正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p><p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p><h6 id="简单小例子"><a href="#简单小例子" class="headerlink" title="简单小例子"></a><strong>简单小例子</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf1=new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">//获取通道</span><br><span class="line">FileChannel channel1 = raf1.getChannel();</span><br><span class="line">//设置缓冲区</span><br><span class="line">ByteBuffer buf1=ByteBuffer.allocate(50);</span><br><span class="line">ByteBuffer buf2=ByteBuffer.allocate(1024);</span><br><span class="line">//分散读取的时候缓存区应该是有序的，所以把几个缓冲区加入数组中</span><br><span class="line">ByteBuffer[] bufs=&#123;buf1,buf2&#125;;</span><br><span class="line">//通道进行传输</span><br><span class="line">channel1.read(bufs);</span><br><span class="line">//查看缓冲区中的内容</span><br><span class="line">for (int i = 0; i &lt; bufs.length; i++) &#123;</span><br><span class="line">   //切换为读模式</span><br><span class="line">   bufs[i].flip();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(new String(bufs[0].array(),0,bufs[0].limit()));</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(new String(bufs[1].array(),0,bufs[1].limit()));</span><br><span class="line">//聚集写入</span><br><span class="line">RandomAccessFile  raf2=new RandomAccessFile(&quot;d:\\al.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel channel2 = raf2.getChannel();</span><br><span class="line">//只能通过通道来进行写入</span><br><span class="line">channel2.write(bufs);</span><br></pre></td></tr></table></figure><h5 id="其他通道"><a href="#其他通道" class="headerlink" title="其他通道"></a><strong>其他通道</strong></h5><p>​            </p><h6 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a><strong>文件通道</strong></h6><p>略</p><h6 id="Socket-通道"><a href="#Socket-通道" class="headerlink" title="Socket 通道"></a>Socket 通道</h6><p>Java NIO中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。可以通过以下2种方式创建 SocketChannel：</p><ul><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达 ServerSocketChannel 时，会创建一个 SocketChannel。</li></ul><p><strong>打开 SocketChannel</strong></p><p>下面是SocketChannel的打开方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;,80));</span><br></pre></td></tr></table></figure><p><strong>从 SocketChannel 读取数据</strong></p><p>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p><p>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p><p><strong>写入 SocketChannel</strong></p><p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p><p><strong>非阻塞模式</strong></p><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p><p><strong>connect()</strong></p><p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    //wait, or do something else...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>write()</strong></p><p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p><p><strong>read()</strong></p><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p><p><strong>不错的小例子</strong></p><p>一下是来自网络的一个小例子，个人觉得很不错，就贴到这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class NioClient &#123;</span><br><span class="line">    //管道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    public NioClient init(String serverIp, int port) throws IOException&#123;</span><br><span class="line">        //获取socket通道</span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        //获得通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line"></span><br><span class="line">        //客户端连接服务器，需要调用channel.finishConnect();才能实际完成连接。</span><br><span class="line">        channel.connect(new InetSocketAddress(serverIp, port));</span><br><span class="line">        //为该通道注册SelectionKey.OP_CONNECT事件</span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;客户端启动&quot;);</span><br><span class="line">        //轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //选择注册过的io操作的事件(第一次为SelectionKey.OP_CONNECT)</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选的key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                if(key.isConnectable())&#123;</span><br><span class="line">                    SocketChannel channel=(SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    //如果正在连接，则完成连接</span><br><span class="line">                    if(channel.isConnectionPending())&#123;</span><br><span class="line">                        channel.finishConnect();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向服务器发送消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to server.&quot;).getBytes()));</span><br><span class="line"></span><br><span class="line">                    //连接成功后，注册接收服务器消息的事件</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;客户端连接成功&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123; //有可读数据事件。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;recevie message from server:, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;client.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioClient().init(&quot;127.0.0.1&quot;, 9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class NioServer &#123;</span><br><span class="line">    //通道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    //获取一个ServerSocket通道，并初始化通道</span><br><span class="line">    public NioServer init(int port) throws IOException&#123;</span><br><span class="line">        //获取一个ServerSocket通道</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(false);</span><br><span class="line">        serverChannel.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        //获取通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line">        //将通道管理器与通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件，</span><br><span class="line">        //只有当该事件到达时，Selector.select()会返回，否则一直阻塞。</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;服务器端启动成功&quot;);</span><br><span class="line"></span><br><span class="line">        //使用轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //当有注册的事件到达时，方法返回，否则阻塞。</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            //获取selector中的迭代器，选中项为注册的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite=selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                //客户端请求连接事件</span><br><span class="line">                if(key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel)key.channel();</span><br><span class="line">                    //获得客户端连接通道</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向客户端发消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to client&quot;).getBytes()));</span><br><span class="line">                    //在与客户端连接成功后，为客户端通道注册SelectionKey.OP_READ事件。</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;客户端请求连接事件&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123;//有可读数据事件</span><br><span class="line">                    //获取客户端传输数据可读取消息通道。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                    //创建读取数据缓冲器</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    int read = channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;receive message from client, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;server.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioServer().init(9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Datagram-通道"><a href="#Datagram-通道" class="headerlink" title="Datagram 通道"></a>Datagram 通道</h6><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><p>Datagram 通道就作为大家自学的内容。</p><h5 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h5><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-0c5dc6435ff44191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12253573-9302f20c78103fbf.png"></p><h6 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a><strong>创建管道</strong></h6><p>通过Pipe.open()方法打开管道。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure><h6 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a><strong>向管</strong>道写数据</h6><p>要向管道写数据，需要访问sink通道。像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br></pre></td></tr></table></figure><p>通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();  </span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">buf.clear();  </span><br><span class="line">buf.put(newData.getBytes());  </span><br><span class="line">buf.flip();  </span><br><span class="line">while(buf.hasRemaining()) &#123;  </span><br><span class="line">   &lt;b&gt;sinkChannel.write(buf);&lt;/b&gt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a><strong>从管道读取数据</strong></h6><p>从读取管道的数据，需要访问source通道，像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据，像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。 </p><h6 id="简单完整实例"><a href="#简单完整实例" class="headerlink" title="简单完整实例"></a>简单完整实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//获取管道</span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">//获取Sink 管道</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">//需要写入数据</span><br><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">//新建缓存区</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">//缓存区存放数据</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line">//获取Source 管道</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">ByteBuffer buf2 = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = sourceChannel.read(buf2);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = sourceChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">sourceChannel.close();</span><br><span class="line">sinkChannel.close();</span><br></pre></td></tr></table></figure><h4 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h4><h6 id="AIO的特点"><a href="#AIO的特点" class="headerlink" title="AIO的特点"></a><strong>AIO的特点</strong></h6><ul><li><p>读完了再通知我</p></li><li><p>不会加快IO，只是在读完后进行通知</p></li><li><p>使用回调函数，进行业务处理</p><p>​</p></li></ul><p>AIO的相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AsynchronousServerSocketChannel类</span><br><span class="line">server = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT));</span><br></pre></td></tr></table></figure><p>使用server上的accept方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; void accept(A attachment,CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt; handler);</span><br></pre></td></tr></table></figure><p>CompletionHandler为回调接口，当有客户端accept之后，就做handler中的事情。</p><h6 id="NIO与AIO区别"><a href="#NIO与AIO区别" class="headerlink" title="NIO与AIO区别"></a>NIO与AIO区别</h6><ul><li>NIO是同步非阻塞的，AIO是异步非阻塞的</li><li>由于NIO的读写过程依然在应用线程里完成，所以对于那些读写过程时间长的，NIO就不太适合。而AIO的读写过程完成后才被通知，所以AIO能够胜任那些重量级，读写过程长的任务。</li></ul><p><strong>结束语</strong></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h4><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a></p><p>【2】<a href="http://www.iteye.com/magazines/132-Java-NIO" target="_blank" rel="noopener">http://www.iteye.com/magazines/132-Java-NIO</a></p><p>【3】<a href="http://www.jb51.net/article/92448.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92448.htm</a></p><p>【4】<a href="http://www.cnblogs.com/good-temper/p/5003892.html" target="_blank" rel="noopener">http://www.cnblogs.com/good-temper/p/5003892.html</a></p><p>【5】<a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm" target="_blank" rel="noopener">http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm</a></p><p>【6】<a href="https://www.ibm.com/developerworks/cn/java/l-niosvr/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-niosvr/</a></p><p>【7】Netty权威指南</p><p>【8】<a href="http://ifeve.com/selectors/" target="_blank" rel="noopener">http://ifeve.com/selectors/</a></p><p>【9】<a href="http://ifeve.com/socket-channel/" target="_blank" rel="noopener">http://ifeve.com/socket-channel/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typora for Markdown 快捷键</title>
    <link href="http://yoursite.com/2018/05/30/Typora-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/05/30/Typora-快捷键/</id>
    <published>2018-05-30T01:25:13.461Z</published>
    <updated>2018-05-30T11:10:38.829Z</updated>
    
    <content type="html"><![CDATA[<p>以前我写博客一直用的有道云笔记，前段时间突然了解到Typora这款软件功能的强大，于是就开始试着用，现在我已经彻底抛弃用了好几年的有道云，奉上一些我总结的最常用快捷键，初学者记住这些，就能流畅的写你的博客了！！！</p><h3 id="最快捷的方式"><a href="#最快捷的方式" class="headerlink" title="最快捷的方式"></a>最快捷的方式</h3><ul><li>鼠标右键。</li></ul><h3 id="操作快捷键"><a href="#操作快捷键" class="headerlink" title="操作快捷键"></a>操作快捷键</h3><table><thead><tr><th style="text-align:left">撤销</th><th style="text-align:left">Ctrl + Z</th></tr></thead><tbody><tr><td style="text-align:left">恢复</td><td style="text-align:left">Ctrl + Shift + Z</td></tr><tr><td style="text-align:left">查找</td><td style="text-align:left">Ctrl + F      (F3)</td></tr><tr><td style="text-align:left">替换</td><td style="text-align:left">Ctrl + H</td></tr><tr><td style="text-align:left">复制代码</td><td style="text-align:left">Ctrl + Shift + Z</td></tr><tr><td style="text-align:left">删除行</td><td style="text-align:left">Ctrl + Shift + L</td></tr></tbody></table><h3 id="语法快捷键"><a href="#语法快捷键" class="headerlink" title="语法快捷键"></a>语法快捷键</h3><table><thead><tr><th>标题</th><th>Ctrl + Alt + （0-6）</th></tr></thead><tbody><tr><td>标题调节</td><td>Ctrl + [（]）</td></tr><tr><td>表格</td><td>Ctrl + Alt + T</td></tr><tr><td>代码</td><td>Ctrl + Alt + C</td></tr><tr><td>数学公式</td><td>Ctrl + Alt + M</td></tr><tr><td>引用</td><td>Ctrl + Alt + Q</td></tr><tr><td>注脚</td><td>Ctrl + Alt + F</td></tr><tr><td>插入图片</td><td>Shift +Ctrl + I</td></tr><tr><td>删除线</td><td>Shift + Alt + 5</td></tr></tbody></table><table><thead><tr><th>链接</th><th>Ctrl + K</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl + B</td></tr><tr><td>斜体</td><td>Ctrl + I</td></tr><tr><td>下划线</td><td>Ctrl + U</td></tr><tr><td>清除格式</td><td>Ctrl + <code>\</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前我写博客一直用的有道云笔记，前段时间突然了解到Typora这款软件功能的强大，于是就开始试着用，现在我已经彻底抛弃用了好几年的有道云，奉上一些我总结的最常用快捷键，初学者记住这些，就能流畅的写你的博客了！！！&lt;/p&gt;
&lt;h3 id=&quot;最快捷的方式&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过zxing生成二维码</title>
    <link href="http://yoursite.com/2018/05/30/%E9%80%9A%E8%BF%87zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2018/05/30/通过zxing生成二维码/</id>
    <published>2018-05-29T17:16:28.784Z</published>
    <updated>2018-05-30T02:43:42.442Z</updated>
    
    <content type="html"><![CDATA[<p>二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，<br>二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。</p><h3 id="1、二维码的生成"><a href="#1、二维码的生成" class="headerlink" title="1、二维码的生成"></a>1、二维码的生成</h3><p> 　　1.1 将Zxing-core.jar 包加入到classpath下。可通过github获取<a href="https://github.com/zxing" target="_blank" rel="noopener">https://github.com/zxing</a></p><p>　　 1.2 二维码的生成需要借助MatrixToImageWriter类，该类是由Google提供的，可以将该类拷贝到源码中，这里我将该类的源码贴上，可以直接使用。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.guoqick.zxing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">createQRCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">300</span>;</span><br><span class="line">        String format = <span class="string">"png"</span>;</span><br><span class="line">        String content = <span class="string">"www.guoqick.cn"</span>;</span><br><span class="line">        <span class="comment">//定义二维码的参数</span></span><br><span class="line">        HashMap hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);</span><br><span class="line">        hints.put(EncodeHintType.MARGIN, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">            Path file = <span class="keyword">new</span> File(<span class="string">"E:/code/img.png"</span>).toPath();</span><br><span class="line">            MatrixToImageWriter.writeToPath(bitMatrix,format,file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、二维码的解析"><a href="#2、二维码的解析" class="headerlink" title="2、二维码的解析"></a>2、二维码的解析</h3><p>　　2.1 将Zxing-core.jar 包加入到classpath下。　　</p><p>　　2.2 和生成一样，我们需要一个辅助类（ BufferedImageLuminanceSource），同样该类Google也提供了，这里我同样将该类的源码贴出来，可以直接拷贝使用个，省去查找的麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.zxing;</span><br><span class="line"></span><br><span class="line">import java.awt.Graphics2D;</span><br><span class="line">import java.awt.geom.AffineTransform;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line">import com.google.zxing.LuminanceSource;</span><br><span class="line"></span><br><span class="line">public class BufferedImageLuminanceSource extends LuminanceSource &#123;</span><br><span class="line"></span><br><span class="line">private final BufferedImage image;</span><br><span class="line">   private final int left;</span><br><span class="line">   private final int top;</span><br><span class="line"> </span><br><span class="line">   public BufferedImageLuminanceSource(BufferedImage image) &#123;</span><br><span class="line">     this(image, 0, 0, image.getWidth(), image.getHeight());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public BufferedImageLuminanceSource(BufferedImage image, int left, int top, int width, int height) &#123;</span><br><span class="line">     super(width, height);</span><br><span class="line"> </span><br><span class="line">     int sourceWidth = image.getWidth();</span><br><span class="line">     int sourceHeight = image.getHeight();</span><br><span class="line">     if (left + width &gt; sourceWidth || top + height &gt; sourceHeight) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Crop rectangle does not fit within image data.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     for (int y = top; y &lt; top + height; y++) &#123;</span><br><span class="line">       for (int x = left; x &lt; left + width; x++) &#123;</span><br><span class="line">         if ((image.getRGB(x, y) &amp; 0xFF000000) == 0) &#123;</span><br><span class="line">           image.setRGB(x, y, 0xFFFFFFFF); // = white</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     this.image = new BufferedImage(sourceWidth, sourceHeight, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">     this.image.getGraphics().drawImage(image, 0, 0, null);</span><br><span class="line">     this.left = left;</span><br><span class="line">     this.top = top;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public byte[] getRow(int y, byte[] row) &#123;</span><br><span class="line">     if (y &lt; 0 || y &gt;= getHeight()) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Requested row is outside the image: &quot; + y);</span><br><span class="line">     &#125;</span><br><span class="line">     int width = getWidth();</span><br><span class="line">     if (row == null || row.length &lt; width) &#123;</span><br><span class="line">       row = new byte[width];</span><br><span class="line">     &#125;</span><br><span class="line">     image.getRaster().getDataElements(left, top + y, width, 1, row);</span><br><span class="line">     return row;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public byte[] getMatrix() &#123;</span><br><span class="line">     int width = getWidth();</span><br><span class="line">     int height = getHeight();</span><br><span class="line">     int area = width * height;</span><br><span class="line">     byte[] matrix = new byte[area];</span><br><span class="line">     image.getRaster().getDataElements(left, top, width, height, matrix);</span><br><span class="line">     return matrix;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean isCropSupported() &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public LuminanceSource crop(int left, int top, int width, int height) &#123;</span><br><span class="line">     return new BufferedImageLuminanceSource(image, this.left + left, this.top + top, width, height);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean isRotateSupported() &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public LuminanceSource rotateCounterClockwise() &#123;</span><br><span class="line"> </span><br><span class="line">       int sourceWidth = image.getWidth();</span><br><span class="line">     int sourceHeight = image.getHeight();</span><br><span class="line"> </span><br><span class="line">     AffineTransform transform = new AffineTransform(0.0, -1.0, 1.0, 0.0, 0.0, sourceWidth);</span><br><span class="line"> </span><br><span class="line">     BufferedImage rotatedImage = new BufferedImage(sourceHeight, sourceWidth, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"> </span><br><span class="line">     Graphics2D g = rotatedImage.createGraphics();</span><br><span class="line">     g.drawImage(image, transform, null);</span><br><span class="line">     g.dispose();</span><br><span class="line"> </span><br><span class="line">     int width = getWidth();</span><br><span class="line">     return new BufferedImageLuminanceSource(rotatedImage, top, sourceWidth - (left + width), getHeight(), width);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 编写解析二维码的实现代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">MultiFormatReader formatReader = new MultiFormatReader();</span><br><span class="line">String filePath = &quot;C:/Users/Administrator/Desktop/testImage/test.jpg&quot;;</span><br><span class="line">File file = new File(filePath);</span><br><span class="line">BufferedImage image = ImageIO.read(file);</span><br><span class="line">;</span><br><span class="line">LuminanceSource source = new BufferedImageLuminanceSource(image);</span><br><span class="line">Binarizer binarizer = new HybridBinarizer(source);</span><br><span class="line">BinaryBitmap binaryBitmap = new BinaryBitmap(binarizer);</span><br><span class="line">Map hints = new HashMap();</span><br><span class="line">hints.put(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);</span><br><span class="line">Result result = formatReader.decode(binaryBitmap, hints);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result = &quot; + result.toString());</span><br><span class="line">System.out.println(&quot;resultFormat = &quot; + result.getBarcodeFormat());</span><br><span class="line">System.out.println(&quot;resultText = &quot; + result.getText());</span><br><span class="line"></span><br><span class="line">&#125;catch(</span><br><span class="line">Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整個二維碼生成及解析流程就結束了，喜歡的點點讚。。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，&lt;br&gt;二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;1、二维码的生成&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
