<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭琪的博客</title>
  
  <subtitle>年轻只知学习营利，乃生命中最黯淡之时刻。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-30T01:13:39.222Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭 琪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过zxing生成二维码</title>
    <link href="http://yoursite.com/2018/05/30/%E9%80%9A%E8%BF%87zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2018/05/30/通过zxing生成二维码/</id>
    <published>2018-05-29T17:16:28.784Z</published>
    <updated>2018-05-30T01:13:39.222Z</updated>
    
    <content type="html"><![CDATA[<p>​       二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，<br>二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。<br>完整的 demo ,请查看我的 github</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.guoqick.zxing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">createQRCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">300</span>;</span><br><span class="line">        String format = <span class="string">"png"</span>;</span><br><span class="line">        String content = <span class="string">"www.guoqick.cn"</span>;</span><br><span class="line">        <span class="comment">//定义二维码的参数</span></span><br><span class="line">        HashMap hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);</span><br><span class="line">        hints.put(EncodeHintType.MARGIN, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">            Path file = <span class="keyword">new</span> File(<span class="string">"E:/code/img.png"</span>).toPath();</span><br><span class="line">            MatrixToImageWriter.writeToPath(bitMatrix,format,file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​       二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，&lt;br&gt;二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。&lt;br&gt;完整的 demo ,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BIO与NIO、AIO的区别</title>
    <link href="http://yoursite.com/2018/05/29/BIO%E4%B8%8ENIO%E3%80%81AIO%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/05/29/BIO与NIO、AIO的区别/</id>
    <published>2018-05-29T15:51:50.146Z</published>
    <updated>2018-05-29T16:35:04.297Z</updated>
    
    <content type="html"><![CDATA[<p>  IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。</p><h2 id="一、BIO"><a href="#一、BIO" class="headerlink" title="一、BIO"></a>一、BIO</h2><p>​     在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。</p><h2 id="二、NIO"><a href="#二、NIO" class="headerlink" title="二、NIO"></a>二、NIO</h2><p>​    NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。</p><p>​    NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>   BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。</p><p><img src="https://upload-images.jianshu.io/upload_images/12434140-6eb728b3786334ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO.png"></p><p>​      NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p><p>​      在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。</p><p>　　HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。</p><h2 id="三、AIO"><a href="#三、AIO" class="headerlink" title="三、AIO"></a>三、AIO</h2><p>​     与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：</p><ul><li>AsynchronousSocketChannel</li><li>AsynchronousServerSocketChannel</li><li>AsynchronousFileChannel</li><li>AsynchronousDatagramChannel</li></ul><p>其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。</p><p>BIO是一个连接一个线程。</p><p>NIO是一个请求一个线程。</p><p>AIO是一个有效请求一个线程。</p><p>先来个例子理解一下概念，以银行取款为例： </p><ul><li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；</li><li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；</li><li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</li><li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）</li></ul><p>Java对BIO、NIO、AIO的支持：</p><ul><li>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li><li>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li><li>Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</li></ul><p>BIO、NIO、AIO适用场景分析:</p><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><p>另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。</p><p>在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。</p><p>​    在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。</p><p> 一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO</p><p>同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</p><p>同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。</p><p>异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！</p><p> 异步非阻塞IO:在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。   </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。&lt;/p&gt;
&lt;h2 id=&quot;一、BIO&quot;&gt;&lt;a href=&quot;#一、BIO&quot; class=&quot;headerlink&quot; title=&quot;一、BIO&quot;&gt;&lt;/a&gt;一、BIO&lt;/h2&gt;&lt;p&gt;​     在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试重要知识点复习大纲</title>
    <link href="http://yoursite.com/2018/05/29/%E9%9D%A2%E8%AF%95%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://yoursite.com/2018/05/29/面试重要知识点复习大纲/</id>
    <published>2018-05-29T15:34:40.620Z</published>
    <updated>2018-05-30T01:22:41.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java基础部分"><a href="#一、Java基础部分" class="headerlink" title="一、Java基础部分"></a>一、Java基础部分</h2><p>​    1.数组中的排序问题(笔试或者机试，前者可能性更大)</p><p>​    2.面向对象的理解</p><p>​    3.集合相关的问题，比如hashmap跟hashtable的区别。搞清楚每个集合对象的特性就欧了。</p><p>​    4.多线程启动方式，以及产生死锁的原因和解决办法【多线程问题不是很常问，有精力就复习这块内容】</p><p>​    5.IO流，了解常见的几个流对象以及基本的流操作即可，被机试的可能性比较小。</p><h2 id="二、Web基础"><a href="#二、Web基础" class="headerlink" title="二、Web基础"></a>二、Web基础</h2><p>​    1.http协议(定义、常见的请求头以及响应头&lt;功能&gt;、状态码)</p><p>​    2.tomcat(目录结构&lt;存放的内容以及配置文件里面能做哪些工作&gt;、常见配置;有能力者可以了解一下tomcat的原理&lt;启动加载问题&gt;)</p><p>​    3.jdbc(编程步骤、与hibernate以及mybatis的区别)</p><p>​    4.servlet(概念的理解；生命周期、线程安全问题、接口相关类型、体系结构&lt;区别&gt;、request以及response的用途、servletContext对象的功能、编码以及路径问题)</p><p>​    5.filter(生命周期、常见应用、dofilter里面的参数、应用场景)</p><p>​    6.jsp(隐式对象、常见标签&lt;指令、动作&gt;、EL以及JSTL)</p><p>​    7.cookie/session(概念的理解；生命周期，session创建的时期，相关方法的使用)</p><h2 id="三、五大框架"><a href="#三、五大框架" class="headerlink" title="三、五大框架"></a>三、五大框架</h2><p>​    1.struts2(action相关的问题&lt;书写方式[区别]、接受请求参数的方式、相关配置、访问servletAPI的方式&gt;；值栈相 关问题&lt;定义、内部结构、如何获取值栈对象、EL为什么能访问值栈中的数据&gt;；struts2与springMVC的区别；拦截器与过滤器的 区别；struts2工作原理&lt;执行流程&gt;)</p><p>​    2.hibernate(核心思想要了解；开发流程&lt;加载文件的过程&gt;；查询方式；如何优化；sql与hql的区别；update与 saveOrUpdate的区别；get和load的区别；Java对象三种状态的特征以及转换、核心API、一级缓存和二级缓存、延迟加载)</p><p>​    3.spring(springIOC和DI；生命周期；Bean注入属性的方式；aop极其相关名词解释；核心类；applicationContext与beanFactory的区别；bean实例化有哪些方式)</p><p>   4.springMVC(工作流程；与struts2的区别；乱码问题如何处理；各组件的扩展类型)</p><p>​    5.mybatis(与jdbc/hibernate的区别；)</p><h2 id="四、脚本"><a href="#四、脚本" class="headerlink" title="四、脚本"></a>四、脚本</h2><p>​    1.JavaScript核心对象</p><p>​    2.浏览器BOM对象</p><p>​    3.文档对象模型DOM</p><p>​    4.常见事件</p><p>​    5.Ajax编程(web交互2种方式的对比)</p><p>​    6.传统Ajax编程的步骤以及从服务器端返回的数据格式(之间的差别)</p><p>​    7.JSON数据格式的转换操作</p><p>​    8.jQuery选择器</p><p>​    9.jQuery的Ajax编程(常见方法)</p><p>​    10.其余的问题都是一些笔试题，让你直接写javascript代码实现某一功能</p><h2 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h2><p>​    数据库这一块几乎都是一些概念性的问答题(存储过程、函数、事务、索引、触发器、视图、游标以及一些优化操作),笔试100%会出现，一般考察的都是多表联合查询</p><h2 id="六、人事相关"><a href="#六、人事相关" class="headerlink" title="六、人事相关"></a>六、人事相关</h2><p>​    1.自我介绍(注重的是你之前在公司里面工作内容，特别是最近在公司里面做的项目&lt;回答思路参考项目相关问题一&gt;)</p><p>​    2.简单的介绍一下上一家公司的情况/评价</p><p>​    3.你为什么来北京工作，怎样看待跳槽？</p><p>​    4.你对我们公司了解吗？</p><p>​    5.你如果有幸进入我们公司，有什么规划吗？</p><p>​    6.你上一家公司的薪资大概是多少？有哪些组成部分？</p><p>​    7.你有没有投其它公司？如果其它公司也给了offer，你会如何抉择？</p><p>​    8.你有对象吗？打算什么时候结婚生孩子？</p><p>​    9.你对薪资待遇有什么要求？能再低一点吗？</p><p>​    10.你还有什么问题要问我吗？</p><h2 id="七、项目相关"><a href="#七、项目相关" class="headerlink" title="七、项目相关"></a>七、项目相关</h2><p>​    1.请介绍一下你最近做的这一个项目吧【思路：项目给谁做的、项目涉及的领域、系统的架构(功能&amp;技术)、系统的用途、系统的部署、使用了哪些比较新颖的技术】</p><p>​    2.谈谈你对电商行业的了解【思路：电商行业的发展、行业技术特点、行业的一些概念】</p><p>​    3.你这个项目大概有哪些功能，你负责了哪些核心功能？【拥有的功能尽可能说多一点，建议10个左右，自己负责的3个大(如商品管理、订单、购物车)，其余的都是其他组员开发的任务】</p><p>​    4.谈谈xx(具体的，比如商品管理、订单、购物车)模块/功能的实现思路？实现的过程中涉及到了哪些技术，这些技术能介绍下吗？【可参考“02_电商项目面试问题”里面的答案】</p><p>​    5.你们公司有多少人？有测试吗？有美工吗？整个项目组人员配置是怎么样的？项目开发的流程大概是什么样子的？【检验是否有工作经验的一个问题】</p><p>​    6.这个项目使用了什么构建工具没有？有的话，多模块之间是如何划分的？为什么要这么划分？</p><p>​    7.在这个项目中是如何设计商品规格的？</p><p>​    8.这个系统中你是如何实现跨系统调用的？  </p><p>​    9.在这个项目中，CMS系统是如何设计的，简单的说一下设计思路</p><p>​    10.在这个项目中，你们主要使用什么样的数据格式来进行数据的传输的？</p><p>​    11.单点系统的设计思想你了解吗？他在系统架构中的作用是什么？位置如何？</p><p>​    12.你们这个项目中订单ID是怎么生成的？我们公司最近打算做一个电商项目，如果让你设计这块，你会考虑哪些问题？</p><p>​    13.各个服务器的时间不统一怎么办？</p><p>​    14.你们线上部署时什么样的，能画一下吗？<br>    15.你们生产环境的服务器有多少台？    </p><p>   16.你们使用什么做支付的？如果使用易宝做支付，请求超时了怎么处理？    </p><p>   17.你刚才不是说付款成功后易宝会有数据返回吗？如果付款后易宝没有返回，或者返回超时了，但是钱又已经扣了，你怎么办？<br>    18.你们怎么做退款功能的，要多长时间才能把钱退回给用户？<br>    19.你购物车存cookie里边可以实现不登录就可以使用购物车，那么我现在没有登录把商品存购物车了，然后登录了， 然后我换台电脑并且登录了还能不能看见我购物车的信息？如果看不到怎么做到cookie同步，就是在另外一台电脑上可以看到购物车信息<br>    20.如果用户一直向购物车添加商品怎么办？并且他添加一次你查询一次数据库？互联网上用户那么多，这样会对数据库造成很大压力你怎么办？</p><p>   21.购物车的设计细节问题</p><h2 id="八、其他技术问题"><a href="#八、其他技术问题" class="headerlink" title="八、其他技术问题"></a>八、其他技术问题</h2><p>   1.权限控制(一般情况，在公司必须有一定工作经验的开发者才会被分配该功能模块的开发，这意味着学员在刚开始参加工作的那个项目里面绝对不能写的内容。) 这里一般都会提及shiro技术，在这块需要掌握shiro相关的几个组件以及他们的调用关系，然后就是权限设计的几张数据库表(表之间的关系以及每张表里面的重要字段)</p><p>   2.搜索系统(普通的查询会让面试官问及效率问题，那么势必要提到全文检索技术，由于刚学不是很熟，根据自己掌握的情况进行选择)   </p><p>​    3.浏览器跨域问题(前台系统调用可以使用jsonp来实现浏览器跨域问题，去年有学员花几个小时学习这个，仅凭此技术入职8K。)</p><p>​    4.webservice(该技术已有替代技术，如果不会，可以不用花时间去复习)</p><p>​    5.Linux(水太深，只谈自己在项目中就部署的时候用了一下即可)</p><p>​    6.redis(根据自己的能力看是否需要提及次技术，毕竟购物车的实现方式比较多。)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Java基础部分&quot;&gt;&lt;a href=&quot;#一、Java基础部分&quot; class=&quot;headerlink&quot; title=&quot;一、Java基础部分&quot;&gt;&lt;/a&gt;一、Java基础部分&lt;/h2&gt;&lt;p&gt;​    1.数组中的排序问题(笔试或者机试，前者可能性更大)&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java程序员面试99问</title>
    <link href="http://yoursite.com/2018/05/15/java%E9%9D%A2%E8%AF%9599%E9%97%AE/"/>
    <id>http://yoursite.com/2018/05/15/java面试99问/</id>
    <published>2018-05-15T09:25:37.780Z</published>
    <updated>2018-05-30T01:22:11.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h5 id="String-StringBuffer-与-StringBuilder的区别"><a href="#String-StringBuffer-与-StringBuilder的区别" class="headerlink" title="String , StringBuffer 与 StringBuilder的区别"></a><strong>String , StringBuffer 与 StringBuilder的区别</strong></h5><p>这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。</p><p><strong>面试管：</strong>String , StringBuffer 与 StringBuilder之间有什么区别吗？</p><p><strong>你的回答：</strong></p><p>对于字符串拼接：</p><p><strong>性能方面：</strong>StringBuilder &gt; StringBuffer &gt; String（+）（for循环里面字符串拼接）</p><p><strong>线程安全：</strong>StringBuilder （非线程安全，速度快），StringBuffer （线程安全，速度慢）</p><p><strong>如何选择：</strong>StringBuilder （方法内，无线程安全问题），StringBuffer （有线程安全问题，使用它）</p><p>3点建议：（加分项）</p><ul><li>当你连接 2 或 3 个String时，使用String.concat()。</li><li>如果你要连接多于3个String（不含3）,并且你能够精确预测出最终结果的长度，使用StringBuilder/StringBuffer，并设定初始化容量。</li><li>如果你要连接多于3个String（不含3）,并且你不能够精确预测出最终结果的长度，使用StringBundler。</li></ul><p>【1】<a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="noopener">http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html</a></p><p>面试官继续问题：</p><p>StringBuffer 为什么是线程安全的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//StringBuffer源码</span><br><span class="line">/**</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public synchronized void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)&#123;</span><br><span class="line">    super.getChars(srcBegin, srcEnd, dst, dstBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官可能还会继续问：</p><p>为什么加 synchronized 这个关键字，就是线程安全的呢？</p><h5 id="Vector，ArrayList，LinkedList的区别"><a href="#Vector，ArrayList，LinkedList的区别" class="headerlink" title="Vector，ArrayList，LinkedList的区别"></a><strong>Vector，ArrayList，LinkedList的区别</strong></h5><p>一、同步性 </p><p>ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。 </p><p>二、数据增长<br>从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 </p><p>三、检索、插入、删除对象的效率 </p><p>ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。<br>LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。 </p><p>一般大家都知道ArrayList和LinkedList的大致区别：<br>​     1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>​     2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>​     3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 </p><h5 id="List如何去除重复数据"><a href="#List如何去除重复数据" class="headerlink" title="List如何去除重复数据"></a><strong>List如何去除重复数据</strong></h5><p>【1】<a href="http://www.2cto.com/kf/201708/664237.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201708/664237.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AAAA AAAA BBBB BBBB CCCC CCCC CCCC CCCC</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;DDDD&quot;);</span><br><span class="line">         new Test().removeDuplicateWithOrder(list);</span><br><span class="line">//      System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 删除ArrayList中重复元素</span><br><span class="line">public static void removeDuplicate(List list) &#123;</span><br><span class="line">    for (int i = 0; i &lt; list.size() - 1; i++) &#123;</span><br><span class="line">        for (int j = list.size() - 1; j &gt; i; j--) &#123;</span><br><span class="line">               if (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">                  list.remove(j);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法二：通过HashSet剔除</span><br><span class="line">      // 删除ArrayList中重复元素,add进去顺序就变了不考虑顺序的话可以使用</span><br><span class="line">public static void removeDuplicate1(List list) &#123;</span><br><span class="line">         HashSet h = new HashSet(list);</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(h);</span><br><span class="line">         System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法三： 删除ArrayList中重复元素，保持顺序</span><br><span class="line">      // 删除ArrayList中重复元素，保持顺序</span><br><span class="line">public static void removeDuplicateWithOrder(List list) &#123;</span><br><span class="line">         Set set = new HashSet();</span><br><span class="line">         List newList = new ArrayList();</span><br><span class="line">         for (Iterator iter = list.iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Object element = iter.next();</span><br><span class="line">            if (set.add(element))</span><br><span class="line">               newList.add(element);</span><br><span class="line">         &#125;</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(newList);</span><br><span class="line">         System.out.println(&quot; remove duplicate &quot; + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自己手动实现一个线程池"><a href="#自己手动实现一个线程池" class="headerlink" title="自己手动实现一个线程池"></a><strong>自己手动实现一个线程池</strong></h5><p>【1】<a href="http://blog.csdn.net/w2393040183/article/details/52177572" target="_blank" rel="noopener">http://blog.csdn.net/w2393040183/article/details/52177572</a></p><h5 id="Java字节流和字符流的区别"><a href="#Java字节流和字符流的区别" class="headerlink" title="Java字节流和字符流的区别"></a><strong>Java字节流和字符流的区别</strong></h5><p>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</p><ul><li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li><li>字节流默认不使用缓冲区；字符流使用缓冲区。</li><li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li></ul><p>所以对于字节流和字符流的选择，我们建议：在开发中尽量都去使用字节流进行操作，因为字节流可以处理图片、音乐、文字，也可以方便进行传输或者文字的编码转换；如果在处理中文的使用考虑字符流。</p><p>【1】<a href="http://bbs.itheima.com/thread-277923-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-277923-1-1.html</a></p><h5 id="多线程实现生产者-消费者模式"><a href="#多线程实现生产者-消费者模式" class="headerlink" title="多线程实现生产者/消费者模式"></a><strong>多线程实现生产者/消费者模式</strong></h5><h5 id="在Java中什么是线程调度？"><a href="#在Java中什么是线程调度？" class="headerlink" title="在Java中什么是线程调度？"></a><strong>在Java中什么是线程调度？</strong></h5><h5 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a><strong>线程与进程的区别？</strong></h5><p><a href="http://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="noopener">http://blog.csdn.net/yaosiming2011/article/details/44280797</a></p><p><strong>死锁与活锁区别，死锁与饥饿的区别？</strong></p><p><a href="http://www.cnblogs.com/lance43990740/p/6853631.html" target="_blank" rel="noopener">http://www.cnblogs.com/lance43990740/p/6853631.html</a></p><h5 id="在线程中你怎么处理不可捕捉异常"><a href="#在线程中你怎么处理不可捕捉异常" class="headerlink" title="在线程中你怎么处理不可捕捉异常"></a><strong>在线程中你怎么处理不可捕捉异常</strong></h5><p>【1】<a href="http://blog.csdn.net/Dxx23/article/details/44775735" target="_blank" rel="noopener">http://blog.csdn.net/Dxx23/article/details/44775735</a></p><p><strong>多线程上下文切换</strong></p><p>【1】<a href="http://www.cnblogs.com/szlbm/p/5505707.html" target="_blank" rel="noopener">http://www.cnblogs.com/szlbm/p/5505707.html</a></p><h5 id="HashTable，HashMap，TreeMap的区别"><a href="#HashTable，HashMap，TreeMap的区别" class="headerlink" title="HashTable，HashMap，TreeMap的区别"></a><strong>HashTable，HashMap，TreeMap的区别</strong></h5><p>【1】<a href="http://blog.csdn.net/natian306/article/details/10858097" target="_blank" rel="noopener">http://blog.csdn.net/natian306/article/details/10858097</a></p><p>【2】<a href="http://www.cnblogs.com/tengpan-cn/p/5909395.html" target="_blank" rel="noopener">http://www.cnblogs.com/tengpan-cn/p/5909395.html</a></p><h5 id="IO-BIO-NIO-AIO编程模型"><a href="#IO-BIO-NIO-AIO编程模型" class="headerlink" title="IO,BIO,NIO,AIO编程模型"></a>IO,BIO,NIO,AIO编程模型</h5><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a><br>【2】<a href="http://blog.csdn.net/jiaomingliang/article/details/47684713" target="_blank" rel="noopener">http://blog.csdn.net/jiaomingliang/article/details/47684713</a></p><p>如果你想吃一份宫保鸡丁盖饭： </p><p>同步阻塞：你到饭馆点餐，然后在那<br>等着，还要一边喊：好了没啊！ </p><p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><h5 id="TreeMap实现原理"><a href="#TreeMap实现原理" class="headerlink" title="TreeMap实现原理"></a><strong>TreeMap实现原理</strong></h5><p><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/26668941</a></p><h5 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a><strong>HashMap实现原理</strong></h5><p><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">http://blog.csdn.net/vking_wang/article/details/14166593</a></p><h5 id="如何判断一棵树-tree-是对称的"><a href="#如何判断一棵树-tree-是对称的" class="headerlink" title="如何判断一棵树(tree)是对称的"></a><strong>如何判断一棵树(tree)是对称的</strong></h5><p>【1】<a href="http://blog.csdn.net/yangmm2048/article/details/45689561" target="_blank" rel="noopener">http://blog.csdn.net/yangmm2048/article/details/45689561</a></p><h5 id="如何生成全球唯一的编码"><a href="#如何生成全球唯一的编码" class="headerlink" title="如何生成全球唯一的编码"></a><strong>如何生成全球唯一的编码</strong></h5><h5 id="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"><a href="#关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。" class="headerlink" title="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"></a>关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</h5><h5 id="map实现按照key字典排序，并且按照顺序打印key-和-value"><a href="#map实现按照key字典排序，并且按照顺序打印key-和-value" class="headerlink" title="map实现按照key字典排序，并且按照顺序打印key 和 value?"></a><strong>map实现按照key字典排序，并且按照顺序打印key 和 value?</strong></h5><p>【1】<a href="http://blog.csdn.net/bwgang/article/details/7879563" target="_blank" rel="noopener">http://blog.csdn.net/bwgang/article/details/7879563</a></p><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h5><h5 id="syschronized实现原理"><a href="#syschronized实现原理" class="headerlink" title="syschronized实现原理"></a><strong>syschronized实现原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p><h5 id="syschronized与重入锁ReenTrantLock的区别"><a href="#syschronized与重入锁ReenTrantLock的区别" class="headerlink" title="syschronized与重入锁ReenTrantLock的区别"></a><strong>syschronized与重入锁ReenTrantLock的区别</strong></h5><p>可重入性：<br>从名字上理解，ReenTrantLock的字面意思就是再进入<br>的锁，其实synchronized关键字所使用的锁也是可重<br>入的，两者关于这个的区别不大。两者都是同<br>一个线程每次进入一次，锁的计数器都自增1，<br>所以要等到锁的计数器下降为0时才能释放锁。<br>三.synchronized和ReentrantLock的区别<br>除了synchronized的功能,多了三个高级功能.<br>等待可中断,公平锁,绑定多个Condition.</p><ul><li>1.等待可中断<br>在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.   tryLock(long timeout, TimeUnit unit)</li><li>2.公平锁按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.    new RenentrantLock(boolean fair)</li><li>3.绑定多个Condition<br>通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();</li></ul><h5 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><strong>Java多线程</strong></h5><ul><li><p>wait（），notify（）和notifyAll（）</p><p>​</p></li></ul><h5 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a><strong>抽象类与接口的区别</strong></h5><p>【1】<a href="http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html" target="_blank" rel="noopener">http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html</a></p><h5 id="equals-hashcode"><a href="#equals-hashcode" class="headerlink" title="equals hashcode "></a><strong>equals hashcode </strong></h5><p>【1】<a href="http://blog.csdn.net/ftx2540993425/article/details/51206130" target="_blank" rel="noopener">http://blog.csdn.net/ftx2540993425/article/details/51206130</a><br>【2】<a href="http://www.cnblogs.com/Qian123/p/5703507.html" target="_blank" rel="noopener">http://www.cnblogs.com/Qian123/p/5703507.html</a></p><h5 id="lambda优点"><a href="#lambda优点" class="headerlink" title="lambda优点"></a><strong>lambda优点</strong></h5><p>【1】<a href="http://developer.51cto.com/art/201304/387681.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201304/387681.htm</a></p><h5 id="关键字transient"><a href="#关键字transient" class="headerlink" title="关键字transient"></a><strong>关键字transient</strong></h5><p>【1】<a href="http://blog.csdn.net/d12345678a/article/details/54178659" target="_blank" rel="noopener">http://blog.csdn.net/d12345678a/article/details/54178659</a></p><h5 id="JDK和JRE的区别是什么"><a href="#JDK和JRE的区别是什么" class="headerlink" title="JDK和JRE的区别是什么"></a><strong>JDK和JRE的区别是什么</strong></h5><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程 序。</p><p>JDK中包含JRE，JRE中包含JVM。</p><p>JDK中包含的JRE主要是为JDK自带的开发工具提供运行环境，与JDK并列的那个JRE是为用户编写的JAVA代码提供运行环境的。</p><p>classpath配置的是JDK的lib目录，path配置的是JDK的bin目录。</p><h5 id="Java到底是不是一种纯面向对象语言？"><a href="#Java到底是不是一种纯面向对象语言？" class="headerlink" title="Java到底是不是一种纯面向对象语言？"></a><strong>Java到底是不是一种纯面向对象语言？</strong></h5><p>【1】<a href="https://news.cnblogs.com/n/548327/" target="_blank" rel="noopener">https://news.cnblogs.com/n/548327/</a></p><h5 id="HTTP请求的header头解析"><a href="#HTTP请求的header头解析" class="headerlink" title="HTTP请求的header头解析"></a><strong>HTTP请求的header头解析</strong></h5><p><a href="http://blog.csdn.net/hufan11100914/article/details/48029633" target="_blank" rel="noopener">http://blog.csdn.net/hufan11100914/article/details/48029633</a></p><h5 id="如何判断一个对象已经被回收"><a href="#如何判断一个对象已经被回收" class="headerlink" title="如何判断一个对象已经被回收"></a><strong>如何判断一个对象已经被回收</strong></h5><p>【1】<a href="http://blog.csdn.net/canot/article/details/51037938" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51037938</a></p><h5 id="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗"><a href="#假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗" class="headerlink" title="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)"></a><strong>假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)</strong></h5><h5 id="有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…"><a href="#有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…" class="headerlink" title="有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…"></a><strong>有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…</strong></h5><h5 id="两个有序数组合并为一个有序数组"><a href="#两个有序数组合并为一个有序数组" class="headerlink" title="两个有序数组合并为一个有序数组"></a><strong>两个有序数组合并为一个有序数组</strong></h5><p>【1】<a href="http://www.cnblogs.com/A_ming/archive/2010/04/15/1712313.html" target="_blank" rel="noopener">http://www.cnblogs.com/A_ming/archive/2010/04/15/1712313.html</a></p><h5 id="JAVA值类型和引用类型的区别"><a href="#JAVA值类型和引用类型的区别" class="headerlink" title="JAVA值类型和引用类型的区别"></a><strong>JAVA值类型和引用类型的区别</strong></h5><p>【1】<a href="http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html" target="_blank" rel="noopener">http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html</a></p><h5 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a><strong>基本类型转换</strong></h5><p>【1】<a href="http://blog.csdn.net/u011583105/article/details/16349095" target="_blank" rel="noopener">http://blog.csdn.net/u011583105/article/details/16349095</a></p><h5 id="递归算法笔试题"><a href="#递归算法笔试题" class="headerlink" title="递归算法笔试题"></a><strong>递归算法笔试题</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> * 一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少， 用递归算法实现。</span><br><span class="line"> **/</span><br><span class="line">static int find30(int n)&#123;</span><br><span class="line">        if (n &lt;= 0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(n &gt; 0 &amp;&amp; n &lt;= 2)</span><br><span class="line">            return 1;</span><br><span class="line">        return find30(n-1)+find30(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内存泄漏和内存溢出区别"><a href="#内存泄漏和内存溢出区别" class="headerlink" title="内存泄漏和内存溢出区别"></a><strong>内存泄漏和内存溢出区别</strong></h5><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。</p><p>【1】<a href="http://blog.csdn.net/buutterfly/article/details/6617375" target="_blank" rel="noopener">http://blog.csdn.net/buutterfly/article/details/6617375</a></p><h5 id="内存溢出和内存泄漏的原因"><a href="#内存溢出和内存泄漏的原因" class="headerlink" title="内存溢出和内存泄漏的原因"></a><strong>内存溢出和内存泄漏的原因</strong></h5><p>【1】<a href="http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html" target="_blank" rel="noopener">http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html</a></p><p>【2】<a href="http://blog.csdn.net/anxpp/article/details/51325838" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51325838</a></p><p>【3】<a href="http://blog.csdn.net/shanyu1198124123/article/details/52414392" target="_blank" rel="noopener">http://blog.csdn.net/shanyu1198124123/article/details/52414392</a></p><h5 id="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"><a href="#子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次" class="headerlink" title="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"></a>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次</h5><p>【1】<a href="http://www.cnblogs.com/ysloong/p/6370104.html" target="_blank" rel="noopener">http://www.cnblogs.com/ysloong/p/6370104.html</a></p><h5 id="condition的作用"><a href="#condition的作用" class="headerlink" title="condition的作用"></a><strong>condition的作用</strong></h5><p>【1】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p><h5 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"></a><strong>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</strong></h5><h5 id="Java多线程中join方法的理解"><a href="#Java多线程中join方法的理解" class="headerlink" title="Java多线程中join方法的理解"></a>Java多线程中join方法的理解</h5><p>【1】<a href="http://uule.iteye.com/blog/1101994" target="_blank" rel="noopener">http://uule.iteye.com/blog/1101994</a></p><h5 id="equals-与-hashcode"><a href="#equals-与-hashcode" class="headerlink" title="equals() 与 hashcode()"></a><strong>equals() 与 hashcode()</strong></h5><h5 id="Lock接口比synchronized块的优势是什么"><a href="#Lock接口比synchronized块的优势是什么" class="headerlink" title="Lock接口比synchronized块的优势是什么"></a><strong>Lock接口比synchronized块的优势是什么</strong></h5><h5 id="java中wait和sleep方法的不同"><a href="#java中wait和sleep方法的不同" class="headerlink" title="java中wait和sleep方法的不同"></a><strong>java中wait和sleep方法的不同</strong></h5><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><p>【1】<a href="http://blog.csdn.net/clam_clam/article/details/6803667" target="_blank" rel="noopener">http://blog.csdn.net/clam_clam/article/details/6803667</a></p><p><strong>用Java实现阻塞队列</strong></p><p>【1】<a href="http://blog.csdn.net/chenchaofuck1/article/details/51660119" target="_blank" rel="noopener">http://blog.csdn.net/chenchaofuck1/article/details/51660119</a></p><p>【2】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p><p><strong>java中volatile关键字理解</strong></p><p>【1】<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p><p>【2】<a href="http://www.infoq.com/cn/articles/java-memory-model-4/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-memory-model-4/</a></p><p>区别：</p><p>  一、volatile是变量修饰符，而synchronized则作用于一段代码或方法。</p><p> 二、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源</p><h5 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a><strong>什么是竞争条件？你怎样发现和解决竞争？</strong></h5><p>【1】<a href="http://blog.csdn.net/hourui93/article/details/48596259" target="_blank" rel="noopener">http://blog.csdn.net/hourui93/article/details/48596259</a></p><h5 id="你将如何使用thread-dump？你将如何分析Thread-dump"><a href="#你将如何使用thread-dump？你将如何分析Thread-dump" class="headerlink" title="你将如何使用thread dump？你将如何分析Thread dump"></a><strong>你将如何使用thread dump？你将如何分析Thread dump</strong></h5><p>【1】<a href="http://blog.csdn.net/rachel_luo/article/details/8920596" target="_blank" rel="noopener">http://blog.csdn.net/rachel_luo/article/details/8920596</a></p><h5 id="在Java中CycliBarriar和CountdownLatch有什么区别"><a href="#在Java中CycliBarriar和CountdownLatch有什么区别" class="headerlink" title="在Java中CycliBarriar和CountdownLatch有什么区别"></a><strong>在Java中CycliBarriar和CountdownLatch有什么区别</strong></h5><p>【1】<a href="http://blog.csdn.net/kjfcpua/article/details/7300286" target="_blank" rel="noopener">http://blog.csdn.net/kjfcpua/article/details/7300286</a></p><h5 id="Java并发编程-Executor框架集"><a href="#Java并发编程-Executor框架集" class="headerlink" title="Java并发编程-Executor框架集"></a><strong>Java并发编程-Executor框架集</strong></h5><p>【1】<a href="http://www.cnblogs.com/MOBIN/p/5436482.html" target="_blank" rel="noopener">http://www.cnblogs.com/MOBIN/p/5436482.html</a></p><h5 id="对象的四种引用类型"><a href="#对象的四种引用类型" class="headerlink" title="对象的四种引用类型"></a><strong>对象的四种引用类型</strong></h5><p>【1】<a href="http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html</a></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h3><p>【1】<a href="http://www.importnew.com/15851.html#ioc_di" target="_blank" rel="noopener">http://www.importnew.com/15851.html#ioc_di</a></p><p><strong>Spring好在哪里</strong></p><p> 轻量：Spring 是轻量的，基本的版本大约2MB。<br> 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br> 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br> 容器：Spring 包含并管理应用中对象的生命周期和配置。<br> MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br> 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br> 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p><h5 id="spring-实现日志管理"><a href="#spring-实现日志管理" class="headerlink" title="spring 实现日志管理"></a><strong>spring 实现日志管理</strong></h5><h5 id="Spring框架有哪些主要模块"><a href="#Spring框架有哪些主要模块" class="headerlink" title="Spring框架有哪些主要模块**"></a>Spring框架有哪些主要模块**</h5><h5 id="控制反转-IOC-？什么是依赖注入（DI）"><a href="#控制反转-IOC-？什么是依赖注入（DI）" class="headerlink" title="控制反转(IOC)？什么是依赖注入（DI）?"></a><strong>控制反转(IOC)？什么是依赖注入（DI）?</strong></h5><h5 id="IOC-DI-原理"><a href="#IOC-DI-原理" class="headerlink" title="IOC(DI)原理"></a><strong>IOC(DI)原理</strong></h5><h5 id="依然注入三种实现方式"><a href="#依然注入三种实现方式" class="headerlink" title="依然注入三种实现方式"></a><strong>依然注入三种实现方式</strong></h5><h5 id="Spring-Bean作用域之间的区别"><a href="#Spring-Bean作用域之间的区别" class="headerlink" title="Spring Bean作用域之间的区别"></a><strong>Spring Bean作用域之间的区别</strong></h5><h5 id="Spring有几种配置方式"><a href="#Spring有几种配置方式" class="headerlink" title="Spring有几种配置方式"></a><strong>Spring有几种配置方式</strong></h5><ul><li>基于XML的配置</li><li>基于注解的配置</li><li>基于Java的配置</li></ul><h5 id="请解释Spring-Bean的生命周期"><a href="#请解释Spring-Bean的生命周期" class="headerlink" title="请解释Spring Bean的生命周期"></a><strong>请解释Spring Bean的生命周期</strong></h5><h5 id="自动装配模式的区别"><a href="#自动装配模式的区别" class="headerlink" title="自动装配模式的区别"></a><strong>自动装配模式的区别</strong></h5><h5 id="如何开启基于注解的自动装配"><a href="#如何开启基于注解的自动装配" class="headerlink" title="如何开启基于注解的自动装配"></a><strong>如何开启基于注解的自动装配</strong></h5><h5 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a><strong>Spring框架中有哪些不同类型的事件</strong></h5><h5 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a><strong>BeanFactory和ApplicationContext有什么区别</strong></h5><h5 id="三种较常见的-ApplicationContext-实现方式"><a href="#三种较常见的-ApplicationContext-实现方式" class="headerlink" title="三种较常见的 ApplicationContext 实现方式"></a><strong>三种较常见的 ApplicationContext 实现方式</strong></h5><ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li><li>XmlWebApplicationContext</li></ul><h5 id="如何用基于Java配置的方式配置Spring"><a href="#如何用基于Java配置的方式配置Spring" class="headerlink" title="如何用基于Java配置的方式配置Spring"></a><strong>如何用基于Java配置的方式配置Spring</strong></h5><p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。</p><h5 id="Spring中注入一个Java-Collection"><a href="#Spring中注入一个Java-Collection" class="headerlink" title="Spring中注入一个Java Collection"></a><strong>Spring中注入一个Java Collection</strong></h5><p><list> :   该标签用来装配可重复的list值。</list></p><p><set> :    该标签用来装配没有重复的set值。</set></p><p><map>:   该标签可用来注入键和值可以为任何类型的键值对。</map></p><p><props> : 该标签支持注入键和值都是字符串类型的键值对。</props></p><h5 id="FileSystemResource和ClassPathResource有何区别"><a href="#FileSystemResource和ClassPathResource有何区别" class="headerlink" title="FileSystemResource和ClassPathResource有何区别"></a><strong>FileSystemResource和ClassPathResource有何区别</strong></h5><h5 id="Spring-框架中都用到了哪些设计模式"><a href="#Spring-框架中都用到了哪些设计模式" class="headerlink" title="Spring 框架中都用到了哪些设计模式"></a><strong>Spring 框架中都用到了哪些设计模式</strong></h5><ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例。</li></ul><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h3><h3 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a><strong>Struts</strong></h3><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h3><p><strong>Post，Get区别</strong></p><p>Session, Cookie区别</p><p>Servlet的生命周期</p><p>HTTP 报文包含内容<br>简述三次握手和四次挥手</p><p>TCP是TCP/IP的第三层传输层，对应OSI的第四层传输层；<br>IP是TCP/IP的第二层互联层，对应OSI的第三层网络层。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><h5 id="postgresql数据库比mysql好在哪里？"><a href="#postgresql数据库比mysql好在哪里？" class="headerlink" title="postgresql数据库比mysql好在哪里？"></a><strong>postgresql数据库比mysql好在哪里？</strong></h5><p>【1】<a href="http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html</a></p><h5 id="数据库的左连接，右连接，内连接，外连接"><a href="#数据库的左连接，右连接，内连接，外连接" class="headerlink" title="数据库的左连接，右连接，内连接，外连接"></a><strong>数据库的左连接，右连接，内连接，外连接</strong></h5><p>【1】<a href="http://blog.csdn.net/zj972535075/article/details/50364813" target="_blank" rel="noopener">http://blog.csdn.net/zj972535075/article/details/50364813</a></p><h5 id="数据库四个范式"><a href="#数据库四个范式" class="headerlink" title="数据库四个范式"></a><strong>数据库四个范式</strong></h5><p>【1】<a href="http://blog.csdn.net/famousdt/article/details/6921622" target="_blank" rel="noopener">http://blog.csdn.net/famousdt/article/details/6921622</a><br>【2】<a href="http://www.jb51.net/article/19312.htm" target="_blank" rel="noopener">http://www.jb51.net/article/19312.htm</a></p><h5 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a><strong>数据库事务隔离级别</strong></h5><p>四个事务隔离级别概念和脏读、不可重复读、幻读这几类问题的概念。</p><ul><li>Read uncommitted</li><li>Read committed</li><li>Repeatable read</li><li>Serializable<br>这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li></ul><p>【1】<a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">http://blog.csdn.net/fg2006/article/details/6937413</a></p><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><strong>乐观锁和悲观锁</strong></h5><p>乐观锁和悲观锁的概念，乐观锁实现：第一种是使用版本号（hibernate乐观锁），第二种是使用时间戳。</p><p>【１】<a href="http://www.cnblogs.com/wang-meng/p/5506943.html" target="_blank" rel="noopener">http://www.cnblogs.com/wang-meng/p/5506943.html</a></p><h5 id="排他锁、共享锁"><a href="#排他锁、共享锁" class="headerlink" title="排他锁、共享锁"></a><strong>排他锁、共享锁</strong></h5><p>排他锁概念：<br><strong>注意：</strong>排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。</p><p>共享锁概念：<br><strong>注意：</strong>一个事务获取了共享锁，在其他查询中也只能加共享锁或不加锁。</p><p><strong>注意：</strong>排他锁与共享锁不能存在同一数据上。</p><p>【1】<a href="http://blog.csdn.net/c466254931/article/details/53463596" target="_blank" rel="noopener">http://blog.csdn.net/c466254931/article/details/53463596</a></p><h5 id="数据库索引类型及实现方式"><a href="#数据库索引类型及实现方式" class="headerlink" title="数据库索引类型及实现方式"></a><strong>数据库索引类型及实现方式</strong></h5><p><strong>索引的优缺点:</strong></p><p>唯一索引：   UNIQUE<br>主键索引：   primary key<br>聚集索引（也叫聚簇索引）：cluster <strong>概念</strong>等等</p><p>【1】<a href="http://www.cnblogs.com/barrywxx/p/4351901.html" target="_blank" rel="noopener">http://www.cnblogs.com/barrywxx/p/4351901.html</a><br>【2】<a href="http://www.cnblogs.com/terryglp/articles/2450197.html" target="_blank" rel="noopener">http://www.cnblogs.com/terryglp/articles/2450197.html</a></p><p> <strong>SQL联合索引 与 单一列的索引区别:</strong></p><p>【1】<a href="http://blog.csdn.net/shellching/article/details/7655793" target="_blank" rel="noopener">http://blog.csdn.net/shellching/article/details/7655793</a></p><p><strong>索引的实现方式：</strong></p><ul><li>B+树</li><li>散列索引</li><li>位图索引：位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，<strong>只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势</strong>。</li></ul><h5 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h5><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a><strong>执行计划</strong></h5><p>explain语句</p><p>【1】<a href="http://toplchx.iteye.com/blog/2091860" target="_blank" rel="noopener">http://toplchx.iteye.com/blog/2091860</a></p><h5 id="事务4大特性"><a href="#事务4大特性" class="headerlink" title="事务4大特性"></a><strong>事务4大特性</strong></h5><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)    </li><li>分离性(亦称独立性Isolation)</li><li>持久性(Durability)</li></ul><p>原子性(Atomicity)：要么全部执行，要么完全不执行</p><p>一致性(Consistency) 实例：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>【1】<a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">http://www.cnblogs.com/fjdingsd/p/5273008.html</a></p><h5 id="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"><a href="#在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？" class="headerlink" title="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"></a><strong>在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？</strong></h5><ul><li>办法一，建立分区表，按照用户浏览的记录数进行分区。</li><li>办法二，单独建立一张表，存放这样的信息。这张表就两个列，用户id和浏览量，这种思想叫冗余表。但是需要注意的是冗余表的建立，可以大幅提供效率，但会增加数据库维护的成本，需要综合考虑是否合适。</li><li>办法三，使用mongodb这样的nosql数据库。mongodb是一个文档型的nosql数据库，创建表的时候，增加两个列，一个保存浏览量，一个保存具体的浏览记录。这种方式跟冗余表的思想是一样的</li></ul><p>【1】<a href="http://blog.csdn.net/lgb934/article/details/8662956" target="_blank" rel="noopener">http://blog.csdn.net/lgb934/article/details/8662956</a></p><h5 id="关于数据库where和having的区别，执行顺序、group-by-与having如何使用。"><a href="#关于数据库where和having的区别，执行顺序、group-by-与having如何使用。" class="headerlink" title="关于数据库where和having的区别，执行顺序、group by 与having如何使用。"></a><strong>关于数据库where和having的区别，执行顺序、group by 与having如何使用。</strong></h5><p><a href="http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118" target="_blank" rel="noopener">http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118</a></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><h5 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a><strong>分布式锁的实现</strong></h5><p>【1】<a href="https://my.oschina.net/u/1995545/blog/366381" target="_blank" rel="noopener">https://my.oschina.net/u/1995545/blog/366381</a></p><h5 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a><strong>5种数据类型</strong></h5><ul><li>全局key操作</li><li>String（字符串）</li><li>Hashes类型:(map)</li><li>List类型</li><li>set类型</li><li>Sorted-Sets类型</li></ul><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51354188" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51354188</a></p><h5 id="两种持久化方式及原理"><a href="#两种持久化方式及原理" class="headerlink" title="两种持久化方式及原理"></a><strong>两种持久化方式及原理</strong></h5><p><strong>Redis的持久化策略：</strong><br>rdb:快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略<br>aof：把所有的对redis的服务器进行修改的命令都存到一个文件里，命令的集合</p><p>【1】<a href="http://blog.csdn.net/u010785685/article/details/52366977" target="_blank" rel="noopener">http://blog.csdn.net/u010785685/article/details/52366977</a></p><h5 id="与Memcache区别"><a href="#与Memcache区别" class="headerlink" title="与Memcache区别"></a><strong>与Memcache区别</strong></h5><p>redis和memecache的不同在于：</p><ul><li>存储方式：<br>  memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小<br>  redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。</li><li>数据支持类型：<br>  redis在数据支持上要比memecache多的多。</li><li>使用底层模型不同：<br>  新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>运行环境不同：<br>  redis目前官方只支持Linux 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上</li></ul><p>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；  </p><p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；  </p><p>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；  </p><p>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；  </p><p>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；  </p><p>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；  </p><p>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；  </p><p>Redis支持数据的备份，即master-slave模式的数据备份；  </p><p>应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。 </p><p>【1】<a href="http://blog.csdn.net/sunmenggmail/article/details/36176029" target="_blank" rel="noopener">http://blog.csdn.net/sunmenggmail/article/details/36176029</a></p><h5 id="redis是多线程还是单线程"><a href="#redis是多线程还是单线程" class="headerlink" title="redis是多线程还是单线程"></a>redis是多线程还是单线程</h5><p>【1】<a href="http://www.cnblogs.com/syyong/p/6231326.html" target="_blank" rel="noopener">http://www.cnblogs.com/syyong/p/6231326.html</a></p><h5 id="订阅-发布"><a href="#订阅-发布" class="headerlink" title="订阅/发布"></a><strong>订阅/发布</strong></h5><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51376197" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51376197</a></p><h5 id="分布式（主从模式）"><a href="#分布式（主从模式）" class="headerlink" title="分布式（主从模式）"></a><strong>分布式（主从模式）</strong></h5><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h5><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><h5 id="门面模式的解释，适用场合"><a href="#门面模式的解释，适用场合" class="headerlink" title="门面模式的解释，适用场合"></a><strong>门面模式的解释，适用场合</strong></h5><p>【1】<a href="http://www.cnblogs.com/lthIU/p/5860607.html" target="_blank" rel="noopener">http://www.cnblogs.com/lthIU/p/5860607.html</a></p><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a><strong>Hibernate</strong></h3><p>Hibernate工作原理</p><p>Hibernate四种查询</p><p>Hibernate的3种对象状态</p><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/68923405#t9" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/68923405#t9</a></p><h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h3><p>JVM虚拟机内存模型</p><p>堆内存模型</p><p>【1】<a href="http://www.cnblogs.com/AloneSword/p/4262255.html" target="_blank" rel="noopener">http://www.cnblogs.com/AloneSword/p/4262255.html</a></p><p><strong>垃圾回收算法：</strong></p><ul><li>引用计数算法</li><li>根搜索算法</li><li>标记-清除算法</li><li>标记-整理算法</li><li>分代收集算法</li><li>CMS算法：Concurrent Mark Sweep/CMS是一款并发、使用标记-清除算法的gc。（<a href="http://www.cnblogs.com/Leo_wl/p/5393300.html" target="_blank" rel="noopener">http://www.cnblogs.com/Leo_wl/p/5393300.html</a> 或者 <a href="http://blog.csdn.net/aibisoft/article/details/27555793）" target="_blank" rel="noopener">http://blog.csdn.net/aibisoft/article/details/27555793）</a></li></ul><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><strong>Linux常用命令</strong></h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h5><h5 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a><strong>管道命令</strong></h5><p>【1】<a href="http://www.cnblogs.com/mrzero/p/3985302.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrzero/p/3985302.html</a></p><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h3><h5 id="Tomcat性能调优"><a href="#Tomcat性能调优" class="headerlink" title="Tomcat性能调优"></a><strong>Tomcat性能调优</strong></h5><ul><li>JVM参数调优</li><li>NIO协议</li><li>线程池和连接数配置</li><li>禁用AJP协议</li></ul><h5 id="Tomcat启动时加载数据到缓存"><a href="#Tomcat启动时加载数据到缓存" class="headerlink" title="Tomcat启动时加载数据到缓存"></a><strong>Tomcat启动时加载数据到缓存</strong></h5><p>【1】<a href="http://blog.csdn.net/cnctcom/article/details/52861955" target="_blank" rel="noopener">http://blog.csdn.net/cnctcom/article/details/52861955</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><h5 id="git如何回退到某个历史版本"><a href="#git如何回退到某个历史版本" class="headerlink" title="git如何回退到某个历史版本"></a><strong>git如何回退到某个历史版本</strong></h5><p>【1】<a href="http://blog.csdn.net/newjueqi/article/details/49098123" target="_blank" rel="noopener">http://blog.csdn.net/newjueqi/article/details/49098123</a></p><h5 id="SVN和Git优缺点比较"><a href="#SVN和Git优缺点比较" class="headerlink" title="SVN和Git优缺点比较"></a><strong>SVN和Git优缺点比较</strong></h5><p>【1】<a href="http://blog.csdn.net/yuwq123/article/details/52748009" target="_blank" rel="noopener">http://blog.csdn.net/yuwq123/article/details/52748009</a></p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h3><h5 id="Statement与PreparedStatement的区别"><a href="#Statement与PreparedStatement的区别" class="headerlink" title="Statement与PreparedStatement的区别?"></a><strong>Statement与PreparedStatement的区别?</strong></h5><p>【1】<a href="http://blog.csdn.net/haorengoodman/article/details/23995347" target="_blank" rel="noopener">http://blog.csdn.net/haorengoodman/article/details/23995347</a></p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h3><h5 id="MyBatis如何唯一标识一个SQL语句"><a href="#MyBatis如何唯一标识一个SQL语句" class="headerlink" title="MyBatis如何唯一标识一个SQL语句"></a><strong>MyBatis如何唯一标识一个SQL语句</strong></h5><h5 id="Hibernate和MyBatis如何映射一对多关系"><a href="#Hibernate和MyBatis如何映射一对多关系" class="headerlink" title="Hibernate和MyBatis如何映射一对多关系"></a><strong>Hibernate和MyBatis如何映射一对多关系</strong></h5><p>【1】<a href="http://www.cnblogs.com/liujiayun/p/5814158.html" target="_blank" rel="noopener">http://www.cnblogs.com/liujiayun/p/5814158.html</a></p><p>【2】<a href="http://blog.csdn.net/suwu150/article/details/52896459" target="_blank" rel="noopener">http://blog.csdn.net/suwu150/article/details/52896459</a></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端**"></a>前端**</h3><h5 id="ajax原理"><a href="#ajax原理" class="headerlink" title="ajax原理"></a><strong>ajax原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="noopener">http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html</a></p><h3 id="算法面试题"><a href="#算法面试题" class="headerlink" title="算法面试题"></a><strong>算法面试题</strong></h3><p>现在有1000瓶药水，其中至多有1瓶是有剧毒的，现在给你10只狗，在24小时内通过小狗试药的方式，</p><p>找出那些药有毒或者全部没毒（小狗服完药20小时之后才能判断是否中毒）。</p><p>【1】<a href="http://blog.csdn.net/sancho_lai/article/details/3218786" target="_blank" rel="noopener">http://blog.csdn.net/sancho_lai/article/details/3218786</a></p><h3 id="Java中Atomic包的原理和分析"><a href="#Java中Atomic包的原理和分析" class="headerlink" title="Java中Atomic包的原理和分析"></a>Java中Atomic包的原理和分析</h3><p>【1】<a href="http://blog.csdn.net/tanga842428/article/details/52765537" target="_blank" rel="noopener">http://blog.csdn.net/tanga842428/article/details/52765537</a></p><p>下面是笔者整理的jdk自带的常用命令行工具的使用方法，全部原创，转载请注明出处，并贴上链接，谢谢！</p><ul><li><a href="http://blog.csdn.net/winwill2012/article/details/46319033" target="_blank" rel="noopener"><strong>jps命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46319355" target="_blank" rel="noopener"><strong>jstat命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46336839" target="_blank" rel="noopener"><strong>jinfo命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46337339" target="_blank" rel="noopener"><strong>jmap命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46337535" target="_blank" rel="noopener"><strong>jhat命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46364339" target="_blank" rel="noopener"><strong>jstack命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46364849" target="_blank" rel="noopener"><strong>jcmd命令使用</strong></a></li></ul><h3 id="后台系统怎么防止请求重复提交"><a href="#后台系统怎么防止请求重复提交" class="headerlink" title="后台系统怎么防止请求重复提交"></a><strong>后台系统怎么防止请求重复提交</strong></h3><p>【1】<a href="http://blog.csdn.net/hshl1214/article/details/46635905" target="_blank" rel="noopener">http://blog.csdn.net/hshl1214/article/details/46635905</a></p><h3 id="有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。"><a href="#有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。"></a><strong>有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。</strong></h3><p>【1】<a href="http://www.cnblogs.com/children/archive/2012/10/02/2710624.html" target="_blank" rel="noopener">http://www.cnblogs.com/children/archive/2012/10/02/2710624.html</a></p><h3 id="反射中，Class-forName-和-ClassLoader-区别"><a href="#反射中，Class-forName-和-ClassLoader-区别" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别"></a><strong>反射中，Class.forName 和 ClassLoader 区别</strong></h3><h3 id="描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点。"></a><strong>描述动态代理的几种实现方式，分别说出相应的优缺点。</strong></h3><p>【1】<a href="http://blog.csdn.net/kyi_zhu123/article/details/52644624" target="_blank" rel="noopener">http://blog.csdn.net/kyi_zhu123/article/details/52644624</a></p><h3 id="在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。"><a href="#在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。" class="headerlink" title="在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。"></a><strong>在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。</strong></h3><ol><li><a href="http://blog.csdn.net/bbirdsky/article/details/8283143" target="_blank" rel="noopener">http://blog.csdn.net/bbirdsky/article/details/8283143</a>  </li><li>字符串类(Java.lang.String)是Java中使用最多的类，也是最为特殊的一个类，很多时候，我们对它既熟悉又陌生。在很多面试题中经常用String大做文章，只要掌握了String特性，对付它们就不再是困难了。  </li><li>1、从根本上认识java.lang.String类和String池  </li><li>首先，我建议先看看String类的源码实现，这是从本质上认识String类的根本出发点。  </li><li>从源码中可以看到：  </li><li>String类是final的，不可被继承。public final class String。  </li><li>String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];  </li><li>​</li><li>然后打开String类的API文档，从API中可以发现：  </li><li>String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。  </li><li>String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联，这个后面会讲述。  </li><li>Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。  </li><li>​</li><li>2、创建字符串的方式  </li><li>创建字符串的方式很多，归纳起来有三类：  </li><li>使用new关键字创建字符串，比如String s1 = new String(“abc”);  </li><li>直接指定。比如String s2 = “abc”;  </li><li>使用串联生成新的字符串。比如String s3 = “ab” + “c”。  </li><li>​</li><li>3、String对象的创建的特性  </li><li>String对象的创建也很讲究，关键是要明白其原理。  </li><li>​</li><li>特性1：  </li><li>当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个字符串的内容在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。  </li><li>​</li><li>特性2：  </li><li>Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。  </li><li>​</li><li>特性3：  </li><li>使用直接指定、使用纯字符串串联或者在编译期间可以确定结果的变量表达式来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象；  </li><li>1、 直接指定，例如：下面代码运行结果为true；  </li><li>String str1 = “abc”;  </li><li>String str2 = “abc”;  </li><li>System.out.println(str1 == str2);  </li><li>2、 使用纯字符串串联，例如：下面代码运行结果为true；  </li><li>String str1 = “abc”;  </li><li>String str2 = “ab” + “c”;  </li><li>System.out.println(str1 == str2);  </li><li>3、 在编译期间可以确定结果的变量表达式，例如：下面代码运行结果为true。  </li><li>final String str1 = “c”; //final类型的变量在编译时当常量处理  </li><li>String str2 = “ab” + “c”;  </li><li>String str3 = “ab” + str1;  </li><li>System.out.println(str2==str3);  </li><li>​</li><li>否则使用包含编译期间无法确定结果的变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String（由StringBuilder.toString()生成）对象。  </li><li>1、普通变量表达式进行创建字符串，例如：下面代码运行结果为false；  </li><li>String str1 = “c”;  </li><li>String str2 = “ab” + “c”;  </li><li>String str3 = “ab” + str1;  </li><li>System.out.println(str2==str3);  </li></ol><h3 id="人事问题（补充）"><a href="#人事问题（补充）" class="headerlink" title="人事问题（补充）"></a><strong>人事问题（补充）</strong></h3><p>在面试过程中，当你技术面试过关之后，通常会有一个HR面试，一般到这里说明你基本已经通过了面试，但是你还是不能松懈的，这一面也是不容小觑的。比如HR经常会问你这些问题：</p><ul><li>你为什么要离职啊？</li><li>你对我们公司还有什么要了解的吗？</li><li>你能支持经常出差吗？或者能支持经常加班吗？</li><li>你上一家公司的薪资是多少？</li><li>你手里拿到多少个offer了？</li><li>如果我们公司的薪资达不到你的要求，你会考虑留下来吗？</li><li>等等一系列的问题。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h3&gt;&lt;h5 id=&quot;String-StringBuffer-与-StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String-
      
    
    </summary>
    
    
  </entry>
  
</feed>
