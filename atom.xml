<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭琪的博客</title>
  
  <subtitle>人生如逆旅，我亦是行人。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-04T03:40:44.525Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郭 琪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>intellij idea最常用快捷键</title>
    <link href="http://yoursite.com/2018/06/04/intellij%20idea%E6%9C%80%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/06/04/intellij idea最常用快捷键/</id>
    <published>2018-06-04T03:40:05.827Z</published>
    <updated>2018-06-04T03:40:44.525Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理以前的笔记，发现很多挺有用的东西，虽然现在看起来已经很简单了，但是毕竟是自己亲自总结的，不忍丢弃。这是一些idea最常用快捷键，虽然使用intellij idea一年多了，但偶尔还会记错，急用时就不用再去找笔记了。</p><table><thead><tr><th>方法</th><th>快捷键</th></tr></thead><tbody><tr><td>向上空一行</td><td>Ctrl+ALT+Enter</td></tr><tr><td>向下空一行</td><td>Shift+Enter</td></tr><tr><td>向上移动方法块</td><td>Ctrl+Shift+↑</td></tr><tr><td>向下移动方法块</td><td>Ctrl+Shift+↓</td></tr><tr><td>删除行</td><td>Ctrl+X</td></tr><tr><td>复制行</td><td>Ctrl+D</td></tr><tr><td>格式化代码</td><td>Ctrl+Alt+L</td></tr><tr><td>查看一个类所有方法</td><td>Ctrl+F12</td></tr><tr><td>重写接口实现类</td><td>Ctrl+I</td></tr><tr><td>导入包,自动修正</td><td>Alt+Enter</td></tr><tr><td>去除未引用的类和包</td><td>Ctrl+Alt+O</td></tr><tr><td>方法参数提示</td><td>Ctrl+P</td></tr><tr><td>显示类结构图</td><td>Ctrl+H</td></tr><tr><td>查找类</td><td>Ctrl+N</td></tr><tr><td>查找文件</td><td>Ctrl+Shift+N</td></tr><tr><td>补全代码</td><td>Ctrl+ALT+V</td></tr><tr><td>搜索</td><td>Ctrl+F</td></tr><tr><td>ry…catch..</td><td>Ctrl+Alt+T</td></tr><tr><td>快速打开或隐藏工程面板</td><td>Alt+1</td></tr><tr><td>生成get或set方法快捷键</td><td>Alt+insert</td></tr><tr><td>导入未实现的方法,强制类型转换</td><td>Alt+Enter</td></tr><tr><td>断点调式查看值</td><td>Alt+F8</td></tr><tr><td>Debug(遇到嵌套的方法会进入)</td><td>F7</td></tr><tr><td>Debug(遇到嵌套方法跳过)</td><td>F8</td></tr><tr><td>Debug(调到下一个断点)</td><td>F9</td></tr><tr><td>设置</td><td>Ctrl+Alt+S</td></tr><tr><td>替换</td><td>Ctrl+R</td></tr><tr><td>新建Modules</td><td>Ctrl+Shift+Alt+T</td></tr><tr><td>foreach 循环</td><td>Ctrl + j</td></tr><tr><td>public static void main(String[] args)</td><td>psvm</td></tr><tr><td>System.out.println()</td><td>sout</td></tr><tr><td>全文查找</td><td>Ctrl+Shift+F</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天整理以前的笔记，发现很多挺有用的东西，虽然现在看起来已经很简单了，但是毕竟是自己亲自总结的，不忍丢弃。这是一些idea最常用快捷键，虽然使用intellij idea一年多了，但偶尔还会记错，急用时就不用再去找笔记了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一种数组去重方法</title>
    <link href="http://yoursite.com/2018/06/04/%E4%B8%80%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/04/一种数组去重方法/</id>
    <published>2018-06-04T01:54:39.566Z</published>
    <updated>2018-06-04T01:53:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>数组如何去重呢？可以先转成一个list集合，然后再把这个list集合整体放入一个新的LinkedHashSet&lt;&gt;中，hashSet不会添加重复的元素，这样就去除了那些重复的；最后再把这个LinkedHashSet&lt;&gt;转换为数组就可以了。下面贴上我的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.demo;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.LinkedHashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Test01 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Integer[] array = &#123;10,10,10,5,5,5,100,20,2000,2000,20,20,80,80,80,80&#125;;</span><br><span class="line">//把数组变成集合</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">//定义一个LinkedHashSet集合,可以去重并且按照存入的顺序进行显示</span><br><span class="line">LinkedHashSet&lt;Integer&gt; lhs = new LinkedHashSet&lt;&gt;();</span><br><span class="line">//将list中的内容添加到lhs中</span><br><span class="line">lhs.addAll(list);</span><br><span class="line">//把lhs集合中的内容变成数组</span><br><span class="line">Integer[] newArray = lhs.toArray(new Integer[lhs.size()]);</span><br><span class="line">System.out.println(&quot;原数组: &quot;+Arrays.toString(array));</span><br><span class="line">System.out.println(&quot;去重后的数组: &quot;+Arrays.toString(newArray));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数组如何去重呢？可以先转成一个list集合，然后再把这个list集合整体放入一个新的LinkedHashSet&amp;lt;&amp;gt;中，hashSet不会添加重复的元素，这样就去除了那些重复的；最后再把这个LinkedHashSet&amp;lt;&amp;gt;转换为数组就可以了。下面贴上我的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BIO与NIO、AIO学习笔记</title>
    <link href="http://yoursite.com/2018/06/03/BIO,NIO,AIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/03/BIO,NIO,AIO学习笔记/</id>
    <published>2018-06-03T07:03:55.435Z</published>
    <updated>2018-06-03T12:12:50.722Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。</p><p>java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。<a href="http://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">字符集</a>编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和<a href="http://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">内存映射文件</a>的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。</p><h6 id="大纲目录"><a href="#大纲目录" class="headerlink" title="大纲目录"></a><strong>大纲目录</strong></h6><ul><li>1.总体介绍</li><li>2.IO基础知识回顾</li><li>3.BIO编程</li><li>4.伪异步I/O编程</li><li>5.NIO 编程简单介绍</li><li>6.通道 Channel</li><li>7.缓冲区 Buffer</li><li>8.选择器 Selector</li><li>9.分散（Scatter）/聚集（Gather）</li><li>10.其他通道</li><li>11.管道（Pipe）</li><li>12.AIO编程</li></ul><h6 id="IO，NIO，JDK介绍"><a href="#IO，NIO，JDK介绍" class="headerlink" title="IO，NIO，JDK介绍**"></a>IO，NIO，JDK介绍**</h6><p>查看JDK</p><h4 id="IO基础知识回顾"><a href="#IO基础知识回顾" class="headerlink" title="IO基础知识回顾"></a><strong>IO基础知识回顾</strong></h4><h6 id="IO流类图结构"><a href="#IO流类图结构" class="headerlink" title="IO流类图结构"></a>IO流类图结构</h6><p><img src="https://upload-images.jianshu.io/upload_images/12253573-4e46ad888ecd59c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO流知识图.jpg"></p><h6 id="IO流简单例子"><a href="#IO流简单例子" class="headerlink" title="IO流简单例子"></a>IO流简单例子</h6><p>实例一：        </p><pre><code>FileInputStream fis=null;FileOutputStream fos=null;try {    fis = new FileInputStream(new File(&quot;D:\\a.txt&quot;));    fos = new FileOutputStream(new File(&quot;D:\\y.txt&quot;));    int ch;    while((ch=fis.read()) != -1){        System.out.println((char)ch);        fos.write(ch);    }} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}finally {    if(null != fos){        fos.close();    }    if(null != fis){        fis.close();    }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12253573-9ce8520cc3d558a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-480f7ddf1d788db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>实例二：字节流转换成字符流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:\\a.txt&quot;)));</span><br><span class="line">            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;D:\\y.txt&quot;)));</span><br><span class="line">            String s;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            while((s=br.readLine())!=null)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                bw.write(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != bw)&#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实例三：用转换流从控制台上读入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            String s=br.readLine();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h4><h5 id="传统BIO通信模型图"><a href="#传统BIO通信模型图" class="headerlink" title="传统BIO通信模型图"></a><strong>传统BIO通信模型图</strong></h5><p>​    传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行<strong>同步阻塞式</strong>通信。 服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。</p><p>​    简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。</p><p>​    传统BIO通信模型图：</p><p>​    <img src="https://upload-images.jianshu.io/upload_images/12253573-ee9dde1900e94c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>​    该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，<strong>服务端的线程个数和客户端并发访问数呈1:1的正比关系</strong>，<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p><h5 id="传统BIO编程实例"><a href="#传统BIO编程实例" class="headerlink" title="传统BIO编程实例"></a><strong>传统BIO编程实例</strong></h5><p>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">package com.evada.de;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */</span><br><span class="line">public final class AyTest extends BaseTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //启动线程，运行服务器</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ServerBetter.start();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">        //启动线程，运行客户端</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;;</span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @SuppressWarnings(&quot;static-access&quot;)</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //随机产生算术表达式</span><br><span class="line">                    String expression = random.nextInt(10) + &quot;&quot; + operators[random.nextInt(4)] + (random.nextInt(10) + 1);</span><br><span class="line">                    Client.send(expression);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.currentThread().sleep(random.nextInt(1000));</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ServerBetter&#123;</span><br><span class="line"></span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    //单例的ServerSocket</span><br><span class="line">    private static ServerSocket server;</span><br><span class="line"></span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span><br><span class="line">    public static void start() throws IOException &#123;</span><br><span class="line">        //使用默认值端口</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;</span><br><span class="line">        if(server != null) return;</span><br><span class="line">        try&#123;</span><br><span class="line">            //通过构造函数创建ServerSocket，如果端口合法且空闲，服务端就监听成功</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">            //通过无线循环监听客户端连接，如果没有客户端接入，将阻塞在accept操作上。</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码</span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路</span><br><span class="line">                new Thread(new ServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(server != null)&#123;</span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            String expression;</span><br><span class="line">            String result;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //通过BufferedReader读取一行</span><br><span class="line">                //如果已经读到输入流尾部，返回null,退出循环</span><br><span class="line">                //如果得到非空值，就尝试计算结果并返回</span><br><span class="line">                if((expression = in.readLine())==null) break;</span><br><span class="line">                System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">                try&#123;</span><br><span class="line">                    result = &quot;123&quot;;//Calculator.cal(expression).toString();</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                    result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_SERVER_PORT = 12345;</span><br><span class="line">    //默认服务器Ip</span><br><span class="line">    private static String DEFAULT_SERVER_IP = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    public static void send(String expression)&#123;</span><br><span class="line">        send(DEFAULT_SERVER_PORT,expression);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void send(int port,String expression)&#123;</span><br><span class="line">        System.out.println(&quot;算术表达式为：&quot; + expression);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(DEFAULT_SERVER_IP,port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            out.println(expression);</span><br><span class="line">            System.out.println(&quot;___结果为：&quot; + in.readLine());</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一下必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪异步I-O编程"><a href="#伪异步I-O编程" class="headerlink" title="伪异步I/O编程"></a><strong>伪异步I/O编程</strong></h4><p>我们可以使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（<strong>但是底层还是使用的同步阻塞I/O</strong>），通常被称为“伪异步I/O模型“</p><h5 id="伪异步I-O编程模型图"><a href="#伪异步I-O编程模型图" class="headerlink" title="伪异步I/O编程模型图"></a>伪异步I/O编程模型图</h5><p><img src="https://upload-images.jianshu.io/upload_images/12253573-096c246f211d008d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="伪异步io流.png"></p><p>  测试运行结果是一样的。</p><p>​    我们知道，如果使用CachedThreadPool线程池（不限制线程数量，如果不清楚请参考文首提供的文章），其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用<strong>FixedThreadPool</strong>我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型。</p><p>​    但是，正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流就行读取时，会一直阻塞，直到发生：</p><ul><li>​    有数据可读</li><li>​    可用数据以及读取完毕</li><li>​    发生空指针或I/O异常</li></ul><p>​    所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。</p><p>​    而后面即将介绍的NIO，就能解决这个难题。</p><h5 id="伪异步IO编程代码"><a href="#伪异步IO编程代码" class="headerlink" title="伪异步IO编程代码"></a><strong>伪异步IO编程代码</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.anxpp.io.calculator.bio;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">import java.util.concurrent.ExecutorService;  </span><br><span class="line">import java.util.concurrent.Executors;  </span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */ </span><br><span class="line">public final class ServerBetter &#123;  </span><br><span class="line">    //默认的端口号  </span><br><span class="line">    private static int DEFAULT_PORT = 12345;  </span><br><span class="line">    //单例的ServerSocket  </span><br><span class="line">    private static ServerSocket server;  </span><br><span class="line">    //线程池 懒汉式的单例  </span><br><span class="line">    private static ExecutorService executorService = Executors.newFixedThreadPool(60);  </span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值  </span><br><span class="line">    public static void start() throws IOException&#123;  </span><br><span class="line">        //使用默认值  </span><br><span class="line">        start(DEFAULT_PORT);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了  </span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;  </span><br><span class="line">        if(server != null) return;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            //通过构造函数创建ServerSocket  </span><br><span class="line">            //如果端口合法且空闲，服务端就监听成功  </span><br><span class="line">            server = new ServerSocket(port);  </span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);  </span><br><span class="line">            //通过无线循环监听客户端连接  </span><br><span class="line">            //如果没有客户端接入，将阻塞在accept操作上。  </span><br><span class="line">            while(true)&#123;  </span><br><span class="line">                Socket socket = server.accept();  </span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码  </span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路  </span><br><span class="line">                executorService.execute(new ServerHandler(socket));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            //一些必要的清理工作  </span><br><span class="line">            if(server != null)&#123;  </span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);  </span><br><span class="line">                server.close();  </span><br><span class="line">                server = null;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1,同步和异步是针对应用程序和内核的交互而言的。 </li><li>2,阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。  </li></ul><p>由上描述基本可以总结一句简短的话，<strong>同步和异步是目的，阻塞和非阻塞是实现方式</strong>。</p><p><strong>同步阻塞：</strong><br>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。 </p><p><strong>同步非阻塞：</strong><br>在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。<br><strong>异步：</strong><br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p><p>如果你想吃一份宫保鸡丁盖饭： </p><p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ </p><p>同步非阻塞（NIO）：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><h4 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h5><p>Java NIO(New IO)是一个可以替代标准Java IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p><p>Java NIO 由以下几个核心部分组成： </p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件，但Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，我将集中精力在这三个组件上。其它组件会在单独的章节中讲到。 </p><p>注意（每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送响应）</p><h5 id="非常形象的实例"><a href="#非常形象的实例" class="headerlink" title="非常形象的实例"></a><strong>非常形象的实例</strong></h5><p>小量的线程如何同时为大量连接服务呢，答案就是就绪选择。这就好比到餐厅吃饭，每来一桌客人，都有一个服务员专门为你服务，从你到餐厅到结帐走人，这样方式的好处是服务质量好，一对一的服务，VIP啊，可是缺点也很明显，成本高，如果餐厅生意好，同时来100桌客人，就需要100个服务员，那老板发工资的时候得心痛死了，这就是传统的一个连接一个线程的方式。</p><p>老板是什么人啊，精着呢。这老板就得捉摸怎么能用10个服务员同时为100桌客人服务呢，老板就发现，服务员在为客人服务的过程中并不是一直都忙着，客人点完菜，上完菜，吃着的这段时间，服务员就闲下来了，可是这个服务员还是被这桌客人占用着，不能为别的客人服务，用华为领导的话说，就是工作不饱满。那怎么把这段闲着的时间利用起来呢。这餐厅老板就想了一个办法，让一个服务员（前台）专门负责收集客人的需求，登记下来，比如有客人进来了、客人点菜了，客人要结帐了，都先记录下来按顺序排好。每个服务员到这里领一个需求，比如点菜，就拿着菜单帮客人点菜去了。点好菜以后，服务员马上回来，领取下一个需求，继续为别人客人服务去了。这种方式服务质量就不如一对一的服务了，当客人数据很多的时候可能需要等待。但好处也很明显，由于在客人正吃饭着的时候服务员不用闲着了，服务员这个时间内可以为其他客人服务了，原来10个服务员最多同时为10桌客人服务，现在可能10个服务员，就可以负责50桌、100桌。。。。</p><p>这种服务方式跟传统的区别有两个：</p><p>1、增加了一个角色，要有一个专门负责收集客人需求的人。NIO里对应的就是Selector。</p><p>2、由阻塞服务方式改为非阻塞服务了，客人吃着的时候服务员不用一直侯在客人旁边了。传统的IO操作，比如read()，当没有数据可读的时候，线程一直阻塞被占用，直到数据到来。NIO中没有数据可读时，read()会立即返回0，线程不会阻塞。</p><p>NIO中，客户端创建一个连接后，先要将连接注册到Selector，相当于客人进入餐厅后，告诉前台你要用餐，前台会告诉你你的桌号是几号，然后你就可能到那张桌子坐下了，SelectionKey就是桌号。当某一桌需要服务时，前台就记录哪一桌需要什么服务，比如1号桌要点菜，2号桌要结帐，服务员从前台取一条记录，根据记录提供服务，完了再来取下一条。这样服务的时间就被最有效的利用起来了。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h5><p>原理图一：简图</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-2d7f631076e8ecd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>原理图二：详图</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-f7ae6b97e9d8158c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h5 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h5><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>Stream oriented</td><td>Buffer oriented</td></tr><tr><td>Blocking IO</td><td>Non blocking IO</td></tr><tr><td></td><td>Selectors</td></tr></tbody></table><h6 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a><strong>面向流与面向缓冲</strong></h6><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的</p><p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它<strong>不能前后移动流中的数据</strong>。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的<strong>灵活性</strong>。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 </p><h6 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a><strong>阻塞与非阻塞IO</strong></h6><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p><h5 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a><strong>NIO和IO如何影响应用程序的设计</strong></h5><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面： </p><ul><li>对NIO或IO类的API调用。</li><li>数据处理。</li><li>用来处理数据的线程数。</li></ul><h5 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h6><p>Channel 是对数据的源头和数据目标点流经途径的抽象，在这个意义上和 InputStream 和 OutputStream 类似。Channel可以译为“通道、管 道”，而传输中的数据仿佛就像是在其中流淌的水。前面也提到了Buffer，Buffer和Channel相互配合使用，才是Java的NIO。</p><h6 id="Java-NIO的通道与流区别"><a href="#Java-NIO的通道与流区别" class="headerlink" title="Java NIO的通道与流区别"></a>Java NIO的通道与流区别</h6><ul><li><p>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</p></li><li><p>通道可以异步地读写。</p></li><li><p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</p><p>​</p></li></ul><p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-77cb44a820e56481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-7d7a517d14ca4b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：通道必须结合Buffer使用，不能直接向通道中读/写数据</p><h6 id="Channel主要分类"><a href="#Channel主要分类" class="headerlink" title="Channel主要分类"></a><strong>Channel主要分类</strong></h6><p>广义上来说通道可以被分为两类：File I/O和Stream I/O，也就是文件通道和套接字通道。如果分的更细致一点则是：</p><ul><li>FileChannel 从文件读写数据</li><li>SocketChannel 通过TCP读写网络数据</li><li>ServerSocketChannel 可以监听新进来的TCP连接，并对每个链接创建对应的SocketChannel</li><li>DatagramChannel 通过UDP读写网络中的数据</li><li>Pipe</li></ul><h6 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a><strong>Channel的实现</strong></h6><p>这些是Java NIO中最重要的通道的实现： </p><ul><li>FileChannel：从文件中读写数据。</li><li>DatagramChannel：能通过UDP读写网络中的数据。</li><li>SocketChannel：能通过TCP读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h6 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h6><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d://nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure><h6 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h6><p>调用多个read()方法之一从FileChannel中读取数据。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p><p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h6 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h6><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p><h6 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h6><p>用完FileChannel后必须将其关闭。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure><h6 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h6><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p><p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p><p>这里有两个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure><p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</p><p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p><h6 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h6><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure><h6 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h6><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure><p>这个例子截取文件的前1024个字节。</p><h6 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h6><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p><p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure><p><strong>transferFrom()</strong></p><p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，</span><br><span class="line">//需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</span><br><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();  </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();   </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure><p>transferFrom 方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 </p><p>此外要注意，在 SoketChannel 的实现中，SocketChannel 只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel 可能不会将请求的所有数据(count个字节)全部传输到 FileChannel 中。 </p><p><strong>transferTo()</strong></p><p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();    </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();  </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。 </p><p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。 </p><h6 id="Channel简单实例"><a href="#Channel简单实例" class="headerlink" title="Channel简单实例"></a><strong>Channel简单实例</strong></h6><p>下面是Channel的一个简单的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h5 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h5><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。 </p><h6 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a><strong>Buffer的基本用法</strong></h6><p>使用Buffer读写数据一般遵循以下四个步骤： </p><ul><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ul><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从<strong>写模式切换到读模式</strong>。在读模式下，可以读取之前写入到buffer的所有数据。 </p><p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 <strong>clear() 或 compact() 方法</strong>。clear() 方法会清空整个缓冲区。compact() <strong>方法只会清除已经读过的数据</strong>。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h6 id="Buffer的三个属性"><a href="#Buffer的三个属性" class="headerlink" title="Buffer的三个属性"></a><strong>Buffer的三个属性</strong></h6><p>为了理解Buffer的工作原理，需要熟悉它的三个属性： </p><ul><li><strong>capacity</strong>：作为一个内存块，Buffer 有一个固定的大小值，也叫 “capacity”. 你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。 </li><li><strong>position</strong>：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity – 1。 当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position会被重置为 0。当从Buffer的 position 处读取数据时，position 向前移动到下一个可读的位置。 </li><li><strong>limit</strong>：在写模式下，Buffer的limit表示你最多能往 Buffer 里写多少数据。 <strong>写模式下</strong>，limit 等于 Buffer 的 capacity 。 当切换Buffer到读模式时， limit 表示你<strong>最多</strong>能读到多少数据。因此，当切换Buffer到读模式时，limit 会被设置成写模式下的 position 值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是 position ）。 </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12253573-4f05e0bf6b4092fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buffers-modes.png"></p><h6 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a><strong>Buffer的类型</strong></h6><p>Java NIO 有以下Buffer类型： </p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h6 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a><strong>Buffer的分配</strong></h6><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储1024个字符的CharBuffer： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure><h6 id="Buffer写数据"><a href="#Buffer写数据" class="headerlink" title="Buffer写数据"></a><strong>Buffer写数据</strong></h6><p>写数据到Buffer有两种方式： </p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的put()方法写到Buffer里。</li></ul><p>从Channel写到Buffer，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer</span><br></pre></td></tr></table></figure><p>通过put方法写Buffer的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure><p>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。 </p><h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><strong>flip()方法</strong></h5><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。 </p><p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。 </p><h6 id="Buffer中读取数据"><a href="#Buffer中读取数据" class="headerlink" title="Buffer中读取数据"></a><strong>Buffer中读取数据</strong></h6><p>从Buffer中读取数据有两种方式： </p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><p>从Buffer读取数据到Channel的例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//read from buffer into channel.  </span><br><span class="line">int bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure><p>使用get()方法从Buffer中读取数据的例子 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte = buf.get();</span><br></pre></td></tr></table></figure><p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。</p><p><strong>rewind()方法</strong> </p><p>Buffer.rewind()将 position 设回0，所以你可以重读Buffer中的所有数据。limit 保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</p><p><strong>clear()与compact()方法</strong></p><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。 </p><p>如果调用的是 clear() 方法，position将被设回 0，limit被设置成 capacity 的值。换句话说，Buffer 被清空了。</p><p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。 </p><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p><p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。 </p><p><strong>mark()与reset()方法</strong></p><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();  </span><br><span class="line">//set position back to mark.  </span><br><span class="line">buffer.reset();  </span><br><span class="line">equals()与compareTo()方法</span><br></pre></td></tr></table></figure><p>可以使用equals()和compareTo()方法两个Buffer。 </p><p><strong>equals()</strong></p><p>当满足下列条件时，表示两个Buffer相等： </p><ul><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的 byte、char 等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ul><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 </p><p><strong>compareTo()方法</strong></p><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer “小于” 另一个Buffer： </p><ul><li>第一个不相等的元素小于另一个Buffer中对应的元素。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li></ul><h5 id="选择器（-Selector）"><a href="#选择器（-Selector）" class="headerlink" title="选择器（ Selector）"></a>选择器（ Selector）</h5><h6 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h6><p>Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。Selector提供选择<strong>已经就绪的任务的能力</strong>：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过<strong>SelectionKey</strong>可以获取就绪Channel的集合，进行后续的I/O操作。</p><p>一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-6c12c7fbdf8b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>要使用Selector，得向 Selector 注册 Channel ，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子比如新连接进来，数据接收等。 </p><h6 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a><strong>Selector的创建</strong></h6><p>通过调用Selector.open()方法创建一个Selector，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h6 id="Selector注册通道"><a href="#Selector注册通道" class="headerlink" title="Selector注册通道"></a><strong>Selector注册通道</strong></h6><p>为了将 Channel 和 Selector 配合使用，必须将 channel 注册到 selector 上。通过 SelectableChannel.register() 方法来实现，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);  </span><br><span class="line">SelectionKey key = channel.register(selector,  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式。而套接字通道都可以。 </p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件： </p><ul><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ul><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个 server socket channel 准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。 </p><p>这四种事件用 SelectionKey 的四个常量来表示： </p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>如果你对不止一种事件感兴趣，那么可以用 “ 位 或 ” 操作符将常量连接起来，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h6 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a><strong>SelectionKey</strong></h6><p>在上一小节中，当向Selector注册Channel时，register() 方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性： </p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><p>下面我会描述这些属性。</p><p><strong>interest集合</strong></p><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过 SelectionKey 读写 interest 集合，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line">boolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><p>可以看到，用“位与”操作interest 集合和给定的 SelectionKey 常量，<strong>可以确定某个确定的事件是否在 interest 集合中</strong>。</p><p><strong>ready集合</strong></p><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个readySet。Selection将在下一小节进行解释。可以这样访问ready集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure><p>可以用像检测 interest 集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><p><strong>Channel + Selector</strong></p><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><p><strong>附加的对象</strong></p><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><p><strong>通过Selector选择通道</strong></p><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p><p>select(long timeout) 和 select() 一样，除了最长会阻塞 timeout 毫秒(参数)。</p><p>selectNow() 不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><p><strong>selectedKeys()</strong></p><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当向 Selector 注册 Channel 时，Channel.register() 方法会返回一个 SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的 keyIterator.remove() 调用。Selector不会自己从已选择键集中移除 SelectionKey 实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel() 方法返回的通道需要转型成你要处理的类型，如 ServerSocketChannel 或 SocketChannel 等。</p><p><strong>wakeUp()</strong></p><p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p><strong>close()</strong></p><p>用完 Selector 后调用其 close() 方法会关闭该 Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p><p>完整的示例</p><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p><pre><code>Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) {  int readyChannels = selector.select();  if(readyChannels == 0) continue;  Set selectedKeys = selector.selectedKeys();  Iterator keyIterator = selectedKeys.iterator();  while(keyIterator.hasNext()) {  SelectionKey key = keyIterator.next();  if(key.isAcceptable()) {    // a connection was accepted by a ServerSocketChannel.  } else if (key.isConnectable()) {    // a connection was established with a remote server.  } else if (key.isReadable()) {    // a channel is ready for reading  } else if (key.isWritable()) {    // a channel is ready for writing  }    keyIterator.remove();  }}</code></pre><h5 id="分散（Scatter）-聚集（Gather）"><a href="#分散（Scatter）-聚集（Gather）" class="headerlink" title="分散（Scatter）/聚集（Gather）"></a>分散（Scatter）/聚集（Gather）</h5><h6 id="分散概念"><a href="#分散概念" class="headerlink" title="分散概念"></a><strong>分散概念</strong></h6><p>分散（scatter）：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-bc98928415f0e3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure><p>注意buffer首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。read() 方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到buffer，当一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。 </p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。 </p><h6 id="聚集概念"><a href="#聚集概念" class="headerlink" title="聚集概念"></a><strong>聚集概念</strong></h6><p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-cae64631861a6ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">//write data into buffers  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>buffer的一个数组被传递给了 write() 方法，这个方法写他们在数组中遇到的接下来的 buffer 的内容。只是这些数据在 buffer 的 position 和 limit 直接被写。因此，如果一个buffer有一个128字节的容量，但是只包含了58个字节，只有58个字节可以从 buffer 中写到 channel 。因此，一个聚集写操作通过动态可变大小的消息部分会工作的很好，跟分散读取正好相反。</p><h6 id="分散-聚集的应用"><a href="#分散-聚集的应用" class="headerlink" title="分散/聚集的应用"></a><strong>分散/聚集的应用</strong></h6><p>scatter / gather经常用于需要将传输的数据分开处理的场合。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容纳正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p><p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p><h6 id="简单小例子"><a href="#简单小例子" class="headerlink" title="简单小例子"></a><strong>简单小例子</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf1=new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">//获取通道</span><br><span class="line">FileChannel channel1 = raf1.getChannel();</span><br><span class="line">//设置缓冲区</span><br><span class="line">ByteBuffer buf1=ByteBuffer.allocate(50);</span><br><span class="line">ByteBuffer buf2=ByteBuffer.allocate(1024);</span><br><span class="line">//分散读取的时候缓存区应该是有序的，所以把几个缓冲区加入数组中</span><br><span class="line">ByteBuffer[] bufs=&#123;buf1,buf2&#125;;</span><br><span class="line">//通道进行传输</span><br><span class="line">channel1.read(bufs);</span><br><span class="line">//查看缓冲区中的内容</span><br><span class="line">for (int i = 0; i &lt; bufs.length; i++) &#123;</span><br><span class="line">   //切换为读模式</span><br><span class="line">   bufs[i].flip();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(new String(bufs[0].array(),0,bufs[0].limit()));</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(new String(bufs[1].array(),0,bufs[1].limit()));</span><br><span class="line">//聚集写入</span><br><span class="line">RandomAccessFile  raf2=new RandomAccessFile(&quot;d:\\al.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel channel2 = raf2.getChannel();</span><br><span class="line">//只能通过通道来进行写入</span><br><span class="line">channel2.write(bufs);</span><br></pre></td></tr></table></figure><h5 id="其他通道"><a href="#其他通道" class="headerlink" title="其他通道"></a><strong>其他通道</strong></h5><p>​            </p><h6 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a><strong>文件通道</strong></h6><p>略</p><h6 id="Socket-通道"><a href="#Socket-通道" class="headerlink" title="Socket 通道"></a>Socket 通道</h6><p>Java NIO中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。可以通过以下2种方式创建 SocketChannel：</p><ul><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达 ServerSocketChannel 时，会创建一个 SocketChannel。</li></ul><p><strong>打开 SocketChannel</strong></p><p>下面是SocketChannel的打开方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;,80));</span><br></pre></td></tr></table></figure><p><strong>从 SocketChannel 读取数据</strong></p><p>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p><p>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p><p><strong>写入 SocketChannel</strong></p><p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p><p><strong>非阻塞模式</strong></p><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p><p><strong>connect()</strong></p><p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    //wait, or do something else...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>write()</strong></p><p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p><p><strong>read()</strong></p><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p><p><strong>不错的小例子</strong></p><p>一下是来自网络的一个小例子，个人觉得很不错，就贴到这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class NioClient &#123;</span><br><span class="line">    //管道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    public NioClient init(String serverIp, int port) throws IOException&#123;</span><br><span class="line">        //获取socket通道</span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        //获得通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line"></span><br><span class="line">        //客户端连接服务器，需要调用channel.finishConnect();才能实际完成连接。</span><br><span class="line">        channel.connect(new InetSocketAddress(serverIp, port));</span><br><span class="line">        //为该通道注册SelectionKey.OP_CONNECT事件</span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;客户端启动&quot;);</span><br><span class="line">        //轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //选择注册过的io操作的事件(第一次为SelectionKey.OP_CONNECT)</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选的key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                if(key.isConnectable())&#123;</span><br><span class="line">                    SocketChannel channel=(SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    //如果正在连接，则完成连接</span><br><span class="line">                    if(channel.isConnectionPending())&#123;</span><br><span class="line">                        channel.finishConnect();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向服务器发送消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to server.&quot;).getBytes()));</span><br><span class="line"></span><br><span class="line">                    //连接成功后，注册接收服务器消息的事件</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;客户端连接成功&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123; //有可读数据事件。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;recevie message from server:, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;client.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioClient().init(&quot;127.0.0.1&quot;, 9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class NioServer &#123;</span><br><span class="line">    //通道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    //获取一个ServerSocket通道，并初始化通道</span><br><span class="line">    public NioServer init(int port) throws IOException&#123;</span><br><span class="line">        //获取一个ServerSocket通道</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(false);</span><br><span class="line">        serverChannel.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        //获取通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line">        //将通道管理器与通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件，</span><br><span class="line">        //只有当该事件到达时，Selector.select()会返回，否则一直阻塞。</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;服务器端启动成功&quot;);</span><br><span class="line"></span><br><span class="line">        //使用轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //当有注册的事件到达时，方法返回，否则阻塞。</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            //获取selector中的迭代器，选中项为注册的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite=selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                //客户端请求连接事件</span><br><span class="line">                if(key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel)key.channel();</span><br><span class="line">                    //获得客户端连接通道</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向客户端发消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to client&quot;).getBytes()));</span><br><span class="line">                    //在与客户端连接成功后，为客户端通道注册SelectionKey.OP_READ事件。</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;客户端请求连接事件&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123;//有可读数据事件</span><br><span class="line">                    //获取客户端传输数据可读取消息通道。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                    //创建读取数据缓冲器</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    int read = channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;receive message from client, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;server.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioServer().init(9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Datagram-通道"><a href="#Datagram-通道" class="headerlink" title="Datagram 通道"></a>Datagram 通道</h6><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><p>Datagram 通道就作为大家自学的内容。</p><h5 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h5><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 </p><p><img src="https://upload-images.jianshu.io/upload_images/12253573-0c5dc6435ff44191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12253573-9302f20c78103fbf.png"></p><h6 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a><strong>创建管道</strong></h6><p>通过Pipe.open()方法打开管道。例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure><h6 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a><strong>向管</strong>道写数据</h6><p>要向管道写数据，需要访问sink通道。像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br></pre></td></tr></table></figure><p>通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();  </span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">buf.clear();  </span><br><span class="line">buf.put(newData.getBytes());  </span><br><span class="line">buf.flip();  </span><br><span class="line">while(buf.hasRemaining()) &#123;  </span><br><span class="line">   &lt;b&gt;sinkChannel.write(buf);&lt;/b&gt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a><strong>从管道读取数据</strong></h6><p>从读取管道的数据，需要访问source通道，像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure><p>调用source通道的read()方法来读取数据，像这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。 </p><h6 id="简单完整实例"><a href="#简单完整实例" class="headerlink" title="简单完整实例"></a>简单完整实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//获取管道</span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">//获取Sink 管道</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">//需要写入数据</span><br><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">//新建缓存区</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">//缓存区存放数据</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line">//获取Source 管道</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">ByteBuffer buf2 = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = sourceChannel.read(buf2);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = sourceChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">sourceChannel.close();</span><br><span class="line">sinkChannel.close();</span><br></pre></td></tr></table></figure><h4 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h4><h6 id="AIO的特点"><a href="#AIO的特点" class="headerlink" title="AIO的特点"></a><strong>AIO的特点</strong></h6><ul><li><p>读完了再通知我</p></li><li><p>不会加快IO，只是在读完后进行通知</p></li><li><p>使用回调函数，进行业务处理</p><p>​</p></li></ul><p>AIO的相关代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AsynchronousServerSocketChannel类</span><br><span class="line">server = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT));</span><br></pre></td></tr></table></figure><p>使用server上的accept方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; void accept(A attachment,CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt; handler);</span><br></pre></td></tr></table></figure><p>CompletionHandler为回调接口，当有客户端accept之后，就做handler中的事情。</p><h6 id="NIO与AIO区别"><a href="#NIO与AIO区别" class="headerlink" title="NIO与AIO区别"></a>NIO与AIO区别</h6><ul><li>NIO是同步非阻塞的，AIO是异步非阻塞的</li><li>由于NIO的读写过程依然在应用线程里完成，所以对于那些读写过程时间长的，NIO就不太适合。而AIO的读写过程完成后才被通知，所以AIO能够胜任那些重量级，读写过程长的任务。</li></ul><p><strong>结束语</strong></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h4><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a></p><p>【2】<a href="http://www.iteye.com/magazines/132-Java-NIO" target="_blank" rel="noopener">http://www.iteye.com/magazines/132-Java-NIO</a></p><p>【3】<a href="http://www.jb51.net/article/92448.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92448.htm</a></p><p>【4】<a href="http://www.cnblogs.com/good-temper/p/5003892.html" target="_blank" rel="noopener">http://www.cnblogs.com/good-temper/p/5003892.html</a></p><p>【5】<a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm" target="_blank" rel="noopener">http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm</a></p><p>【6】<a href="https://www.ibm.com/developerworks/cn/java/l-niosvr/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-niosvr/</a></p><p>【7】Netty权威指南</p><p>【8】<a href="http://ifeve.com/selectors/" target="_blank" rel="noopener">http://ifeve.com/selectors/</a></p><p>【9】<a href="http://ifeve.com/socket-channel/" target="_blank" rel="noopener">http://ifeve.com/socket-channel/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Typora for Markdown 快捷键</title>
    <link href="http://yoursite.com/2018/05/30/Typora-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2018/05/30/Typora-快捷键/</id>
    <published>2018-05-30T01:25:13.461Z</published>
    <updated>2018-05-30T11:10:38.829Z</updated>
    
    <content type="html"><![CDATA[<p>以前我写博客一直用的有道云笔记，前段时间突然了解到Typora这款软件功能的强大，于是就开始试着用，现在我已经彻底抛弃用了好几年的有道云，奉上一些我总结的最常用快捷键，初学者记住这些，就能流畅的写你的博客了！！！</p><h3 id="最快捷的方式"><a href="#最快捷的方式" class="headerlink" title="最快捷的方式"></a>最快捷的方式</h3><ul><li>鼠标右键。</li></ul><h3 id="操作快捷键"><a href="#操作快捷键" class="headerlink" title="操作快捷键"></a>操作快捷键</h3><table><thead><tr><th style="text-align:left">撤销</th><th style="text-align:left">Ctrl + Z</th></tr></thead><tbody><tr><td style="text-align:left">恢复</td><td style="text-align:left">Ctrl + Shift + Z</td></tr><tr><td style="text-align:left">查找</td><td style="text-align:left">Ctrl + F      (F3)</td></tr><tr><td style="text-align:left">替换</td><td style="text-align:left">Ctrl + H</td></tr><tr><td style="text-align:left">复制代码</td><td style="text-align:left">Ctrl + Shift + Z</td></tr><tr><td style="text-align:left">删除行</td><td style="text-align:left">Ctrl + Shift + L</td></tr></tbody></table><h3 id="语法快捷键"><a href="#语法快捷键" class="headerlink" title="语法快捷键"></a>语法快捷键</h3><table><thead><tr><th>标题</th><th>Ctrl + Alt + （0-6）</th></tr></thead><tbody><tr><td>标题调节</td><td>Ctrl + [（]）</td></tr><tr><td>表格</td><td>Ctrl + Alt + T</td></tr><tr><td>代码</td><td>Ctrl + Alt + C</td></tr><tr><td>数学公式</td><td>Ctrl + Alt + M</td></tr><tr><td>引用</td><td>Ctrl + Alt + Q</td></tr><tr><td>注脚</td><td>Ctrl + Alt + F</td></tr><tr><td>插入图片</td><td>Shift +Ctrl + I</td></tr><tr><td>删除线</td><td>Shift + Alt + 5</td></tr></tbody></table><table><thead><tr><th>链接</th><th>Ctrl + K</th></tr></thead><tbody><tr><td>加粗</td><td>Ctrl + B</td></tr><tr><td>斜体</td><td>Ctrl + I</td></tr><tr><td>下划线</td><td>Ctrl + U</td></tr><tr><td>清除格式</td><td>Ctrl + <code>\</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前我写博客一直用的有道云笔记，前段时间突然了解到Typora这款软件功能的强大，于是就开始试着用，现在我已经彻底抛弃用了好几年的有道云，奉上一些我总结的最常用快捷键，初学者记住这些，就能流畅的写你的博客了！！！&lt;/p&gt;
&lt;h3 id=&quot;最快捷的方式&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过zxing生成二维码</title>
    <link href="http://yoursite.com/2018/05/30/%E9%80%9A%E8%BF%87zxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://yoursite.com/2018/05/30/通过zxing生成二维码/</id>
    <published>2018-05-29T17:16:28.784Z</published>
    <updated>2018-05-30T02:43:42.442Z</updated>
    
    <content type="html"><![CDATA[<p>二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，<br>二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。</p><h3 id="1、二维码的生成"><a href="#1、二维码的生成" class="headerlink" title="1、二维码的生成"></a>1、二维码的生成</h3><p> 　　1.1 将Zxing-core.jar 包加入到classpath下。可通过github获取<a href="https://github.com/zxing" target="_blank" rel="noopener">https://github.com/zxing</a></p><p>　　 1.2 二维码的生成需要借助MatrixToImageWriter类，该类是由Google提供的，可以将该类拷贝到源码中，这里我将该类的源码贴上，可以直接使用。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.guoqick.zxing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">createQRCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">300</span>;</span><br><span class="line">        String format = <span class="string">"png"</span>;</span><br><span class="line">        String content = <span class="string">"www.guoqick.cn"</span>;</span><br><span class="line">        <span class="comment">//定义二维码的参数</span></span><br><span class="line">        HashMap hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">        hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);</span><br><span class="line">        hints.put(EncodeHintType.MARGIN, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, width, height, hints);</span><br><span class="line">            Path file = <span class="keyword">new</span> File(<span class="string">"E:/code/img.png"</span>).toPath();</span><br><span class="line">            MatrixToImageWriter.writeToPath(bitMatrix,format,file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、二维码的解析"><a href="#2、二维码的解析" class="headerlink" title="2、二维码的解析"></a>2、二维码的解析</h3><p>　　2.1 将Zxing-core.jar 包加入到classpath下。　　</p><p>　　2.2 和生成一样，我们需要一个辅助类（ BufferedImageLuminanceSource），同样该类Google也提供了，这里我同样将该类的源码贴出来，可以直接拷贝使用个，省去查找的麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">package cn.guoqick.zxing;</span><br><span class="line"></span><br><span class="line">import java.awt.Graphics2D;</span><br><span class="line">import java.awt.geom.AffineTransform;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line">import com.google.zxing.LuminanceSource;</span><br><span class="line"></span><br><span class="line">public class BufferedImageLuminanceSource extends LuminanceSource &#123;</span><br><span class="line"></span><br><span class="line">private final BufferedImage image;</span><br><span class="line">   private final int left;</span><br><span class="line">   private final int top;</span><br><span class="line"> </span><br><span class="line">   public BufferedImageLuminanceSource(BufferedImage image) &#123;</span><br><span class="line">     this(image, 0, 0, image.getWidth(), image.getHeight());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public BufferedImageLuminanceSource(BufferedImage image, int left, int top, int width, int height) &#123;</span><br><span class="line">     super(width, height);</span><br><span class="line"> </span><br><span class="line">     int sourceWidth = image.getWidth();</span><br><span class="line">     int sourceHeight = image.getHeight();</span><br><span class="line">     if (left + width &gt; sourceWidth || top + height &gt; sourceHeight) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Crop rectangle does not fit within image data.&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     for (int y = top; y &lt; top + height; y++) &#123;</span><br><span class="line">       for (int x = left; x &lt; left + width; x++) &#123;</span><br><span class="line">         if ((image.getRGB(x, y) &amp; 0xFF000000) == 0) &#123;</span><br><span class="line">           image.setRGB(x, y, 0xFFFFFFFF); // = white</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     this.image = new BufferedImage(sourceWidth, sourceHeight, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">     this.image.getGraphics().drawImage(image, 0, 0, null);</span><br><span class="line">     this.left = left;</span><br><span class="line">     this.top = top;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public byte[] getRow(int y, byte[] row) &#123;</span><br><span class="line">     if (y &lt; 0 || y &gt;= getHeight()) &#123;</span><br><span class="line">       throw new IllegalArgumentException(&quot;Requested row is outside the image: &quot; + y);</span><br><span class="line">     &#125;</span><br><span class="line">     int width = getWidth();</span><br><span class="line">     if (row == null || row.length &lt; width) &#123;</span><br><span class="line">       row = new byte[width];</span><br><span class="line">     &#125;</span><br><span class="line">     image.getRaster().getDataElements(left, top + y, width, 1, row);</span><br><span class="line">     return row;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public byte[] getMatrix() &#123;</span><br><span class="line">     int width = getWidth();</span><br><span class="line">     int height = getHeight();</span><br><span class="line">     int area = width * height;</span><br><span class="line">     byte[] matrix = new byte[area];</span><br><span class="line">     image.getRaster().getDataElements(left, top, width, height, matrix);</span><br><span class="line">     return matrix;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean isCropSupported() &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public LuminanceSource crop(int left, int top, int width, int height) &#123;</span><br><span class="line">     return new BufferedImageLuminanceSource(image, this.left + left, this.top + top, width, height);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean isRotateSupported() &#123;</span><br><span class="line">     return true;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public LuminanceSource rotateCounterClockwise() &#123;</span><br><span class="line"> </span><br><span class="line">       int sourceWidth = image.getWidth();</span><br><span class="line">     int sourceHeight = image.getHeight();</span><br><span class="line"> </span><br><span class="line">     AffineTransform transform = new AffineTransform(0.0, -1.0, 1.0, 0.0, 0.0, sourceWidth);</span><br><span class="line"> </span><br><span class="line">     BufferedImage rotatedImage = new BufferedImage(sourceHeight, sourceWidth, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"> </span><br><span class="line">     Graphics2D g = rotatedImage.createGraphics();</span><br><span class="line">     g.drawImage(image, transform, null);</span><br><span class="line">     g.dispose();</span><br><span class="line"> </span><br><span class="line">     int width = getWidth();</span><br><span class="line">     return new BufferedImageLuminanceSource(rotatedImage, top, sourceWidth - (left + width), getHeight(), width);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 编写解析二维码的实现代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">MultiFormatReader formatReader = new MultiFormatReader();</span><br><span class="line">String filePath = &quot;C:/Users/Administrator/Desktop/testImage/test.jpg&quot;;</span><br><span class="line">File file = new File(filePath);</span><br><span class="line">BufferedImage image = ImageIO.read(file);</span><br><span class="line">;</span><br><span class="line">LuminanceSource source = new BufferedImageLuminanceSource(image);</span><br><span class="line">Binarizer binarizer = new HybridBinarizer(source);</span><br><span class="line">BinaryBitmap binaryBitmap = new BinaryBitmap(binarizer);</span><br><span class="line">Map hints = new HashMap();</span><br><span class="line">hints.put(EncodeHintType.CHARACTER_SET, &quot;UTF-8&quot;);</span><br><span class="line">Result result = formatReader.decode(binaryBitmap, hints);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;result = &quot; + result.toString());</span><br><span class="line">System.out.println(&quot;resultFormat = &quot; + result.getBarcodeFormat());</span><br><span class="line">System.out.println(&quot;resultText = &quot; + result.getText());</span><br><span class="line"></span><br><span class="line">&#125;catch(</span><br><span class="line">Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整個二維碼生成及解析流程就結束了，喜歡的點點讚。。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二维码现在随处可见，在日常的开发中，也会经常涉及到二维码的生成，特别是开发一些活动或者推广方面的功能时，&lt;br&gt;二维码甚至成为必备功能点。本文介绍通过 google 的 zxing 包生成带 logo 的二维码的过程，供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;1、二维码的生成&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试重要知识点复习大纲</title>
    <link href="http://yoursite.com/2018/05/29/%E9%9D%A2%E8%AF%95%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <id>http://yoursite.com/2018/05/29/面试重要知识点复习大纲/</id>
    <published>2018-05-29T15:34:40.620Z</published>
    <updated>2018-05-30T01:22:41.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java基础部分"><a href="#一、Java基础部分" class="headerlink" title="一、Java基础部分"></a>一、Java基础部分</h2><p>​    1.数组中的排序问题(笔试或者机试，前者可能性更大)</p><p>​    2.面向对象的理解</p><p>​    3.集合相关的问题，比如hashmap跟hashtable的区别。搞清楚每个集合对象的特性就欧了。</p><p>​    4.多线程启动方式，以及产生死锁的原因和解决办法【多线程问题不是很常问，有精力就复习这块内容】</p><p>​    5.IO流，了解常见的几个流对象以及基本的流操作即可，被机试的可能性比较小。</p><h2 id="二、Web基础"><a href="#二、Web基础" class="headerlink" title="二、Web基础"></a>二、Web基础</h2><p>​    1.http协议(定义、常见的请求头以及响应头&lt;功能&gt;、状态码)</p><p>​    2.tomcat(目录结构&lt;存放的内容以及配置文件里面能做哪些工作&gt;、常见配置;有能力者可以了解一下tomcat的原理&lt;启动加载问题&gt;)</p><p>​    3.jdbc(编程步骤、与hibernate以及mybatis的区别)</p><p>​    4.servlet(概念的理解；生命周期、线程安全问题、接口相关类型、体系结构&lt;区别&gt;、request以及response的用途、servletContext对象的功能、编码以及路径问题)</p><p>​    5.filter(生命周期、常见应用、dofilter里面的参数、应用场景)</p><p>​    6.jsp(隐式对象、常见标签&lt;指令、动作&gt;、EL以及JSTL)</p><p>​    7.cookie/session(概念的理解；生命周期，session创建的时期，相关方法的使用)</p><h2 id="三、五大框架"><a href="#三、五大框架" class="headerlink" title="三、五大框架"></a>三、五大框架</h2><p>​    1.struts2(action相关的问题&lt;书写方式[区别]、接受请求参数的方式、相关配置、访问servletAPI的方式&gt;；值栈相 关问题&lt;定义、内部结构、如何获取值栈对象、EL为什么能访问值栈中的数据&gt;；struts2与springMVC的区别；拦截器与过滤器的 区别；struts2工作原理&lt;执行流程&gt;)</p><p>​    2.hibernate(核心思想要了解；开发流程&lt;加载文件的过程&gt;；查询方式；如何优化；sql与hql的区别；update与 saveOrUpdate的区别；get和load的区别；Java对象三种状态的特征以及转换、核心API、一级缓存和二级缓存、延迟加载)</p><p>​    3.spring(springIOC和DI；生命周期；Bean注入属性的方式；aop极其相关名词解释；核心类；applicationContext与beanFactory的区别；bean实例化有哪些方式)</p><p>   4.springMVC(工作流程；与struts2的区别；乱码问题如何处理；各组件的扩展类型)</p><p>​    5.mybatis(与jdbc/hibernate的区别；)</p><h2 id="四、脚本"><a href="#四、脚本" class="headerlink" title="四、脚本"></a>四、脚本</h2><p>​    1.JavaScript核心对象</p><p>​    2.浏览器BOM对象</p><p>​    3.文档对象模型DOM</p><p>​    4.常见事件</p><p>​    5.Ajax编程(web交互2种方式的对比)</p><p>​    6.传统Ajax编程的步骤以及从服务器端返回的数据格式(之间的差别)</p><p>​    7.JSON数据格式的转换操作</p><p>​    8.jQuery选择器</p><p>​    9.jQuery的Ajax编程(常见方法)</p><p>​    10.其余的问题都是一些笔试题，让你直接写javascript代码实现某一功能</p><h2 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h2><p>​    数据库这一块几乎都是一些概念性的问答题(存储过程、函数、事务、索引、触发器、视图、游标以及一些优化操作),笔试100%会出现，一般考察的都是多表联合查询</p><h2 id="六、人事相关"><a href="#六、人事相关" class="headerlink" title="六、人事相关"></a>六、人事相关</h2><p>​    1.自我介绍(注重的是你之前在公司里面工作内容，特别是最近在公司里面做的项目&lt;回答思路参考项目相关问题一&gt;)</p><p>​    2.简单的介绍一下上一家公司的情况/评价</p><p>​    3.你为什么来北京工作，怎样看待跳槽？</p><p>​    4.你对我们公司了解吗？</p><p>​    5.你如果有幸进入我们公司，有什么规划吗？</p><p>​    6.你上一家公司的薪资大概是多少？有哪些组成部分？</p><p>​    7.你有没有投其它公司？如果其它公司也给了offer，你会如何抉择？</p><p>​    8.你有对象吗？打算什么时候结婚生孩子？</p><p>​    9.你对薪资待遇有什么要求？能再低一点吗？</p><p>​    10.你还有什么问题要问我吗？</p><h2 id="七、项目相关"><a href="#七、项目相关" class="headerlink" title="七、项目相关"></a>七、项目相关</h2><p>​    1.请介绍一下你最近做的这一个项目吧【思路：项目给谁做的、项目涉及的领域、系统的架构(功能&amp;技术)、系统的用途、系统的部署、使用了哪些比较新颖的技术】</p><p>​    2.谈谈你对电商行业的了解【思路：电商行业的发展、行业技术特点、行业的一些概念】</p><p>​    3.你这个项目大概有哪些功能，你负责了哪些核心功能？【拥有的功能尽可能说多一点，建议10个左右，自己负责的3个大(如商品管理、订单、购物车)，其余的都是其他组员开发的任务】</p><p>​    4.谈谈xx(具体的，比如商品管理、订单、购物车)模块/功能的实现思路？实现的过程中涉及到了哪些技术，这些技术能介绍下吗？【可参考“02_电商项目面试问题”里面的答案】</p><p>​    5.你们公司有多少人？有测试吗？有美工吗？整个项目组人员配置是怎么样的？项目开发的流程大概是什么样子的？【检验是否有工作经验的一个问题】</p><p>​    6.这个项目使用了什么构建工具没有？有的话，多模块之间是如何划分的？为什么要这么划分？</p><p>​    7.在这个项目中是如何设计商品规格的？</p><p>​    8.这个系统中你是如何实现跨系统调用的？  </p><p>​    9.在这个项目中，CMS系统是如何设计的，简单的说一下设计思路</p><p>​    10.在这个项目中，你们主要使用什么样的数据格式来进行数据的传输的？</p><p>​    11.单点系统的设计思想你了解吗？他在系统架构中的作用是什么？位置如何？</p><p>​    12.你们这个项目中订单ID是怎么生成的？我们公司最近打算做一个电商项目，如果让你设计这块，你会考虑哪些问题？</p><p>​    13.各个服务器的时间不统一怎么办？</p><p>​    14.你们线上部署时什么样的，能画一下吗？<br>    15.你们生产环境的服务器有多少台？    </p><p>   16.你们使用什么做支付的？如果使用易宝做支付，请求超时了怎么处理？    </p><p>   17.你刚才不是说付款成功后易宝会有数据返回吗？如果付款后易宝没有返回，或者返回超时了，但是钱又已经扣了，你怎么办？<br>    18.你们怎么做退款功能的，要多长时间才能把钱退回给用户？<br>    19.你购物车存cookie里边可以实现不登录就可以使用购物车，那么我现在没有登录把商品存购物车了，然后登录了， 然后我换台电脑并且登录了还能不能看见我购物车的信息？如果看不到怎么做到cookie同步，就是在另外一台电脑上可以看到购物车信息<br>    20.如果用户一直向购物车添加商品怎么办？并且他添加一次你查询一次数据库？互联网上用户那么多，这样会对数据库造成很大压力你怎么办？</p><p>   21.购物车的设计细节问题</p><h2 id="八、其他技术问题"><a href="#八、其他技术问题" class="headerlink" title="八、其他技术问题"></a>八、其他技术问题</h2><p>   1.权限控制(一般情况，在公司必须有一定工作经验的开发者才会被分配该功能模块的开发，这意味着学员在刚开始参加工作的那个项目里面绝对不能写的内容。) 这里一般都会提及shiro技术，在这块需要掌握shiro相关的几个组件以及他们的调用关系，然后就是权限设计的几张数据库表(表之间的关系以及每张表里面的重要字段)</p><p>   2.搜索系统(普通的查询会让面试官问及效率问题，那么势必要提到全文检索技术，由于刚学不是很熟，根据自己掌握的情况进行选择)   </p><p>​    3.浏览器跨域问题(前台系统调用可以使用jsonp来实现浏览器跨域问题，去年有学员花几个小时学习这个，仅凭此技术入职8K。)</p><p>​    4.webservice(该技术已有替代技术，如果不会，可以不用花时间去复习)</p><p>​    5.Linux(水太深，只谈自己在项目中就部署的时候用了一下即可)</p><p>​    6.redis(根据自己的能力看是否需要提及次技术，毕竟购物车的实现方式比较多。)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Java基础部分&quot;&gt;&lt;a href=&quot;#一、Java基础部分&quot; class=&quot;headerlink&quot; title=&quot;一、Java基础部分&quot;&gt;&lt;/a&gt;一、Java基础部分&lt;/h2&gt;&lt;p&gt;​    1.数组中的排序问题(笔试或者机试，前者可能性更大)&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java程序员面试99问</title>
    <link href="http://yoursite.com/2018/05/15/java%E9%9D%A2%E8%AF%9599%E9%97%AE/"/>
    <id>http://yoursite.com/2018/05/15/java面试99问/</id>
    <published>2018-05-15T09:25:37.780Z</published>
    <updated>2018-05-30T01:22:11.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h5 id="String-StringBuffer-与-StringBuilder的区别"><a href="#String-StringBuffer-与-StringBuilder的区别" class="headerlink" title="String , StringBuffer 与 StringBuilder的区别"></a><strong>String , StringBuffer 与 StringBuilder的区别</strong></h5><p>这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。</p><p><strong>面试管：</strong>String , StringBuffer 与 StringBuilder之间有什么区别吗？</p><p><strong>你的回答：</strong></p><p>对于字符串拼接：</p><p><strong>性能方面：</strong>StringBuilder &gt; StringBuffer &gt; String（+）（for循环里面字符串拼接）</p><p><strong>线程安全：</strong>StringBuilder （非线程安全，速度快），StringBuffer （线程安全，速度慢）</p><p><strong>如何选择：</strong>StringBuilder （方法内，无线程安全问题），StringBuffer （有线程安全问题，使用它）</p><p>3点建议：（加分项）</p><ul><li>当你连接 2 或 3 个String时，使用String.concat()。</li><li>如果你要连接多于3个String（不含3）,并且你能够精确预测出最终结果的长度，使用StringBuilder/StringBuffer，并设定初始化容量。</li><li>如果你要连接多于3个String（不含3）,并且你不能够精确预测出最终结果的长度，使用StringBundler。</li></ul><p>【1】<a href="http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html" target="_blank" rel="noopener">http://www.cnblogs.com/A_ming/archive/2010/04/13/1711395.html</a></p><p>面试官继续问题：</p><p>StringBuffer 为什么是线程安全的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//StringBuffer源码</span><br><span class="line">/**</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public synchronized void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)&#123;</span><br><span class="line">    super.getChars(srcBegin, srcEnd, dst, dstBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试官可能还会继续问：</p><p>为什么加 synchronized 这个关键字，就是线程安全的呢？</p><h5 id="Vector，ArrayList，LinkedList的区别"><a href="#Vector，ArrayList，LinkedList的区别" class="headerlink" title="Vector，ArrayList，LinkedList的区别"></a><strong>Vector，ArrayList，LinkedList的区别</strong></h5><p>一、同步性 </p><p>ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。 </p><p>二、数据增长<br>从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 </p><p>三、检索、插入、删除对象的效率 </p><p>ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。<br>LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。 </p><p>一般大家都知道ArrayList和LinkedList的大致区别：<br>​     1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>​     2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>​     3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 </p><h5 id="List如何去除重复数据"><a href="#List如何去除重复数据" class="headerlink" title="List如何去除重复数据"></a><strong>List如何去除重复数据</strong></h5><p>【1】<a href="http://www.2cto.com/kf/201708/664237.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201708/664237.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AAAA AAAA BBBB BBBB CCCC CCCC CCCC CCCC</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;DDDD&quot;);</span><br><span class="line">         new Test().removeDuplicateWithOrder(list);</span><br><span class="line">//      System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 删除ArrayList中重复元素</span><br><span class="line">public static void removeDuplicate(List list) &#123;</span><br><span class="line">    for (int i = 0; i &lt; list.size() - 1; i++) &#123;</span><br><span class="line">        for (int j = list.size() - 1; j &gt; i; j--) &#123;</span><br><span class="line">               if (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">                  list.remove(j);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法二：通过HashSet剔除</span><br><span class="line">      // 删除ArrayList中重复元素,add进去顺序就变了不考虑顺序的话可以使用</span><br><span class="line">public static void removeDuplicate1(List list) &#123;</span><br><span class="line">         HashSet h = new HashSet(list);</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(h);</span><br><span class="line">         System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法三： 删除ArrayList中重复元素，保持顺序</span><br><span class="line">      // 删除ArrayList中重复元素，保持顺序</span><br><span class="line">public static void removeDuplicateWithOrder(List list) &#123;</span><br><span class="line">         Set set = new HashSet();</span><br><span class="line">         List newList = new ArrayList();</span><br><span class="line">         for (Iterator iter = list.iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Object element = iter.next();</span><br><span class="line">            if (set.add(element))</span><br><span class="line">               newList.add(element);</span><br><span class="line">         &#125;</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(newList);</span><br><span class="line">         System.out.println(&quot; remove duplicate &quot; + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自己手动实现一个线程池"><a href="#自己手动实现一个线程池" class="headerlink" title="自己手动实现一个线程池"></a><strong>自己手动实现一个线程池</strong></h5><p>【1】<a href="http://blog.csdn.net/w2393040183/article/details/52177572" target="_blank" rel="noopener">http://blog.csdn.net/w2393040183/article/details/52177572</a></p><h5 id="Java字节流和字符流的区别"><a href="#Java字节流和字符流的区别" class="headerlink" title="Java字节流和字符流的区别"></a><strong>Java字节流和字符流的区别</strong></h5><p>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</p><ul><li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li><li>字节流默认不使用缓冲区；字符流使用缓冲区。</li><li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li></ul><p>所以对于字节流和字符流的选择，我们建议：在开发中尽量都去使用字节流进行操作，因为字节流可以处理图片、音乐、文字，也可以方便进行传输或者文字的编码转换；如果在处理中文的使用考虑字符流。</p><p>【1】<a href="http://bbs.itheima.com/thread-277923-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-277923-1-1.html</a></p><h5 id="多线程实现生产者-消费者模式"><a href="#多线程实现生产者-消费者模式" class="headerlink" title="多线程实现生产者/消费者模式"></a><strong>多线程实现生产者/消费者模式</strong></h5><h5 id="在Java中什么是线程调度？"><a href="#在Java中什么是线程调度？" class="headerlink" title="在Java中什么是线程调度？"></a><strong>在Java中什么是线程调度？</strong></h5><h5 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a><strong>线程与进程的区别？</strong></h5><p><a href="http://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="noopener">http://blog.csdn.net/yaosiming2011/article/details/44280797</a></p><p><strong>死锁与活锁区别，死锁与饥饿的区别？</strong></p><p><a href="http://www.cnblogs.com/lance43990740/p/6853631.html" target="_blank" rel="noopener">http://www.cnblogs.com/lance43990740/p/6853631.html</a></p><h5 id="在线程中你怎么处理不可捕捉异常"><a href="#在线程中你怎么处理不可捕捉异常" class="headerlink" title="在线程中你怎么处理不可捕捉异常"></a><strong>在线程中你怎么处理不可捕捉异常</strong></h5><p>【1】<a href="http://blog.csdn.net/Dxx23/article/details/44775735" target="_blank" rel="noopener">http://blog.csdn.net/Dxx23/article/details/44775735</a></p><p><strong>多线程上下文切换</strong></p><p>【1】<a href="http://www.cnblogs.com/szlbm/p/5505707.html" target="_blank" rel="noopener">http://www.cnblogs.com/szlbm/p/5505707.html</a></p><h5 id="HashTable，HashMap，TreeMap的区别"><a href="#HashTable，HashMap，TreeMap的区别" class="headerlink" title="HashTable，HashMap，TreeMap的区别"></a><strong>HashTable，HashMap，TreeMap的区别</strong></h5><p>【1】<a href="http://blog.csdn.net/natian306/article/details/10858097" target="_blank" rel="noopener">http://blog.csdn.net/natian306/article/details/10858097</a></p><p>【2】<a href="http://www.cnblogs.com/tengpan-cn/p/5909395.html" target="_blank" rel="noopener">http://www.cnblogs.com/tengpan-cn/p/5909395.html</a></p><h5 id="IO-BIO-NIO-AIO编程模型"><a href="#IO-BIO-NIO-AIO编程模型" class="headerlink" title="IO,BIO,NIO,AIO编程模型"></a>IO,BIO,NIO,AIO编程模型</h5><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a><br>【2】<a href="http://blog.csdn.net/jiaomingliang/article/details/47684713" target="_blank" rel="noopener">http://blog.csdn.net/jiaomingliang/article/details/47684713</a></p><p>如果你想吃一份宫保鸡丁盖饭： </p><p>同步阻塞：你到饭馆点餐，然后在那<br>等着，还要一边喊：好了没啊！ </p><p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p><p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p><p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p><h5 id="TreeMap实现原理"><a href="#TreeMap实现原理" class="headerlink" title="TreeMap实现原理"></a><strong>TreeMap实现原理</strong></h5><p><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/26668941</a></p><h5 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a><strong>HashMap实现原理</strong></h5><p><a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">http://blog.csdn.net/vking_wang/article/details/14166593</a></p><h5 id="如何判断一棵树-tree-是对称的"><a href="#如何判断一棵树-tree-是对称的" class="headerlink" title="如何判断一棵树(tree)是对称的"></a><strong>如何判断一棵树(tree)是对称的</strong></h5><p>【1】<a href="http://blog.csdn.net/yangmm2048/article/details/45689561" target="_blank" rel="noopener">http://blog.csdn.net/yangmm2048/article/details/45689561</a></p><h5 id="如何生成全球唯一的编码"><a href="#如何生成全球唯一的编码" class="headerlink" title="如何生成全球唯一的编码"></a><strong>如何生成全球唯一的编码</strong></h5><h5 id="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"><a href="#关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。" class="headerlink" title="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"></a>关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</h5><h5 id="map实现按照key字典排序，并且按照顺序打印key-和-value"><a href="#map实现按照key字典排序，并且按照顺序打印key-和-value" class="headerlink" title="map实现按照key字典排序，并且按照顺序打印key 和 value?"></a><strong>map实现按照key字典排序，并且按照顺序打印key 和 value?</strong></h5><p>【1】<a href="http://blog.csdn.net/bwgang/article/details/7879563" target="_blank" rel="noopener">http://blog.csdn.net/bwgang/article/details/7879563</a></p><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h5><h5 id="syschronized实现原理"><a href="#syschronized实现原理" class="headerlink" title="syschronized实现原理"></a><strong>syschronized实现原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p><h5 id="syschronized与重入锁ReenTrantLock的区别"><a href="#syschronized与重入锁ReenTrantLock的区别" class="headerlink" title="syschronized与重入锁ReenTrantLock的区别"></a><strong>syschronized与重入锁ReenTrantLock的区别</strong></h5><p>可重入性：<br>从名字上理解，ReenTrantLock的字面意思就是再进入<br>的锁，其实synchronized关键字所使用的锁也是可重<br>入的，两者关于这个的区别不大。两者都是同<br>一个线程每次进入一次，锁的计数器都自增1，<br>所以要等到锁的计数器下降为0时才能释放锁。<br>三.synchronized和ReentrantLock的区别<br>除了synchronized的功能,多了三个高级功能.<br>等待可中断,公平锁,绑定多个Condition.</p><ul><li>1.等待可中断<br>在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.   tryLock(long timeout, TimeUnit unit)</li><li>2.公平锁按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.    new RenentrantLock(boolean fair)</li><li>3.绑定多个Condition<br>通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();</li></ul><h5 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><strong>Java多线程</strong></h5><ul><li><p>wait（），notify（）和notifyAll（）</p><p>​</p></li></ul><h5 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a><strong>抽象类与接口的区别</strong></h5><p>【1】<a href="http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html" target="_blank" rel="noopener">http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html</a></p><h5 id="equals-hashcode"><a href="#equals-hashcode" class="headerlink" title="equals hashcode "></a><strong>equals hashcode </strong></h5><p>【1】<a href="http://blog.csdn.net/ftx2540993425/article/details/51206130" target="_blank" rel="noopener">http://blog.csdn.net/ftx2540993425/article/details/51206130</a><br>【2】<a href="http://www.cnblogs.com/Qian123/p/5703507.html" target="_blank" rel="noopener">http://www.cnblogs.com/Qian123/p/5703507.html</a></p><h5 id="lambda优点"><a href="#lambda优点" class="headerlink" title="lambda优点"></a><strong>lambda优点</strong></h5><p>【1】<a href="http://developer.51cto.com/art/201304/387681.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201304/387681.htm</a></p><h5 id="关键字transient"><a href="#关键字transient" class="headerlink" title="关键字transient"></a><strong>关键字transient</strong></h5><p>【1】<a href="http://blog.csdn.net/d12345678a/article/details/54178659" target="_blank" rel="noopener">http://blog.csdn.net/d12345678a/article/details/54178659</a></p><h5 id="JDK和JRE的区别是什么"><a href="#JDK和JRE的区别是什么" class="headerlink" title="JDK和JRE的区别是什么"></a><strong>JDK和JRE的区别是什么</strong></h5><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程 序。</p><p>JDK中包含JRE，JRE中包含JVM。</p><p>JDK中包含的JRE主要是为JDK自带的开发工具提供运行环境，与JDK并列的那个JRE是为用户编写的JAVA代码提供运行环境的。</p><p>classpath配置的是JDK的lib目录，path配置的是JDK的bin目录。</p><h5 id="Java到底是不是一种纯面向对象语言？"><a href="#Java到底是不是一种纯面向对象语言？" class="headerlink" title="Java到底是不是一种纯面向对象语言？"></a><strong>Java到底是不是一种纯面向对象语言？</strong></h5><p>【1】<a href="https://news.cnblogs.com/n/548327/" target="_blank" rel="noopener">https://news.cnblogs.com/n/548327/</a></p><h5 id="HTTP请求的header头解析"><a href="#HTTP请求的header头解析" class="headerlink" title="HTTP请求的header头解析"></a><strong>HTTP请求的header头解析</strong></h5><p><a href="http://blog.csdn.net/hufan11100914/article/details/48029633" target="_blank" rel="noopener">http://blog.csdn.net/hufan11100914/article/details/48029633</a></p><h5 id="如何判断一个对象已经被回收"><a href="#如何判断一个对象已经被回收" class="headerlink" title="如何判断一个对象已经被回收"></a><strong>如何判断一个对象已经被回收</strong></h5><p>【1】<a href="http://blog.csdn.net/canot/article/details/51037938" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51037938</a></p><h5 id="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗"><a href="#假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗" class="headerlink" title="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)"></a><strong>假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)</strong></h5><h5 id="有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…"><a href="#有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…" class="headerlink" title="有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…"></a><strong>有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…</strong></h5><h5 id="两个有序数组合并为一个有序数组"><a href="#两个有序数组合并为一个有序数组" class="headerlink" title="两个有序数组合并为一个有序数组"></a><strong>两个有序数组合并为一个有序数组</strong></h5><p>【1】<a href="http://www.cnblogs.com/A_ming/archive/2010/04/15/1712313.html" target="_blank" rel="noopener">http://www.cnblogs.com/A_ming/archive/2010/04/15/1712313.html</a></p><h5 id="JAVA值类型和引用类型的区别"><a href="#JAVA值类型和引用类型的区别" class="headerlink" title="JAVA值类型和引用类型的区别"></a><strong>JAVA值类型和引用类型的区别</strong></h5><p>【1】<a href="http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html" target="_blank" rel="noopener">http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html</a></p><h5 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a><strong>基本类型转换</strong></h5><p>【1】<a href="http://blog.csdn.net/u011583105/article/details/16349095" target="_blank" rel="noopener">http://blog.csdn.net/u011583105/article/details/16349095</a></p><h5 id="递归算法笔试题"><a href="#递归算法笔试题" class="headerlink" title="递归算法笔试题"></a><strong>递归算法笔试题</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> * 一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少， 用递归算法实现。</span><br><span class="line"> **/</span><br><span class="line">static int find30(int n)&#123;</span><br><span class="line">        if (n &lt;= 0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(n &gt; 0 &amp;&amp; n &lt;= 2)</span><br><span class="line">            return 1;</span><br><span class="line">        return find30(n-1)+find30(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="内存泄漏和内存溢出区别"><a href="#内存泄漏和内存溢出区别" class="headerlink" title="内存泄漏和内存溢出区别"></a><strong>内存泄漏和内存溢出区别</strong></h5><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。</p><p>【1】<a href="http://blog.csdn.net/buutterfly/article/details/6617375" target="_blank" rel="noopener">http://blog.csdn.net/buutterfly/article/details/6617375</a></p><h5 id="内存溢出和内存泄漏的原因"><a href="#内存溢出和内存泄漏的原因" class="headerlink" title="内存溢出和内存泄漏的原因"></a><strong>内存溢出和内存泄漏的原因</strong></h5><p>【1】<a href="http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html" target="_blank" rel="noopener">http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html</a></p><p>【2】<a href="http://blog.csdn.net/anxpp/article/details/51325838" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51325838</a></p><p>【3】<a href="http://blog.csdn.net/shanyu1198124123/article/details/52414392" target="_blank" rel="noopener">http://blog.csdn.net/shanyu1198124123/article/details/52414392</a></p><h5 id="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"><a href="#子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次" class="headerlink" title="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"></a>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次</h5><p>【1】<a href="http://www.cnblogs.com/ysloong/p/6370104.html" target="_blank" rel="noopener">http://www.cnblogs.com/ysloong/p/6370104.html</a></p><h5 id="condition的作用"><a href="#condition的作用" class="headerlink" title="condition的作用"></a><strong>condition的作用</strong></h5><p>【1】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p><h5 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"></a><strong>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</strong></h5><h5 id="Java多线程中join方法的理解"><a href="#Java多线程中join方法的理解" class="headerlink" title="Java多线程中join方法的理解"></a>Java多线程中join方法的理解</h5><p>【1】<a href="http://uule.iteye.com/blog/1101994" target="_blank" rel="noopener">http://uule.iteye.com/blog/1101994</a></p><h5 id="equals-与-hashcode"><a href="#equals-与-hashcode" class="headerlink" title="equals() 与 hashcode()"></a><strong>equals() 与 hashcode()</strong></h5><h5 id="Lock接口比synchronized块的优势是什么"><a href="#Lock接口比synchronized块的优势是什么" class="headerlink" title="Lock接口比synchronized块的优势是什么"></a><strong>Lock接口比synchronized块的优势是什么</strong></h5><h5 id="java中wait和sleep方法的不同"><a href="#java中wait和sleep方法的不同" class="headerlink" title="java中wait和sleep方法的不同"></a><strong>java中wait和sleep方法的不同</strong></h5><p>最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><p>【1】<a href="http://blog.csdn.net/clam_clam/article/details/6803667" target="_blank" rel="noopener">http://blog.csdn.net/clam_clam/article/details/6803667</a></p><p><strong>用Java实现阻塞队列</strong></p><p>【1】<a href="http://blog.csdn.net/chenchaofuck1/article/details/51660119" target="_blank" rel="noopener">http://blog.csdn.net/chenchaofuck1/article/details/51660119</a></p><p>【2】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p><p><strong>java中volatile关键字理解</strong></p><p>【1】<a href="http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html" target="_blank" rel="noopener">http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html</a></p><p>【2】<a href="http://www.infoq.com/cn/articles/java-memory-model-4/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-memory-model-4/</a></p><p>区别：</p><p>  一、volatile是变量修饰符，而synchronized则作用于一段代码或方法。</p><p> 二、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源</p><h5 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a><strong>什么是竞争条件？你怎样发现和解决竞争？</strong></h5><p>【1】<a href="http://blog.csdn.net/hourui93/article/details/48596259" target="_blank" rel="noopener">http://blog.csdn.net/hourui93/article/details/48596259</a></p><h5 id="你将如何使用thread-dump？你将如何分析Thread-dump"><a href="#你将如何使用thread-dump？你将如何分析Thread-dump" class="headerlink" title="你将如何使用thread dump？你将如何分析Thread dump"></a><strong>你将如何使用thread dump？你将如何分析Thread dump</strong></h5><p>【1】<a href="http://blog.csdn.net/rachel_luo/article/details/8920596" target="_blank" rel="noopener">http://blog.csdn.net/rachel_luo/article/details/8920596</a></p><h5 id="在Java中CycliBarriar和CountdownLatch有什么区别"><a href="#在Java中CycliBarriar和CountdownLatch有什么区别" class="headerlink" title="在Java中CycliBarriar和CountdownLatch有什么区别"></a><strong>在Java中CycliBarriar和CountdownLatch有什么区别</strong></h5><p>【1】<a href="http://blog.csdn.net/kjfcpua/article/details/7300286" target="_blank" rel="noopener">http://blog.csdn.net/kjfcpua/article/details/7300286</a></p><h5 id="Java并发编程-Executor框架集"><a href="#Java并发编程-Executor框架集" class="headerlink" title="Java并发编程-Executor框架集"></a><strong>Java并发编程-Executor框架集</strong></h5><p>【1】<a href="http://www.cnblogs.com/MOBIN/p/5436482.html" target="_blank" rel="noopener">http://www.cnblogs.com/MOBIN/p/5436482.html</a></p><h5 id="对象的四种引用类型"><a href="#对象的四种引用类型" class="headerlink" title="对象的四种引用类型"></a><strong>对象的四种引用类型</strong></h5><p>【1】<a href="http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html</a></p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h3><p>【1】<a href="http://www.importnew.com/15851.html#ioc_di" target="_blank" rel="noopener">http://www.importnew.com/15851.html#ioc_di</a></p><p><strong>Spring好在哪里</strong></p><p> 轻量：Spring 是轻量的，基本的版本大约2MB。<br> 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br> 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br> 容器：Spring 包含并管理应用中对象的生命周期和配置。<br> MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br> 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br> 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p><h5 id="spring-实现日志管理"><a href="#spring-实现日志管理" class="headerlink" title="spring 实现日志管理"></a><strong>spring 实现日志管理</strong></h5><h5 id="Spring框架有哪些主要模块"><a href="#Spring框架有哪些主要模块" class="headerlink" title="Spring框架有哪些主要模块**"></a>Spring框架有哪些主要模块**</h5><h5 id="控制反转-IOC-？什么是依赖注入（DI）"><a href="#控制反转-IOC-？什么是依赖注入（DI）" class="headerlink" title="控制反转(IOC)？什么是依赖注入（DI）?"></a><strong>控制反转(IOC)？什么是依赖注入（DI）?</strong></h5><h5 id="IOC-DI-原理"><a href="#IOC-DI-原理" class="headerlink" title="IOC(DI)原理"></a><strong>IOC(DI)原理</strong></h5><h5 id="依然注入三种实现方式"><a href="#依然注入三种实现方式" class="headerlink" title="依然注入三种实现方式"></a><strong>依然注入三种实现方式</strong></h5><h5 id="Spring-Bean作用域之间的区别"><a href="#Spring-Bean作用域之间的区别" class="headerlink" title="Spring Bean作用域之间的区别"></a><strong>Spring Bean作用域之间的区别</strong></h5><h5 id="Spring有几种配置方式"><a href="#Spring有几种配置方式" class="headerlink" title="Spring有几种配置方式"></a><strong>Spring有几种配置方式</strong></h5><ul><li>基于XML的配置</li><li>基于注解的配置</li><li>基于Java的配置</li></ul><h5 id="请解释Spring-Bean的生命周期"><a href="#请解释Spring-Bean的生命周期" class="headerlink" title="请解释Spring Bean的生命周期"></a><strong>请解释Spring Bean的生命周期</strong></h5><h5 id="自动装配模式的区别"><a href="#自动装配模式的区别" class="headerlink" title="自动装配模式的区别"></a><strong>自动装配模式的区别</strong></h5><h5 id="如何开启基于注解的自动装配"><a href="#如何开启基于注解的自动装配" class="headerlink" title="如何开启基于注解的自动装配"></a><strong>如何开启基于注解的自动装配</strong></h5><h5 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a><strong>Spring框架中有哪些不同类型的事件</strong></h5><h5 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a><strong>BeanFactory和ApplicationContext有什么区别</strong></h5><h5 id="三种较常见的-ApplicationContext-实现方式"><a href="#三种较常见的-ApplicationContext-实现方式" class="headerlink" title="三种较常见的 ApplicationContext 实现方式"></a><strong>三种较常见的 ApplicationContext 实现方式</strong></h5><ul><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li><li>XmlWebApplicationContext</li></ul><h5 id="如何用基于Java配置的方式配置Spring"><a href="#如何用基于Java配置的方式配置Spring" class="headerlink" title="如何用基于Java配置的方式配置Spring"></a><strong>如何用基于Java配置的方式配置Spring</strong></h5><p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。</p><h5 id="Spring中注入一个Java-Collection"><a href="#Spring中注入一个Java-Collection" class="headerlink" title="Spring中注入一个Java Collection"></a><strong>Spring中注入一个Java Collection</strong></h5><p><list> :   该标签用来装配可重复的list值。</list></p><p><set> :    该标签用来装配没有重复的set值。</set></p><p><map>:   该标签可用来注入键和值可以为任何类型的键值对。</map></p><p><props> : 该标签支持注入键和值都是字符串类型的键值对。</props></p><h5 id="FileSystemResource和ClassPathResource有何区别"><a href="#FileSystemResource和ClassPathResource有何区别" class="headerlink" title="FileSystemResource和ClassPathResource有何区别"></a><strong>FileSystemResource和ClassPathResource有何区别</strong></h5><h5 id="Spring-框架中都用到了哪些设计模式"><a href="#Spring-框架中都用到了哪些设计模式" class="headerlink" title="Spring 框架中都用到了哪些设计模式"></a><strong>Spring 框架中都用到了哪些设计模式</strong></h5><ul><li>代理模式—在AOP和remoting中被用的比较多。</li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例。</li></ul><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h3><h3 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a><strong>Struts</strong></h3><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h3><p><strong>Post，Get区别</strong></p><p>Session, Cookie区别</p><p>Servlet的生命周期</p><p>HTTP 报文包含内容<br>简述三次握手和四次挥手</p><p>TCP是TCP/IP的第三层传输层，对应OSI的第四层传输层；<br>IP是TCP/IP的第二层互联层，对应OSI的第三层网络层。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><h5 id="postgresql数据库比mysql好在哪里？"><a href="#postgresql数据库比mysql好在哪里？" class="headerlink" title="postgresql数据库比mysql好在哪里？"></a><strong>postgresql数据库比mysql好在哪里？</strong></h5><p>【1】<a href="http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html</a></p><h5 id="数据库的左连接，右连接，内连接，外连接"><a href="#数据库的左连接，右连接，内连接，外连接" class="headerlink" title="数据库的左连接，右连接，内连接，外连接"></a><strong>数据库的左连接，右连接，内连接，外连接</strong></h5><p>【1】<a href="http://blog.csdn.net/zj972535075/article/details/50364813" target="_blank" rel="noopener">http://blog.csdn.net/zj972535075/article/details/50364813</a></p><h5 id="数据库四个范式"><a href="#数据库四个范式" class="headerlink" title="数据库四个范式"></a><strong>数据库四个范式</strong></h5><p>【1】<a href="http://blog.csdn.net/famousdt/article/details/6921622" target="_blank" rel="noopener">http://blog.csdn.net/famousdt/article/details/6921622</a><br>【2】<a href="http://www.jb51.net/article/19312.htm" target="_blank" rel="noopener">http://www.jb51.net/article/19312.htm</a></p><h5 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a><strong>数据库事务隔离级别</strong></h5><p>四个事务隔离级别概念和脏读、不可重复读、幻读这几类问题的概念。</p><ul><li>Read uncommitted</li><li>Read committed</li><li>Repeatable read</li><li>Serializable<br>这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li></ul><p>【1】<a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">http://blog.csdn.net/fg2006/article/details/6937413</a></p><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><strong>乐观锁和悲观锁</strong></h5><p>乐观锁和悲观锁的概念，乐观锁实现：第一种是使用版本号（hibernate乐观锁），第二种是使用时间戳。</p><p>【１】<a href="http://www.cnblogs.com/wang-meng/p/5506943.html" target="_blank" rel="noopener">http://www.cnblogs.com/wang-meng/p/5506943.html</a></p><h5 id="排他锁、共享锁"><a href="#排他锁、共享锁" class="headerlink" title="排他锁、共享锁"></a><strong>排他锁、共享锁</strong></h5><p>排他锁概念：<br><strong>注意：</strong>排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。</p><p>共享锁概念：<br><strong>注意：</strong>一个事务获取了共享锁，在其他查询中也只能加共享锁或不加锁。</p><p><strong>注意：</strong>排他锁与共享锁不能存在同一数据上。</p><p>【1】<a href="http://blog.csdn.net/c466254931/article/details/53463596" target="_blank" rel="noopener">http://blog.csdn.net/c466254931/article/details/53463596</a></p><h5 id="数据库索引类型及实现方式"><a href="#数据库索引类型及实现方式" class="headerlink" title="数据库索引类型及实现方式"></a><strong>数据库索引类型及实现方式</strong></h5><p><strong>索引的优缺点:</strong></p><p>唯一索引：   UNIQUE<br>主键索引：   primary key<br>聚集索引（也叫聚簇索引）：cluster <strong>概念</strong>等等</p><p>【1】<a href="http://www.cnblogs.com/barrywxx/p/4351901.html" target="_blank" rel="noopener">http://www.cnblogs.com/barrywxx/p/4351901.html</a><br>【2】<a href="http://www.cnblogs.com/terryglp/articles/2450197.html" target="_blank" rel="noopener">http://www.cnblogs.com/terryglp/articles/2450197.html</a></p><p> <strong>SQL联合索引 与 单一列的索引区别:</strong></p><p>【1】<a href="http://blog.csdn.net/shellching/article/details/7655793" target="_blank" rel="noopener">http://blog.csdn.net/shellching/article/details/7655793</a></p><p><strong>索引的实现方式：</strong></p><ul><li>B+树</li><li>散列索引</li><li>位图索引：位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，<strong>只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势</strong>。</li></ul><h5 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h5><h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a><strong>执行计划</strong></h5><p>explain语句</p><p>【1】<a href="http://toplchx.iteye.com/blog/2091860" target="_blank" rel="noopener">http://toplchx.iteye.com/blog/2091860</a></p><h5 id="事务4大特性"><a href="#事务4大特性" class="headerlink" title="事务4大特性"></a><strong>事务4大特性</strong></h5><ul><li>原子性(Atomicity)</li><li>一致性(Consistency)    </li><li>分离性(亦称独立性Isolation)</li><li>持久性(Durability)</li></ul><p>原子性(Atomicity)：要么全部执行，要么完全不执行</p><p>一致性(Consistency) 实例：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><p>【1】<a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">http://www.cnblogs.com/fjdingsd/p/5273008.html</a></p><h5 id="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"><a href="#在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？" class="headerlink" title="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"></a><strong>在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？</strong></h5><ul><li>办法一，建立分区表，按照用户浏览的记录数进行分区。</li><li>办法二，单独建立一张表，存放这样的信息。这张表就两个列，用户id和浏览量，这种思想叫冗余表。但是需要注意的是冗余表的建立，可以大幅提供效率，但会增加数据库维护的成本，需要综合考虑是否合适。</li><li>办法三，使用mongodb这样的nosql数据库。mongodb是一个文档型的nosql数据库，创建表的时候，增加两个列，一个保存浏览量，一个保存具体的浏览记录。这种方式跟冗余表的思想是一样的</li></ul><p>【1】<a href="http://blog.csdn.net/lgb934/article/details/8662956" target="_blank" rel="noopener">http://blog.csdn.net/lgb934/article/details/8662956</a></p><h5 id="关于数据库where和having的区别，执行顺序、group-by-与having如何使用。"><a href="#关于数据库where和having的区别，执行顺序、group-by-与having如何使用。" class="headerlink" title="关于数据库where和having的区别，执行顺序、group by 与having如何使用。"></a><strong>关于数据库where和having的区别，执行顺序、group by 与having如何使用。</strong></h5><p><a href="http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118" target="_blank" rel="noopener">http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118</a></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><h5 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a><strong>分布式锁的实现</strong></h5><p>【1】<a href="https://my.oschina.net/u/1995545/blog/366381" target="_blank" rel="noopener">https://my.oschina.net/u/1995545/blog/366381</a></p><h5 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a><strong>5种数据类型</strong></h5><ul><li>全局key操作</li><li>String（字符串）</li><li>Hashes类型:(map)</li><li>List类型</li><li>set类型</li><li>Sorted-Sets类型</li></ul><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51354188" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51354188</a></p><h5 id="两种持久化方式及原理"><a href="#两种持久化方式及原理" class="headerlink" title="两种持久化方式及原理"></a><strong>两种持久化方式及原理</strong></h5><p><strong>Redis的持久化策略：</strong><br>rdb:快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略<br>aof：把所有的对redis的服务器进行修改的命令都存到一个文件里，命令的集合</p><p>【1】<a href="http://blog.csdn.net/u010785685/article/details/52366977" target="_blank" rel="noopener">http://blog.csdn.net/u010785685/article/details/52366977</a></p><h5 id="与Memcache区别"><a href="#与Memcache区别" class="headerlink" title="与Memcache区别"></a><strong>与Memcache区别</strong></h5><p>redis和memecache的不同在于：</p><ul><li>存储方式：<br>  memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小<br>  redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。</li><li>数据支持类型：<br>  redis在数据支持上要比memecache多的多。</li><li>使用底层模型不同：<br>  新版本的redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li>运行环境不同：<br>  redis目前官方只支持Linux 上去行，从而省去了对于其它系统的支持，这样的话可以更好的把精力用于本系统 环境上的优化，虽然后来微软有一个小组为其写了补丁。但是没有放到主干上</li></ul><p>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；  </p><p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；  </p><p>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；  </p><p>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；  </p><p>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；  </p><p>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；  </p><p>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；  </p><p>Redis支持数据的备份，即master-slave模式的数据备份；  </p><p>应用场景不一样：Redis出来作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。 </p><p>【1】<a href="http://blog.csdn.net/sunmenggmail/article/details/36176029" target="_blank" rel="noopener">http://blog.csdn.net/sunmenggmail/article/details/36176029</a></p><h5 id="redis是多线程还是单线程"><a href="#redis是多线程还是单线程" class="headerlink" title="redis是多线程还是单线程"></a>redis是多线程还是单线程</h5><p>【1】<a href="http://www.cnblogs.com/syyong/p/6231326.html" target="_blank" rel="noopener">http://www.cnblogs.com/syyong/p/6231326.html</a></p><h5 id="订阅-发布"><a href="#订阅-发布" class="headerlink" title="订阅/发布"></a><strong>订阅/发布</strong></h5><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51376197" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51376197</a></p><h5 id="分布式（主从模式）"><a href="#分布式（主从模式）" class="headerlink" title="分布式（主从模式）"></a><strong>分布式（主从模式）</strong></h5><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h5><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><h5 id="门面模式的解释，适用场合"><a href="#门面模式的解释，适用场合" class="headerlink" title="门面模式的解释，适用场合"></a><strong>门面模式的解释，适用场合</strong></h5><p>【1】<a href="http://www.cnblogs.com/lthIU/p/5860607.html" target="_blank" rel="noopener">http://www.cnblogs.com/lthIU/p/5860607.html</a></p><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a><strong>Hibernate</strong></h3><p>Hibernate工作原理</p><p>Hibernate四种查询</p><p>Hibernate的3种对象状态</p><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/68923405#t9" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/68923405#t9</a></p><h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h3><p>JVM虚拟机内存模型</p><p>堆内存模型</p><p>【1】<a href="http://www.cnblogs.com/AloneSword/p/4262255.html" target="_blank" rel="noopener">http://www.cnblogs.com/AloneSword/p/4262255.html</a></p><p><strong>垃圾回收算法：</strong></p><ul><li>引用计数算法</li><li>根搜索算法</li><li>标记-清除算法</li><li>标记-整理算法</li><li>分代收集算法</li><li>CMS算法：Concurrent Mark Sweep/CMS是一款并发、使用标记-清除算法的gc。（<a href="http://www.cnblogs.com/Leo_wl/p/5393300.html" target="_blank" rel="noopener">http://www.cnblogs.com/Leo_wl/p/5393300.html</a> 或者 <a href="http://blog.csdn.net/aibisoft/article/details/27555793）" target="_blank" rel="noopener">http://blog.csdn.net/aibisoft/article/details/27555793）</a></li></ul><h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><strong>Linux常用命令</strong></h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h5><h5 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a><strong>管道命令</strong></h5><p>【1】<a href="http://www.cnblogs.com/mrzero/p/3985302.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrzero/p/3985302.html</a></p><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h3><h5 id="Tomcat性能调优"><a href="#Tomcat性能调优" class="headerlink" title="Tomcat性能调优"></a><strong>Tomcat性能调优</strong></h5><ul><li>JVM参数调优</li><li>NIO协议</li><li>线程池和连接数配置</li><li>禁用AJP协议</li></ul><h5 id="Tomcat启动时加载数据到缓存"><a href="#Tomcat启动时加载数据到缓存" class="headerlink" title="Tomcat启动时加载数据到缓存"></a><strong>Tomcat启动时加载数据到缓存</strong></h5><p>【1】<a href="http://blog.csdn.net/cnctcom/article/details/52861955" target="_blank" rel="noopener">http://blog.csdn.net/cnctcom/article/details/52861955</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><h5 id="git如何回退到某个历史版本"><a href="#git如何回退到某个历史版本" class="headerlink" title="git如何回退到某个历史版本"></a><strong>git如何回退到某个历史版本</strong></h5><p>【1】<a href="http://blog.csdn.net/newjueqi/article/details/49098123" target="_blank" rel="noopener">http://blog.csdn.net/newjueqi/article/details/49098123</a></p><h5 id="SVN和Git优缺点比较"><a href="#SVN和Git优缺点比较" class="headerlink" title="SVN和Git优缺点比较"></a><strong>SVN和Git优缺点比较</strong></h5><p>【1】<a href="http://blog.csdn.net/yuwq123/article/details/52748009" target="_blank" rel="noopener">http://blog.csdn.net/yuwq123/article/details/52748009</a></p><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h3><h5 id="Statement与PreparedStatement的区别"><a href="#Statement与PreparedStatement的区别" class="headerlink" title="Statement与PreparedStatement的区别?"></a><strong>Statement与PreparedStatement的区别?</strong></h5><p>【1】<a href="http://blog.csdn.net/haorengoodman/article/details/23995347" target="_blank" rel="noopener">http://blog.csdn.net/haorengoodman/article/details/23995347</a></p><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h3><h5 id="MyBatis如何唯一标识一个SQL语句"><a href="#MyBatis如何唯一标识一个SQL语句" class="headerlink" title="MyBatis如何唯一标识一个SQL语句"></a><strong>MyBatis如何唯一标识一个SQL语句</strong></h5><h5 id="Hibernate和MyBatis如何映射一对多关系"><a href="#Hibernate和MyBatis如何映射一对多关系" class="headerlink" title="Hibernate和MyBatis如何映射一对多关系"></a><strong>Hibernate和MyBatis如何映射一对多关系</strong></h5><p>【1】<a href="http://www.cnblogs.com/liujiayun/p/5814158.html" target="_blank" rel="noopener">http://www.cnblogs.com/liujiayun/p/5814158.html</a></p><p>【2】<a href="http://blog.csdn.net/suwu150/article/details/52896459" target="_blank" rel="noopener">http://blog.csdn.net/suwu150/article/details/52896459</a></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端**"></a>前端**</h3><h5 id="ajax原理"><a href="#ajax原理" class="headerlink" title="ajax原理"></a><strong>ajax原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="noopener">http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html</a></p><h3 id="算法面试题"><a href="#算法面试题" class="headerlink" title="算法面试题"></a><strong>算法面试题</strong></h3><p>现在有1000瓶药水，其中至多有1瓶是有剧毒的，现在给你10只狗，在24小时内通过小狗试药的方式，</p><p>找出那些药有毒或者全部没毒（小狗服完药20小时之后才能判断是否中毒）。</p><p>【1】<a href="http://blog.csdn.net/sancho_lai/article/details/3218786" target="_blank" rel="noopener">http://blog.csdn.net/sancho_lai/article/details/3218786</a></p><h3 id="Java中Atomic包的原理和分析"><a href="#Java中Atomic包的原理和分析" class="headerlink" title="Java中Atomic包的原理和分析"></a>Java中Atomic包的原理和分析</h3><p>【1】<a href="http://blog.csdn.net/tanga842428/article/details/52765537" target="_blank" rel="noopener">http://blog.csdn.net/tanga842428/article/details/52765537</a></p><p>下面是笔者整理的jdk自带的常用命令行工具的使用方法，全部原创，转载请注明出处，并贴上链接，谢谢！</p><ul><li><a href="http://blog.csdn.net/winwill2012/article/details/46319033" target="_blank" rel="noopener"><strong>jps命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46319355" target="_blank" rel="noopener"><strong>jstat命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46336839" target="_blank" rel="noopener"><strong>jinfo命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46337339" target="_blank" rel="noopener"><strong>jmap命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46337535" target="_blank" rel="noopener"><strong>jhat命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46364339" target="_blank" rel="noopener"><strong>jstack命令使用</strong></a></li><li><a href="http://blog.csdn.net/winwill2012/article/details/46364849" target="_blank" rel="noopener"><strong>jcmd命令使用</strong></a></li></ul><h3 id="后台系统怎么防止请求重复提交"><a href="#后台系统怎么防止请求重复提交" class="headerlink" title="后台系统怎么防止请求重复提交"></a><strong>后台系统怎么防止请求重复提交</strong></h3><p>【1】<a href="http://blog.csdn.net/hshl1214/article/details/46635905" target="_blank" rel="noopener">http://blog.csdn.net/hshl1214/article/details/46635905</a></p><h3 id="有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。"><a href="#有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。"></a><strong>有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。</strong></h3><p>【1】<a href="http://www.cnblogs.com/children/archive/2012/10/02/2710624.html" target="_blank" rel="noopener">http://www.cnblogs.com/children/archive/2012/10/02/2710624.html</a></p><h3 id="反射中，Class-forName-和-ClassLoader-区别"><a href="#反射中，Class-forName-和-ClassLoader-区别" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别"></a><strong>反射中，Class.forName 和 ClassLoader 区别</strong></h3><h3 id="描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点。"></a><strong>描述动态代理的几种实现方式，分别说出相应的优缺点。</strong></h3><p>【1】<a href="http://blog.csdn.net/kyi_zhu123/article/details/52644624" target="_blank" rel="noopener">http://blog.csdn.net/kyi_zhu123/article/details/52644624</a></p><h3 id="在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。"><a href="#在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。" class="headerlink" title="在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。"></a><strong>在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。</strong></h3><ol><li><a href="http://blog.csdn.net/bbirdsky/article/details/8283143" target="_blank" rel="noopener">http://blog.csdn.net/bbirdsky/article/details/8283143</a>  </li><li>字符串类(Java.lang.String)是Java中使用最多的类，也是最为特殊的一个类，很多时候，我们对它既熟悉又陌生。在很多面试题中经常用String大做文章，只要掌握了String特性，对付它们就不再是困难了。  </li><li>1、从根本上认识java.lang.String类和String池  </li><li>首先，我建议先看看String类的源码实现，这是从本质上认识String类的根本出发点。  </li><li>从源码中可以看到：  </li><li>String类是final的，不可被继承。public final class String。  </li><li>String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];  </li><li>​</li><li>然后打开String类的API文档，从API中可以发现：  </li><li>String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。  </li><li>String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联，这个后面会讲述。  </li><li>Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。  </li><li>​</li><li>2、创建字符串的方式  </li><li>创建字符串的方式很多，归纳起来有三类：  </li><li>使用new关键字创建字符串，比如String s1 = new String(“abc”);  </li><li>直接指定。比如String s2 = “abc”;  </li><li>使用串联生成新的字符串。比如String s3 = “ab” + “c”。  </li><li>​</li><li>3、String对象的创建的特性  </li><li>String对象的创建也很讲究，关键是要明白其原理。  </li><li>​</li><li>特性1：  </li><li>当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个字符串的内容在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。  </li><li>​</li><li>特性2：  </li><li>Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。  </li><li>​</li><li>特性3：  </li><li>使用直接指定、使用纯字符串串联或者在编译期间可以确定结果的变量表达式来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象；  </li><li>1、 直接指定，例如：下面代码运行结果为true；  </li><li>String str1 = “abc”;  </li><li>String str2 = “abc”;  </li><li>System.out.println(str1 == str2);  </li><li>2、 使用纯字符串串联，例如：下面代码运行结果为true；  </li><li>String str1 = “abc”;  </li><li>String str2 = “ab” + “c”;  </li><li>System.out.println(str1 == str2);  </li><li>3、 在编译期间可以确定结果的变量表达式，例如：下面代码运行结果为true。  </li><li>final String str1 = “c”; //final类型的变量在编译时当常量处理  </li><li>String str2 = “ab” + “c”;  </li><li>String str3 = “ab” + str1;  </li><li>System.out.println(str2==str3);  </li><li>​</li><li>否则使用包含编译期间无法确定结果的变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String（由StringBuilder.toString()生成）对象。  </li><li>1、普通变量表达式进行创建字符串，例如：下面代码运行结果为false；  </li><li>String str1 = “c”;  </li><li>String str2 = “ab” + “c”;  </li><li>String str3 = “ab” + str1;  </li><li>System.out.println(str2==str3);  </li></ol><h3 id="人事问题（补充）"><a href="#人事问题（补充）" class="headerlink" title="人事问题（补充）"></a><strong>人事问题（补充）</strong></h3><p>在面试过程中，当你技术面试过关之后，通常会有一个HR面试，一般到这里说明你基本已经通过了面试，但是你还是不能松懈的，这一面也是不容小觑的。比如HR经常会问你这些问题：</p><ul><li>你为什么要离职啊？</li><li>你对我们公司还有什么要了解的吗？</li><li>你能支持经常出差吗？或者能支持经常加班吗？</li><li>你上一家公司的薪资是多少？</li><li>你手里拿到多少个offer了？</li><li>如果我们公司的薪资达不到你的要求，你会考虑留下来吗？</li><li>等等一系列的问题。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h3&gt;&lt;h5 id=&quot;String-StringBuffer-与-StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String-
      
    
    </summary>
    
    
  </entry>
  
</feed>
