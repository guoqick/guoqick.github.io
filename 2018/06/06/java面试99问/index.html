<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="郭琪的小站" type="application/atom+xml" />






<meta name="description" content="历时两周，呕心沥血整理而成，良心之作！！翻遍各大站点、公众号总结出的最常问的99个问题。大部分都是把网上最好的答案网址直接粘贴过来，适合准备面试的人复习之用！！！ JavaString , StringBuffer 与 StringBuilder的区别这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。 面试管：String , StringBuffer 与 Str">
<meta property="og:type" content="article">
<meta property="og:title" content="java程序员面试99问">
<meta property="og:url" content="http://yoursite.com/2018/06/06/java面试99问/index.html">
<meta property="og:site_name" content="郭琪的小站">
<meta property="og:description" content="历时两周，呕心沥血整理而成，良心之作！！翻遍各大站点、公众号总结出的最常问的99个问题。大部分都是把网上最好的答案网址直接粘贴过来，适合准备面试的人复习之用！！！ JavaString , StringBuffer 与 StringBuilder的区别这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。 面试管：String , StringBuffer 与 Str">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-09T09:56:19.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java程序员面试99问">
<meta name="twitter:description" content="历时两周，呕心沥血整理而成，良心之作！！翻遍各大站点、公众号总结出的最常问的99个问题。大部分都是把网上最好的答案网址直接粘贴过来，适合准备面试的人复习之用！！！ JavaString , StringBuffer 与 StringBuilder的区别这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。 面试管：String , StringBuffer 与 Str">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/06/java面试99问/"/>





  <title>java程序员面试99问 | 郭琪的小站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">郭琪的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人生如逆旅，我亦是行人。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tag/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/category/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/commonweal/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/java面试99问/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭 琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郭琪的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java程序员面试99问</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T22:16:23+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>历时两周，呕心沥血整理而成，良心之作！！翻遍各大站点、公众号总结出的最常问的99个问题。大部分都是把网上最好的答案网址直接粘贴过来，适合准备面试的人复习之用！！！</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h5 id="String-StringBuffer-与-StringBuilder的区别"><a href="#String-StringBuffer-与-StringBuilder的区别" class="headerlink" title="String , StringBuffer 与 StringBuilder的区别"></a><strong>String , StringBuffer 与 StringBuilder的区别</strong></h5><p>这是一道重要而且高频被问到的面试题，如果这题都没有回答好，那面试官对你就大打折扣了。</p>
<p><strong>面试管：</strong>String , StringBuffer 与 StringBuilder之间有什么区别吗？</p>
<p><strong>你的回答：</strong></p>
<p>对于字符串拼接：</p>
<p><strong>性能方面：</strong>StringBuilder &gt; StringBuffer &gt; String（+）（for循环里面字符串拼接）</p>
<p><strong>线程安全：</strong>StringBuilder （非线程安全，速度快），StringBuffer （线程安全，速度慢）</p>
<p><strong>如何选择：</strong>StringBuilder （方法内，无线程安全问题），StringBuffer （有线程安全问题，使用它）</p>
<p>3点建议：（加分项）</p>
<ul>
<li>当你连接 2 或 3 个String时，使用String.concat()。</li>
<li>如果你要连接多于3个String（不含3）,并且你能够精确预测出最终结果的长度，使用StringBuilder/StringBuffer，并设定初始化容量。</li>
<li>如果你要连接多于3个String（不含3）,并且你不能够精确预测出最终结果的长度，使用StringBundler。</li>
</ul>
<p>【1】<a href="https://www.cnblogs.com/dolphin0520/p/3778589.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3778589.html</a></p>
<p>面试官继续问题：</p>
<p>StringBuffer 为什么是线程安全的呢？</p>
<p>【2】<a href="https://blog.csdn.net/u014086926/article/details/52069074" target="_blank" rel="noopener">https://blog.csdn.net/u014086926/article/details/52069074</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//StringBuffer源码</span><br><span class="line">/**</span><br><span class="line"> * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public synchronized void getChars(int srcBegin, int srcEnd, char[] dst,int dstBegin)&#123;</span><br><span class="line">    super.getChars(srcBegin, srcEnd, dst, dstBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面试官可能还会继续问：</p>
<p>为什么加 synchronized 这个关键字，就是线程安全的呢？</p>
<h5 id="Vector，ArrayList，LinkedList的区别"><a href="#Vector，ArrayList，LinkedList的区别" class="headerlink" title="Vector，ArrayList，LinkedList的区别"></a><strong>Vector，ArrayList，LinkedList的区别</strong></h5><p>一、同步性 </p>
<p>ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。 </p>
<p>二、数据增长<br>从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 </p>
<p>三、检索、插入、删除对象的效率 </p>
<p>ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。<br>LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。 </p>
<p>一般大家都知道ArrayList和LinkedList的大致区别：<br>​     1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>​     2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>​     3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 </p>
<h5 id="List如何去除重复数据"><a href="#List如何去除重复数据" class="headerlink" title="List如何去除重复数据"></a><strong>List如何去除重复数据</strong></h5><p>【1】<a href="http://www.2cto.com/kf/201708/664237.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201708/664237.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AAAA AAAA BBBB BBBB CCCC CCCC CCCC CCCC</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">         List&lt;string&gt; list = new ArrayList&lt;string&gt;();</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;AAAA&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;BBBB&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;CCCC&quot;);</span><br><span class="line">         list.add(&quot;DDDD&quot;);</span><br><span class="line">         new Test().removeDuplicateWithOrder(list);</span><br><span class="line">//      System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 删除ArrayList中重复元素</span><br><span class="line">public static void removeDuplicate(List list) &#123;</span><br><span class="line">    for (int i = 0; i &lt; list.size() - 1; i++) &#123;</span><br><span class="line">        for (int j = list.size() - 1; j &gt; i; j--) &#123;</span><br><span class="line">               if (list.get(j).equals(list.get(i))) &#123;</span><br><span class="line">                  list.remove(j);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法二：通过HashSet剔除</span><br><span class="line">      // 删除ArrayList中重复元素,add进去顺序就变了不考虑顺序的话可以使用</span><br><span class="line">public static void removeDuplicate1(List list) &#123;</span><br><span class="line">         HashSet h = new HashSet(list);</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(h);</span><br><span class="line">         System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      // 方法三： 删除ArrayList中重复元素，保持顺序</span><br><span class="line">      // 删除ArrayList中重复元素，保持顺序</span><br><span class="line">public static void removeDuplicateWithOrder(List list) &#123;</span><br><span class="line">         Set set = new HashSet();</span><br><span class="line">         List newList = new ArrayList();</span><br><span class="line">         for (Iterator iter = list.iterator(); iter.hasNext();) &#123;</span><br><span class="line">            Object element = iter.next();</span><br><span class="line">            if (set.add(element))</span><br><span class="line">               newList.add(element);</span><br><span class="line">         &#125;</span><br><span class="line">         list.clear();</span><br><span class="line">         list.addAll(newList);</span><br><span class="line">         System.out.println(&quot; remove duplicate &quot; + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自己手动实现一个线程池"><a href="#自己手动实现一个线程池" class="headerlink" title="自己手动实现一个线程池"></a><strong>自己手动实现一个线程池</strong></h5><p>问题一：为什么需要线程池；</p>
<p>问题二：如何动手实现一个线程池；</p>
<p>【1】<a href="http://blog.csdn.net/w2393040183/article/details/52177572" target="_blank" rel="noopener">http://blog.csdn.net/w2393040183/article/details/52177572</a></p>
<h5 id="Java字节流和字符流的区别"><a href="#Java字节流和字符流的区别" class="headerlink" title="Java字节流和字符流的区别"></a><strong>Java字节流和字符流的区别</strong></h5><p>经过以上的描述，我们可以知道字节流与字符流之间主要的区别体现在以下几个方面：</p>
<ul>
<li>字节流操作的基本单元为字节；字符流操作的基本单元为Unicode码元。</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区。</li>
<li>字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元；字符流通常处理文本数据，它支持写入及读取Unicode码元。</li>
</ul>
<p>所以对于字节流和字符流的选择，我们建议：在开发中尽量都去使用字节流进行操作，因为字节流可以处理图片、音乐、文字，也可以方便进行传输或者文字的编码转换；如果在处理中文的使用考虑字符流。</p>
<p>【1】<a href="http://bbs.itheima.com/thread-277923-1-1.html" target="_blank" rel="noopener">http://bbs.itheima.com/thread-277923-1-1.html</a></p>
<h5 id="多线程实现生产者-消费者模式"><a href="#多线程实现生产者-消费者模式" class="headerlink" title="多线程实现生产者/消费者模式"></a><strong>多线程实现生产者/消费者模式</strong></h5><h5 id="在Java中什么是线程调度？"><a href="#在Java中什么是线程调度？" class="headerlink" title="在Java中什么是线程调度？"></a><strong>在Java中什么是线程调度？</strong></h5><p>【1】<a href="https://blog.csdn.net/nalanmingdian/article/details/77748326" target="_blank" rel="noopener">https://blog.csdn.net/nalanmingdian/article/details/77748326</a></p>
<h5 id="线程与进程的区别？"><a href="#线程与进程的区别？" class="headerlink" title="线程与进程的区别？"></a><strong>线程与进程的区别？</strong></h5><p><a href="http://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="noopener">http://blog.csdn.net/yaosiming2011/article/details/44280797</a></p>
<p><strong>死锁与活锁区别，死锁与饥饿的区别？</strong></p>
<p><a href="http://www.cnblogs.com/lance43990740/p/6853631.html" target="_blank" rel="noopener">http://www.cnblogs.com/lance43990740/p/6853631.html</a></p>
<h5 id="在线程中你怎么处理不可控制异常"><a href="#在线程中你怎么处理不可控制异常" class="headerlink" title="在线程中你怎么处理不可控制异常"></a><strong>在线程中你怎么处理不可控制异常</strong></h5><p>【1】<a href="http://blog.csdn.net/Dxx23/article/details/44775735" target="_blank" rel="noopener">http://blog.csdn.net/Dxx23/article/details/44775735</a></p>
<p>java为我们提供了一种线程内发生异常时能够在线程代码边界之外处理异常的回调机制，即Thread对象提供的setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法。通过该方法给某个thread设置一个UncaughtExceptionHandler，可以确保在该线程出现异常时能通过回调UncaughtExceptionHandler接口的public void uncaughtException(Thread t, Throwable e) 方法来处理异常，这样的好处或者说目的是可以在线程代码边界之外（Thread的run()方法之外），有一个地方能处理未捕获异常。但是要特别明确的是：虽然是在回调方法中处理异常，但这个回调方法在执行时依然还在抛出异常的这个线程中！另外还要特别说明一点：如果线程是通过线程池创建，线程异常发生时UncaughtExceptionHandler接口不一定会立即回调。</p>
<p><strong>多线程上下文切换</strong></p>
<p>【1】<a href="http://www.cnblogs.com/szlbm/p/5505707.html" target="_blank" rel="noopener">http://www.cnblogs.com/szlbm/p/5505707.html</a></p>
<h5 id="HashTable，HashMap，TreeMap的区别"><a href="#HashTable，HashMap，TreeMap的区别" class="headerlink" title="HashTable，HashMap，TreeMap的区别"></a><strong>HashTable，HashMap，TreeMap的区别</strong></h5><p>【1】<a href="http://blog.csdn.net/natian306/article/details/10858097" target="_blank" rel="noopener">http://blog.csdn.net/natian306/article/details/10858097</a></p>
<p>【2】<a href="http://www.cnblogs.com/tengpan-cn/p/5909395.html" target="_blank" rel="noopener">http://www.cnblogs.com/tengpan-cn/p/5909395.html</a></p>
<h5 id="IO-BIO-NIO-AIO编程模型"><a href="#IO-BIO-NIO-AIO编程模型" class="headerlink" title="IO,BIO,NIO,AIO编程模型"></a>IO,BIO,NIO,AIO编程模型</h5><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a><br>【2】<a href="http://blog.csdn.net/jiaomingliang/article/details/47684713" target="_blank" rel="noopener">http://blog.csdn.net/jiaomingliang/article/details/47684713</a></p>
<p>如果你想吃一份宫保鸡丁盖饭： </p>
<p>同步阻塞：你到饭馆点餐，然后在那<br>等着，还要一边喊：好了没啊！ </p>
<p>同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p>
<p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p>
<p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p>
<h5 id="TreeMap实现原理"><a href="#TreeMap实现原理" class="headerlink" title="TreeMap实现原理"></a><strong>TreeMap实现原理</strong></h5><p>【1】<a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/26668941</a></p>
<h5 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a><strong>HashMap实现原理</strong></h5><p>【1】<a href="http://blog.csdn.net/vking_wang/article/details/14166593" target="_blank" rel="noopener">http://blog.csdn.net/vking_wang/article/details/14166593</a></p>
<h5 id="如何判断一棵树-tree-是对称的"><a href="#如何判断一棵树-tree-是对称的" class="headerlink" title="如何判断一棵树(tree)是对称的"></a><strong>如何判断一棵树(tree)是对称的</strong></h5><p>【1】<a href="http://blog.csdn.net/yangmm2048/article/details/45689561" target="_blank" rel="noopener">http://blog.csdn.net/yangmm2048/article/details/45689561</a></p>
<h5 id="如何生成全局唯一的编码（序列号）"><a href="#如何生成全局唯一的编码（序列号）" class="headerlink" title="如何生成全局唯一的编码（序列号）"></a><strong>如何生成全局唯一的编码（序列号）</strong></h5><p>【1】<a href="http://www.lmyw.net.cn/?p=1267" target="_blank" rel="noopener">http://www.lmyw.net.cn/?p=1267</a></p>
<h5 id="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"><a href="#关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。" class="headerlink" title="关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"></a>关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</h5><h5 id="map实现按照key字典排序，并且按照顺序打印key-和-value"><a href="#map实现按照key字典排序，并且按照顺序打印key-和-value" class="headerlink" title="map实现按照key字典排序，并且按照顺序打印key 和 value?"></a><strong>map实现按照key字典排序，并且按照顺序打印key 和 value?</strong></h5><p>【1】<a href="http://blog.csdn.net/bwgang/article/details/7879563" target="_blank" rel="noopener">http://blog.csdn.net/bwgang/article/details/7879563</a></p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h5><p>1）反射：根据类的信息来加载这个类，然后构造这个对象，然后再调用这个类中的属性和方法</p>
<p>2）记住获取类的三种方式。</p>
<p>3）反射的应用</p>
<p>4）加分项：反射的性能不好</p>
<p>【1】<a href="http://uule.iteye.com/blog/1423512" target="_blank" rel="noopener">http://uule.iteye.com/blog/1423512</a></p>
<p>【2】<a href="https://blog.csdn.net/the_fire/article/details/6020402" target="_blank" rel="noopener">https://blog.csdn.net/the_fire/article/details/6020402</a></p>
<h5 id="syschronized实现原理"><a href="#syschronized实现原理" class="headerlink" title="syschronized实现原理"></a><strong>syschronized实现原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p>
<p><strong>lock接口比synchronized块的优势是什么</strong></p>
<p>【1】<a href="https://www.cnblogs.com/iyyy/p/7993788.html" target="_blank" rel="noopener">https://www.cnblogs.com/iyyy/p/7993788.html</a></p>
<h5 id="syschronized与重入锁ReenTrantLock的区别"><a href="#syschronized与重入锁ReenTrantLock的区别" class="headerlink" title="syschronized与重入锁ReenTrantLock的区别"></a><strong>syschronized与重入锁ReenTrantLock的区别</strong></h5><p>可重入性：<br>从名字上理解，ReenTrantLock的字面意思就是再进入<br>的锁，其实synchronized关键字所使用的锁也是可重<br>入的，两者关于这个的区别不大。两者都是同<br>一个线程每次进入一次，锁的计数器都自增1，<br>所以要等到锁的计数器下降为0时才能释放锁。<br>三.synchronized和ReentrantLock的区别<br>除了synchronized的功能,多了三个高级功能.<br>等待可中断,公平锁,绑定多个Condition.</p>
<ul>
<li>1.等待可中断<br>在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.   tryLock(long timeout, TimeUnit unit)</li>
<li>2.公平锁按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.    new RenentrantLock(boolean fair)</li>
<li>3.绑定多个Condition<br>通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();</li>
</ul>
<h5 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><strong>Java多线程</strong></h5><h5 id="wait（），notify（）和notifyAll（）"><a href="#wait（），notify（）和notifyAll（）" class="headerlink" title="wait（），notify（）和notifyAll（）"></a><strong>wait（），notify（）和notifyAll（）</strong></h5><p>【1】<a href="https://blog.csdn.net/luoweifu/article/details/46664809" target="_blank" rel="noopener">https://blog.csdn.net/luoweifu/article/details/46664809</a></p>
<p>作业：能通过wait 、notify  、notifyAll默写出生产者消费者模式</p>
<h5 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a><strong>抽象类与接口的区别</strong></h5><p>【1】<a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">http://www.importnew.com/12399.html</a><br>     <a href="http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html" target="_blank" rel="noopener">http://www.cnblogs.com/beanmoon/archive/2012/12/06/2805221.html</a></p>
<h5 id="equals-hashcode"><a href="#equals-hashcode" class="headerlink" title="equals hashcode "></a><strong>equals hashcode </strong></h5><p>【1】<a href="http://blog.csdn.net/ftx2540993425/article/details/51206130" target="_blank" rel="noopener">http://blog.csdn.net/ftx2540993425/article/details/51206130</a><br>【2】<a href="http://www.cnblogs.com/Qian123/p/5703507.html" target="_blank" rel="noopener">http://www.cnblogs.com/Qian123/p/5703507.html</a></p>
<h5 id="lambda优点"><a href="#lambda优点" class="headerlink" title="lambda优点"></a><strong>lambda优点</strong></h5><p>【1】<a href="http://developer.51cto.com/art/201304/387681.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201304/387681.htm</a></p>
<p>【2】</p>
<h5 id="关键字transient"><a href="#关键字transient" class="headerlink" title="关键字transient"></a><strong>关键字transient</strong></h5><p>【1】<a href="http://blog.csdn.net/d12345678a/article/details/54178659" target="_blank" rel="noopener">http://blog.csdn.net/d12345678a/article/details/54178659</a></p>
<h5 id="JDK-和JRE的区别是什么"><a href="#JDK-和JRE的区别是什么" class="headerlink" title="JDK 和JRE的区别是什么"></a>JDK 和JRE的区别是什么</h5><p>Java运行时环境(JRE:Java Runtime Environment)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程 序。</p>
<p>JDK(Java Development Kit ) 中包含JRE，JRE中包含 JVM。</p>
<p>JDK &gt;  JRE &gt; JVM</p>
<p>JDK中包含的JRE主要是为JDK自带的开发工具提供运行环境，与JDK并列的那个JRE是为用户编写的JAVA代码提供运行环境的。</p>
<p>classpath配置的是JDK的lib目录，path配置的是JDK的bin目录。</p>
<p>补充问题：</p>
<p>如果技术面试官问你：”你觉得前面几轮面试的怎么样“  ?</p>
<h5 id="Java到底是不是一种纯面向对象语言？"><a href="#Java到底是不是一种纯面向对象语言？" class="headerlink" title="Java到底是不是一种纯面向对象语言？"></a><strong>Java到底是不是一种纯面向对象语言？</strong></h5><p>【1】<a href="https://news.cnblogs.com/n/548327/" target="_blank" rel="noopener">https://news.cnblogs.com/n/548327/</a></p>
<h5 id="HTTP请求的header头解析"><a href="#HTTP请求的header头解析" class="headerlink" title="HTTP请求的header头解析"></a><strong>HTTP请求的header头解析</strong></h5><p><a href="http://blog.csdn.net/hufan11100914/article/details/48029633" target="_blank" rel="noopener">http://blog.csdn.net/hufan11100914/article/details/48029633</a></p>
<h5 id="如何判断一个对象已经被回收"><a href="#如何判断一个对象已经被回收" class="headerlink" title="如何判断一个对象已经被回收"></a><strong>如何判断一个对象已经被回收</strong></h5><p>【1】<a href="http://blog.csdn.net/canot/article/details/51037938" target="_blank" rel="noopener">http://blog.csdn.net/canot/article/details/51037938</a></p>
<h5 id="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗"><a href="#假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗" class="headerlink" title="假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)"></a><strong>假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)</strong></h5><h5 id="有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…"><a href="#有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…" class="headerlink" title="有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…"></a><strong>有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…</strong></h5><h5 id="将两个有序数组-组合-并为一个-有序数组"><a href="#将两个有序数组-组合-并为一个-有序数组" class="headerlink" title="将两个有序数组   组合 并为一个 有序数组"></a><strong>将两个有序数组   组合 并为一个 有序数组</strong></h5><p>【1】<a href="https://www.cnblogs.com/clarke157/p/6910425.html" target="_blank" rel="noopener">https://www.cnblogs.com/clarke157/p/6910425.html</a></p>
<h5 id="JAVA值类型和引用类型的区别"><a href="#JAVA值类型和引用类型的区别" class="headerlink" title="JAVA值类型和引用类型的区别"></a><strong>JAVA值类型和引用类型的区别</strong></h5><p>【1】<a href="http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html" target="_blank" rel="noopener">http://www.cnblogs.com/InterLinkXiaoCai/p/4951889.html</a></p>
<h5 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a><strong>基本类型转换</strong></h5><p>【1】<a href="http://blog.csdn.net/u011583105/article/details/16349095" target="_blank" rel="noopener">http://blog.csdn.net/u011583105/article/details/16349095</a></p>
<h5 id="递归算法笔试题"><a href="#递归算法笔试题" class="headerlink" title="递归算法笔试题"></a><strong>递归算法笔试题</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> * 一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少， 用递归算法实现。</span><br><span class="line"> **/</span><br><span class="line">static int find30(int n)&#123;</span><br><span class="line">        if (n &lt;= 0)</span><br><span class="line">            return 0;</span><br><span class="line">        else if(n &gt; 0 &amp;&amp; n &lt;= 2)</span><br><span class="line">            return 1;</span><br><span class="line">        return find30(n-1)+find30(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【1】<a href="https://www.cnblogs.com/lan-writenbook/p/5487265.html" target="_blank" rel="noopener">https://www.cnblogs.com/lan-writenbook/p/5487265.html</a></p>
<h5 id="内存泄漏和内存溢出区别"><a href="#内存泄漏和内存溢出区别" class="headerlink" title="内存泄漏和内存溢出区别"></a><strong>内存泄漏和内存溢出区别</strong></h5><p>Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。</p>
<p>【1】<a href="http://blog.csdn.net/buutterfly/article/details/6617375" target="_blank" rel="noopener">http://blog.csdn.net/buutterfly/article/details/6617375</a></p>
<h5 id="内存溢出和内存泄漏的原因"><a href="#内存溢出和内存泄漏的原因" class="headerlink" title="内存溢出和内存泄漏的原因"></a><strong>内存溢出和内存泄漏的原因</strong></h5><p>【1】<a href="http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html" target="_blank" rel="noopener">http://www.cnblogs.com/bluestorm/archive/2012/08/06/2625604.html</a></p>
<p>【2】<a href="http://blog.csdn.net/anxpp/article/details/51325838" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51325838</a></p>
<p>【3】<a href="http://blog.csdn.net/shanyu1198124123/article/details/52414392" target="_blank" rel="noopener">http://blog.csdn.net/shanyu1198124123/article/details/52414392</a></p>
<h5 id="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"><a href="#子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次" class="headerlink" title="子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"></a>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次</h5><p>【1】<a href="http://www.cnblogs.com/ysloong/p/6370104.html" target="_blank" rel="noopener">http://www.cnblogs.com/ysloong/p/6370104.html</a></p>
<h5 id="Condition的作用"><a href="#Condition的作用" class="headerlink" title="Condition的作用"></a><strong>Condition的作用</strong></h5><p>【1】<a href="https://blog.csdn.net/heyutao007/article/details/49889849" target="_blank" rel="noopener">https://blog.csdn.net/heyutao007/article/details/49889849</a></p>
<p>【2】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p>
<h5 id="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"><a href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行" class="headerlink" title="现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"></a><strong>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</strong></h5><h5 id="Java多线程中join方法的理解"><a href="#Java多线程中join方法的理解" class="headerlink" title="Java多线程中join方法的理解"></a>Java多线程中join方法的理解</h5><p>【0】<a href="http://blog.csdn.net/wangxiaotongfan/article/details/51741741" target="_blank" rel="noopener">http://blog.csdn.net/wangxiaotongfan/article/details/51741741</a></p>
<p>【1】<a href="http://uule.iteye.com/blog/1101994" target="_blank" rel="noopener">http://uule.iteye.com/blog/1101994</a></p>
<p>【2】<a href="http://www.cnblogs.com/aboutblank/p/3631453.html" target="_blank" rel="noopener">http://www.cnblogs.com/aboutblank/p/3631453.html</a></p>
<h5 id="equals-与-hashcode-（重要）"><a href="#equals-与-hashcode-（重要）" class="headerlink" title="equals() 与 hashcode()  （重要）"></a><strong>equals() 与 hashcode()  （重要）</strong></h5><p>【1】<a href="http://www.importnew.com/25783.html" target="_blank" rel="noopener">http://www.importnew.com/25783.html</a></p>
<h5 id="Lock接口比synchronized块的优势是什么"><a href="#Lock接口比synchronized块的优势是什么" class="headerlink" title="Lock接口比synchronized块的优势是什么"></a><strong>Lock接口比synchronized块的优势是什么</strong></h5><p>【1】<a href="https://www.cnblogs.com/iyyy/p/7993788.html" target="_blank" rel="noopener">https://www.cnblogs.com/iyyy/p/7993788.html</a></p>
<h5 id="java中-wait-和-sleep-方法的不同"><a href="#java中-wait-和-sleep-方法的不同" class="headerlink" title="java中 wait 和 sleep 方法的不同"></a><strong>java中 wait 和 sleep 方法的不同</strong></h5><p>【1】<a href="http://blog.csdn.net/clam_clam/article/details/6803667" target="_blank" rel="noopener">http://blog.csdn.net/clam_clam/article/details/6803667</a></p>
<p>sleep和wait的区别有：</p>
<ul>
<li>当二者都定义在同步中时，线程执行到sleep，不会释放锁。线程执行到wait，会释放锁。</li>
</ul>
<ul>
<li>首先应该明确 sleep 方法是Thread类中定义的方法，而 wait 方法是Object类中定义的方法。</li>
<li>sleep方法必须人为地为其指定时间。</li>
</ul>
<p>​     wait方法既可以指定时间，也可以不指定时间。</p>
<ul>
<li>sleep方法时间到，线程处于临时阻塞状态或者运行状态。</li>
</ul>
<p>​     wait方法如果没有被设置时间，就必须要通过 notify 或者 notifyAll 来唤醒。</p>
<ul>
<li>sleep方法不一定非要定义在同步中。  wait方法必须定义在同步中。</li>
</ul>
<ul>
<li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li>
</ul>
<p><strong>用Java实现阻塞队列</strong></p>
<p>【1】<a href="https://blog.csdn.net/x_i_y_u_e/article/details/51398994" target="_blank" rel="noopener">https://blog.csdn.net/x_i_y_u_e/article/details/51398994</a></p>
<p>【2】<a href="http://blog.csdn.net/chenchaofuck1/article/details/51660119" target="_blank" rel="noopener">http://blog.csdn.net/chenchaofuck1/article/details/51660119</a></p>
<p>【3】<a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="noopener">http://blog.csdn.net/ghsau/article/details/7481142</a></p>
<p>作业题：区别：<strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong></p>
<p><strong>java中volatile关键字理解</strong></p>
<p>【1】<a href="https://blog.csdn.net/jackyqiziheng/article/details/73703278" target="_blank" rel="noopener">https://blog.csdn.net/jackyqiziheng/article/details/73703278</a></p>
<p>区别：</p>
<p>  一、volatile是变量修饰符，而synchronized则作用于一段代码或方法。</p>
<p> 二、volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源</p>
<p>作业：volatile防止指令重排在单例模式的应用</p>
<h5 id="什么是竞争条件？你怎样发现和解决竞争？"><a href="#什么是竞争条件？你怎样发现和解决竞争？" class="headerlink" title="什么是竞争条件？你怎样发现和解决竞争？"></a><strong>什么是竞争条件？你怎样发现和解决竞争？</strong></h5><p>【1】<a href="http://blog.csdn.net/hourui93/article/details/48596259" target="_blank" rel="noopener">http://blog.csdn.net/hourui93/article/details/48596259</a></p>
<h5 id="你将如何使用thread-dump？你将如何分析Thread-dump"><a href="#你将如何使用thread-dump？你将如何分析Thread-dump" class="headerlink" title="你将如何使用thread dump？你将如何分析Thread dump"></a><strong>你将如何使用thread dump？你将如何分析Thread dump</strong></h5><p>【1】<a href="http://blog.csdn.net/rachel_luo/article/details/8920596" target="_blank" rel="noopener">http://blog.csdn.net/rachel_luo/article/details/8920596</a></p>
<h5 id="在Java中CycliBarriar和CountdownLatch有什么区别"><a href="#在Java中CycliBarriar和CountdownLatch有什么区别" class="headerlink" title="在Java中CycliBarriar和CountdownLatch有什么区别"></a><strong>在Java中CycliBarriar和CountdownLatch有什么区别</strong></h5><p>【1】<a href="http://blog.csdn.net/kjfcpua/article/details/7300286" target="_blank" rel="noopener">http://blog.csdn.net/kjfcpua/article/details/7300286</a></p>
<h5 id="Java并发编程-Executor框架集"><a href="#Java并发编程-Executor框架集" class="headerlink" title="Java并发编程-Executor框架集"></a><strong>Java并发编程-Executor框架集</strong></h5><p>【1】<a href="http://www.cnblogs.com/MOBIN/p/5436482.html" target="_blank" rel="noopener">http://www.cnblogs.com/MOBIN/p/5436482.html</a></p>
<h5 id="对象的四种引用类型"><a href="#对象的四种引用类型" class="headerlink" title="对象的四种引用类型"></a><strong>对象的四种引用类型</strong></h5><p>【1】<a href="http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/archive/2012/09/08/java.html</a></p>
<h5 id="Java中Atomic包的原理和分析"><a href="#Java中Atomic包的原理和分析" class="headerlink" title="Java中Atomic包的原理和分析"></a>Java中Atomic包的原理和分析</h5><p>【1】<a href="http://blog.csdn.net/tanga842428/article/details/52765537" target="_blank" rel="noopener">http://blog.csdn.net/tanga842428/article/details/52765537</a></p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h3><p>【1】<a href="http://www.importnew.com/15851.html#ioc_di" target="_blank" rel="noopener">http://www.importnew.com/15851.html#ioc_di</a></p>
<p><strong>Spring好在哪里</strong></p>
<p> 轻量：Spring 是轻量的，基本的版本大约2MB。<br> 控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br> 面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br> 容器：Spring 包含并管理应用中对象的生命周期和配置。<br> MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br> 事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br> 异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p>
<h5 id="动态代理实现日志管理"><a href="#动态代理实现日志管理" class="headerlink" title="动态代理实现日志管理"></a><strong>动态代理实现日志管理</strong></h5><p>【1】<a href="https://blog.csdn.net/huangwenyi1010/article/details/51798353" target="_blank" rel="noopener">https://blog.csdn.net/huangwenyi1010/article/details/51798353</a></p>
<h5 id="Spring框架有哪些主要模块"><a href="#Spring框架有哪些主要模块" class="headerlink" title="Spring框架有哪些主要模块"></a>Spring框架有哪些主要模块</h5><p>【1】<a href="http://blog.knowsky.com/200197.htm" target="_blank" rel="noopener">http://blog.knowsky.com/200197.htm</a></p>
<h5 id="控制反转-IOC-？什么是依赖注入（DI）"><a href="#控制反转-IOC-？什么是依赖注入（DI）" class="headerlink" title="控制反转(IOC)？什么是依赖注入（DI）?"></a><strong>控制反转(IOC)？什么是依赖注入（DI）?</strong></h5><p>【1】<a href="https://blog.csdn.net/qq_22654611/article/details/52606960/" target="_blank" rel="noopener">https://blog.csdn.net/qq_22654611/article/details/52606960/</a></p>
<h5 id="IOC-DI-原理（重要）"><a href="#IOC-DI-原理（重要）" class="headerlink" title="IOC(DI)原理（重要）"></a><strong>IOC(DI)原理（重要）</strong></h5><p>【1】<a href="https://www.cnblogs.com/ITtangtang/p/3978349.html" target="_blank" rel="noopener">https://www.cnblogs.com/ITtangtang/p/3978349.html</a></p>
<h5 id="依然注入三种实现方式"><a href="#依然注入三种实现方式" class="headerlink" title="依然注入三种实现方式"></a><strong>依然注入三种实现方式</strong></h5><p><strong>FileSystemResource和ClassPathResource有何区别</strong></p>
<p>2种载入Spring配置文件的方式</p>
<p><strong>ClassPathXmlApplicationContext</strong>：从类路径ClassPath中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作，具体代码如下：</p>
<p> //装载单个配置文件实例化ApplicationContext容器</p>
<p>ApplicationContext cxt = newClassPathXmlApplicationContext(“applicationContext.xml”);</p>
<p>//装载多个配置文件实例化ApplicationContext容器</p>
<p>String[] configs ={“bean1.xml”,”bean2.xml”,”bean3.xml”};</p>
<p>ApplicationContext cxt = newClassPathXmlApplicationContext(configs);</p>
<p><strong>FileSystemXmlApplicationContext</strong>：从指定的文件系统路径中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。具体代码如下：</p>
<p>//装载单个配置文件实例化ApplicationContext容器</p>
<p>ApplicationContext cxt = newFileSystemXMLApplicationContext(“beans.xml”);</p>
<p>//装载多个配置文件实例化ApplicationContext容器</p>
<p>String[] configs ={“c:/beans1.xml”,”c:/beans2.xml”};</p>
<p>ApplicationContext cxt = newFileSystemXmlApplicationContext(configs);</p>
<p>XmlWebApplicationContext：从Web应用中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。这是为Web工程量身定制的，使用WebApplicationContextUtils类的getRequiredWebApplicationContext方法可在JSP与Servlet中取得IoC容器的引用。</p>
<h5 id="Spring-Bean作用域之间的区别"><a href="#Spring-Bean作用域之间的区别" class="headerlink" title="Spring Bean作用域之间的区别"></a><strong>Spring Bean作用域之间的区别</strong></h5><h5 id="Spring有几种配置方式"><a href="#Spring有几种配置方式" class="headerlink" title="Spring有几种配置方式"></a><strong>Spring有几种配置方式</strong></h5><ul>
<li>基于XML的配置</li>
<li>基于注解的配置</li>
<li>基于Java的配置</li>
</ul>
<h5 id="请解释Spring-Bean的生命周期"><a href="#请解释Spring-Bean的生命周期" class="headerlink" title="请解释Spring Bean的生命周期"></a><strong>请解释Spring Bean的生命周期</strong></h5><p>【1】<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>
<p>【2】<a href="https://blog.csdn.net/a327369238/article/details/52193822" target="_blank" rel="noopener">https://blog.csdn.net/a327369238/article/details/52193822</a></p>
<h5 id="自动装配模式的区别"><a href="#自动装配模式的区别" class="headerlink" title="自动装配模式的区别"></a><strong>自动装配模式的区别</strong></h5><h5 id="如何开启基于注解的自动装配"><a href="#如何开启基于注解的自动装配" class="headerlink" title="如何开启基于注解的自动装配"></a><strong>如何开启基于注解的自动装配</strong></h5><h5 id="Spring框架中有哪些不同类型的事件"><a href="#Spring框架中有哪些不同类型的事件" class="headerlink" title="Spring框架中有哪些不同类型的事件"></a><strong>Spring框架中有哪些不同类型的事件</strong></h5><p>【1】<a href="https://blog.csdn.net/u011063151/article/details/52036052" target="_blank" rel="noopener">https://blog.csdn.net/u011063151/article/details/52036052</a></p>
<h5 id="BeanFactory和ApplicationContext有什么区别"><a href="#BeanFactory和ApplicationContext有什么区别" class="headerlink" title="BeanFactory和ApplicationContext有什么区别"></a><strong>BeanFactory和ApplicationContext有什么区别</strong></h5><p>【1】<a href="http://youyu4.iteye.com/blog/2346183" target="_blank" rel="noopener">http://youyu4.iteye.com/blog/2346183</a></p>
<h5 id="三种较常见的-ApplicationContext-实现方式"><a href="#三种较常见的-ApplicationContext-实现方式" class="headerlink" title="三种较常见的 ApplicationContext 实现方式"></a><strong>三种较常见的 ApplicationContext 实现方式</strong></h5><ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>XmlWebApplicationContext</li>
</ul>
<h5 id="如何用基于Java配置的方式配置Spring"><a href="#如何用基于Java配置的方式配置Spring" class="headerlink" title="如何用基于Java配置的方式配置Spring"></a><strong>如何用基于Java配置的方式配置Spring</strong></h5><p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。</p>
<h5 id="Spring中注入一个Java-Collection"><a href="#Spring中注入一个Java-Collection" class="headerlink" title="Spring中注入一个Java Collection"></a><strong>Spring中注入一个Java Collection</strong></h5><p><list> :   该标签用来装配可重复的list值。</list></p>
<p><set> :    该标签用来装配没有重复的set值。</set></p>
<p><map>:   该标签可用来注入键和值可以为任何类型的键值对。</map></p>
<p><props> : 该标签支持注入键和值都是字符串类型的键值对。</props></p>
<h5 id="FileSystemResource和ClassPathResource有何区别"><a href="#FileSystemResource和ClassPathResource有何区别" class="headerlink" title="FileSystemResource和ClassPathResource有何区别"></a><strong>FileSystemResource和ClassPathResource有何区别</strong></h5><h5 id="Spring-框架中都用到了哪些设计模式"><a href="#Spring-框架中都用到了哪些设计模式" class="headerlink" title="Spring 框架中都用到了哪些设计模式"></a><strong>Spring 框架中都用到了哪些设计模式</strong></h5><ul>
<li>代理模式—在AOP和remoting中被用的比较多。</li>
<li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li>
<li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li>
<li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li>
<li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li>
<li>工厂模式—BeanFactory用来创建对象的实例。</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a><strong>SpringBoot</strong></h3><h3 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a><strong>Struts</strong></h3><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h3><h5 id="Post，Get请求区别"><a href="#Post，Get请求区别" class="headerlink" title="Post，Get请求区别"></a><strong>Post，Get请求区别</strong></h5><p>【1】<a href="http://blog.csdn.net/yipiankongbai/article/details/24025633" target="_blank" rel="noopener">http://blog.csdn.net/yipiankongbai/article/details/24025633</a></p>
<h5 id="Session-Cookie区别"><a href="#Session-Cookie区别" class="headerlink" title="Session, Cookie区别"></a><strong>Session, Cookie区别</strong></h5><p>【1】<a href="http://blog.csdn.net/axin66ok/article/details/6175522" target="_blank" rel="noopener">http://blog.csdn.net/axin66ok/article/details/6175522</a></p>
<h5 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a><strong>Servlet的生命周期</strong></h5><p>【1】<a href="http://www.runoob.com/servlet/servlet-life-cycle.html" target="_blank" rel="noopener">http://www.runoob.com/servlet/servlet-life-cycle.html</a></p>
<h5 id="HTTP-报文包含内容"><a href="#HTTP-报文包含内容" class="headerlink" title="HTTP 报文包含内容"></a><strong>HTTP 报文包含内容</strong></h5><p>##### </p>
<p><strong>简述三次握手和四次挥手</strong></p>
<p>TCP是TCP/IP的第三层传输层，对应OSI的第四层传输层；<br>IP是TCP/IP的第二层互联层，对应OSI的第三层网络层。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><h5 id="postgresql数据库比mysql好在哪里？"><a href="#postgresql数据库比mysql好在哪里？" class="headerlink" title="postgresql数据库比mysql好在哪里？"></a><strong>postgresql数据库比mysql好在哪里？</strong></h5><p>【1】<a href="http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhangpengme/archive/2011/12/01/2271092.html</a></p>
<h5 id="数据库的左连接，右连接，内连接，外连接"><a href="#数据库的左连接，右连接，内连接，外连接" class="headerlink" title="数据库的左连接，右连接，内连接，外连接"></a><strong>数据库的左连接，右连接，内连接，外连接</strong></h5><p>【1】<a href="http://blog.csdn.net/zj972535075/article/details/50364813" target="_blank" rel="noopener">http://blog.csdn.net/zj972535075/article/details/50364813</a></p>
<h5 id="数据库四个范式"><a href="#数据库四个范式" class="headerlink" title="数据库四个范式"></a><strong>数据库四个范式</strong></h5><p>【1】<a href="https://blog.csdn.net/zymx14/article/details/69789326" target="_blank" rel="noopener">https://blog.csdn.net/zymx14/article/details/69789326</a></p>
<p>【2】<a href="http://blog.csdn.net/famousdt/article/details/6921622" target="_blank" rel="noopener">http://blog.csdn.net/famousdt/article/details/6921622</a><br>【3】<a href="http://www.jb51.net/article/19312.htm" target="_blank" rel="noopener">http://www.jb51.net/article/19312.htm</a></p>
<p>作业：第四种范式的学习</p>
<p><strong>qq：1512079179</strong></p>
<h5 id="数据库事务隔离级别"><a href="#数据库事务隔离级别" class="headerlink" title="数据库事务隔离级别"></a><strong>数据库事务隔离级别</strong></h5><p>四个事务隔离级别概念和脏读、不可重复读、幻读这几类问题的概念。</p>
<ul>
<li>Read uncommitted</li>
<li>Read committed</li>
<li>Repeatable read</li>
<li>Serializable<br>这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li>
</ul>
<p>【1】<a href="http://blog.csdn.net/fg2006/article/details/6937413" target="_blank" rel="noopener">http://blog.csdn.net/fg2006/article/details/6937413</a></p>
<h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><strong>乐观锁和悲观锁</strong></h5><p>乐观锁和悲观锁的概念，乐观锁实现：第一种是使用版本号（hibernate乐观锁），第二种是使用时间戳。</p>
<p>【１】<a href="http://www.cnblogs.com/wang-meng/p/5506943.html" target="_blank" rel="noopener">http://www.cnblogs.com/wang-meng/p/5506943.html</a></p>
<h5 id="排他锁、共享锁"><a href="#排他锁、共享锁" class="headerlink" title="排他锁、共享锁"></a>排他锁、共享锁</h5><p>共享锁概念：<br><strong>注意：</strong>一个事务获取了共享锁，在其他查询中也只能加共享锁或不加锁。</p>
<p>排他锁概念：<br><strong>注意：</strong>排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。</p>
<p><strong>注意：</strong>排他锁与共享锁不能存在同一数据上。</p>
<p>【1】<a href="http://blog.csdn.net/c466254931/article/details/53463596" target="_blank" rel="noopener">http://blog.csdn.net/c466254931/article/details/53463596</a></p>
<h5 id="数据库索引类型及实现方式（重要）"><a href="#数据库索引类型及实现方式（重要）" class="headerlink" title="数据库索引类型及实现方式（重要）"></a><strong>数据库索引类型及实现方式（重要）</strong></h5><p><strong>索引的优缺点:</strong></p>
<p>唯一索引：   UNIQUE<br>主键索引：   primary key<br>聚集索引（也叫聚簇索引）：cluster <strong>概念</strong>等等</p>
<p>【1】<a href="http://www.cnblogs.com/barrywxx/p/4351901.html" target="_blank" rel="noopener">http://www.cnblogs.com/barrywxx/p/4351901.html</a></p>
<p>【2】<a href="https://blog.csdn.net/zc474235918/article/details/50580639" target="_blank" rel="noopener">https://blog.csdn.net/zc474235918/article/details/50580639</a></p>
<p>【2】<a href="http://www.cnblogs.com/terryglp/articles/2450197.html" target="_blank" rel="noopener">http://www.cnblogs.com/terryglp/articles/2450197.html</a></p>
<p>作业：聚集索引与非聚集索引的对比和学习。</p>
<p> <strong>SQL单一索引与联合索引区别:</strong></p>
<p>【1】<a href="http://blog.csdn.net/shellching/article/details/7655793" target="_blank" rel="noopener">http://blog.csdn.net/shellching/article/details/7655793</a></p>
<p>作业：为什么联合索引快或者联合索引的原理是什么？</p>
<p><strong>索引的实现方式：</strong></p>
<ul>
<li>B+树</li>
<li>散列索引</li>
<li>位图索引：位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，<strong>只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势</strong>。</li>
</ul>
<p>【1】<a href="https://blog.csdn.net/sdgihshdv/article/details/75039825" target="_blank" rel="noopener">https://blog.csdn.net/sdgihshdv/article/details/75039825</a></p>
<h5 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h5><p>1）explain语句</p>
<p>2）SQL语句的优化</p>
<p>3）索引</p>
<p>【1】<a href="https://blog.csdn.net/huangwenyi1010/article/details/72673447" target="_blank" rel="noopener">https://blog.csdn.net/huangwenyi1010/article/details/72673447</a></p>
<p>作业：分库、分表</p>
<p>qq：<a href="mailto:1512079179@qq.com" target="_blank" rel="noopener">1512079179@qq.com</a></p>
<h5 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a><strong>执行计划</strong></h5><p>explain语句</p>
<p>【1】<a href="http://toplchx.iteye.com/blog/2091860" target="_blank" rel="noopener">http://toplchx.iteye.com/blog/2091860</a></p>
<h5 id="事务4大特性"><a href="#事务4大特性" class="headerlink" title="事务4大特性"></a><strong>事务4大特性</strong></h5><ul>
<li>原子性(Atomicity)</li>
<li>一致性(Consistency)    </li>
<li>分离性(亦称独立性Isolation)</li>
<li>持久性(Durability)</li>
</ul>
<p>原子性(Atomicity)：要么全部执行，要么完全不执行</p>
<p>一致性(Consistency) 实例：拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>【1】<a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">http://www.cnblogs.com/fjdingsd/p/5273008.html</a></p>
<h5 id="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"><a href="#在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？" class="headerlink" title="在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"></a><strong>在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？</strong></h5><ul>
<li>办法一，建立分区表，按照用户浏览的记录数进行分区。</li>
<li>办法二，单独建立一张表，存放这样的信息。这张表就两个列，用户id和浏览量，这种思想叫冗余表。但是需要注意的是冗余表的建立，可以大幅提供效率，但会增加数据库维护的成本，需要综合考虑是否合适。</li>
<li>办法三，使用mongodb这样的nosql数据库。mongodb是一个文档型的nosql数据库，创建表的时候，增加两个列，一个保存浏览量，一个保存具体的浏览记录。这种方式跟冗余表的思想是一样的</li>
</ul>
<p>【1】<a href="http://blog.csdn.net/lgb934/article/details/8662956" target="_blank" rel="noopener">http://blog.csdn.net/lgb934/article/details/8662956</a></p>
<h5 id="关于数据库where和having的区别，执行顺序、group-by-与having如何使用（重要）"><a href="#关于数据库where和having的区别，执行顺序、group-by-与having如何使用（重要）" class="headerlink" title="关于数据库where和having的区别，执行顺序、group by 与having如何使用（重要）"></a><strong>关于数据库where和having的区别，执行顺序、group by 与having如何使用（重要）</strong></h5><p>【1】<a href="http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118" target="_blank" rel="noopener">http://blog.csdn.net/my773962804/article/details/51538790?_t_t_t=0.17189185717143118</a></p>
<p>【2】<a href="https://blog.csdn.net/bingogirl/article/details/52559302" target="_blank" rel="noopener">https://blog.csdn.net/bingogirl/article/details/52559302</a></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><h5 id="分布式锁的实现（重要）"><a href="#分布式锁的实现（重要）" class="headerlink" title="分布式锁的实现（重要）"></a><strong>分布式锁的实现（重要）</strong></h5><p>【1】<a href="https://my.oschina.net/u/1995545/blog/366381" target="_blank" rel="noopener">https://my.oschina.net/u/1995545/blog/366381</a></p>
<p>作业：setNX内部的实现原理</p>
<p>qq：<a href="mailto:1512079179@qq.com" target="_blank" rel="noopener">1512079179@qq.com</a></p>
<h5 id="5种数据类型"><a href="#5种数据类型" class="headerlink" title="5种数据类型"></a><strong>5种数据类型</strong></h5><ul>
<li>全局key操作</li>
<li>String（字符串）</li>
<li>Hashes类型:(map)</li>
<li>List类型</li>
<li>set类型</li>
<li>Sorted-Sets类型</li>
</ul>
<p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51354188" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51354188</a></p>
<h5 id="Redis两种持久化方式及原理"><a href="#Redis两种持久化方式及原理" class="headerlink" title="Redis两种持久化方式及原理"></a><strong>Redis两种持久化方式及原理</strong></h5><p><strong>Redis的持久化策略：</strong><br>rdb:快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略<br>aof：把所有的对redis的服务器进行修改的命令都存到一个文件里，命令的集合</p>
<p>【1】<a href="http://blog.csdn.net/u010785685/article/details/52366977" target="_blank" rel="noopener">http://blog.csdn.net/u010785685/article/details/52366977</a></p>
<h5 id="Redis与Memcache区别"><a href="#Redis与Memcache区别" class="headerlink" title="Redis与Memcache区别"></a><strong>Redis与Memcache区别</strong></h5><p>redis和memecache的不同在于：</p>
<ul>
<li><p>存储方式：<br>  memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小</p>
<p>  redis有部份存在硬盘上，这样能保证数据的持久性，支持数据的持久化（笔者注：有快照和AOF日志两种持久化方式，在实际应用的时候，要特别注意配置文件快照参数，要不就很有可能服务器频繁满载做dump）。</p>
</li>
<li><p>数据支持类型：<br>  redis在数据支持上要比memecache多的多。</p>
<p>  ​</p>
</li>
</ul>
<ul>
<li><p>应用场景不一样：</p>
<p>Redis除了作为NoSQL数据库使用外，还能用做消息队列、数据堆栈和数据缓存等；Memcached适合于缓存SQL语句、数据集、用户临时性数据、延迟查询数据和session等。</p>
</li>
</ul>
<p>Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；  </p>
<p>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；  </p>
<p>虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；  </p>
<p>过期策略–memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；  </p>
<p>分布式–设定memcache集群，利用magent做一主多从;redis可以做一主多从，也都可以一主一从；  </p>
<p>存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；  </p>
<p>灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；  </p>
<p>Redis支持数据的备份，即master-slave模式的数据备份；  </p>
<p>【1】<a href="http://blog.csdn.net/sunmenggmail/article/details/36176029" target="_blank" rel="noopener">http://blog.csdn.net/sunmenggmail/article/details/36176029</a></p>
<h5 id="redis是多线程还是单线程"><a href="#redis是多线程还是单线程" class="headerlink" title="redis是多线程还是单线程"></a>redis是多线程还是单线程</h5><p>驴妈妈旅游网上的面试题</p>
<p>【2】<a href="http://www.cnblogs.com/yuyutianxia/p/6346723.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuyutianxia/p/6346723.html</a></p>
<p>【1】<a href="http://www.cnblogs.com/syyong/p/6231326.html" target="_blank" rel="noopener">http://www.cnblogs.com/syyong/p/6231326.html</a></p>
<p>Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。</p>
<h3 id="单进程单线程好处"><a href="#单进程单线程好处" class="headerlink" title="单进程单线程好处"></a>单进程单线程好处</h3><ol>
<li>代码更清晰，处理逻辑更简单</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
<li>不存在多进程或者多线程导致的切换而消耗CPU</li>
</ol>
<h3 id="单进程单线程弊端"><a href="#单进程单线程弊端" class="headerlink" title="单进程单线程弊端"></a>单进程单线程弊端</h3><ol>
<li>无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li>
</ol>
<h5 id="redis订阅-发布"><a href="#redis订阅-发布" class="headerlink" title="redis订阅/发布"></a><strong>redis订阅/发布</strong></h5><p>【1】<a href="http://blog.csdn.net/huangwenyi1010/article/details/51376197" target="_blank" rel="noopener">http://blog.csdn.net/huangwenyi1010/article/details/51376197</a></p>
<p>redis  订阅/发布 应用场景</p>
<h5 id="redis分布式（主从模式）"><a href="#redis分布式（主从模式）" class="headerlink" title="redis分布式（主从模式）**"></a>redis分布式（主从模式）**</h5><p>【1】<a href="https://www.cnblogs.com/dtiove/p/5842013.html" target="_blank" rel="noopener">https://www.cnblogs.com/dtiove/p/5842013.html</a></p>
<p>【2】<a href="https://blog.csdn.net/donggang1992/article/details/50981341" target="_blank" rel="noopener">https://blog.csdn.net/donggang1992/article/details/50981341</a></p>
<p><strong>redis实现消息队列</strong></p>
<p>【1】<a href="http://www.runoob.com/redis/redis-lists.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-lists.html</a></p>
<p>【2】<a href="https://blog.csdn.net/ZuoAnYinXiang/article/details/50263945" target="_blank" rel="noopener">https://blog.csdn.net/ZuoAnYinXiang/article/details/50263945</a></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><h5 id="门面模式的解释，适用场合"><a href="#门面模式的解释，适用场合" class="headerlink" title="门面模式的解释，适用场合"></a><strong>门面模式的解释，适用场合</strong></h5><p>【1】<a href="http://www.cnblogs.com/lthIU/p/5860607.html" target="_blank" rel="noopener">http://www.cnblogs.com/lthIU/p/5860607.html</a></p>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a><strong>Hibernate</strong></h3><p><strong>Hibernate工作原理</strong></p>
<p>【1】<a href="https://blog.csdn.net/huangwenyi1010/article/details/68923405" target="_blank" rel="noopener">https://blog.csdn.net/huangwenyi1010/article/details/68923405</a></p>
<p><strong>Hibernate的3种对象状态</strong></p>
<p>【1】<a href="https://blog.csdn.net/huangwenyi1010/article/details/68923405" target="_blank" rel="noopener">https://blog.csdn.net/huangwenyi1010/article/details/68923405</a></p>
<p><strong>Hibernate四种查询</strong></p>
<p>【1】<a href="https://blog.csdn.net/huangwenyi1010/article/details/68923405" target="_blank" rel="noopener">https://blog.csdn.net/huangwenyi1010/article/details/68923405</a></p>
<h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h3><p>JVM虚拟机内存模型</p>
<p>堆内存模型</p>
<p>【1】<a href="http://www.cnblogs.com/AloneSword/p/4262255.html" target="_blank" rel="noopener">http://www.cnblogs.com/AloneSword/p/4262255.html</a></p>
<p><strong>垃圾回收算法：（重要）</strong></p>
<ul>
<li>引用计数算法</li>
<li>根搜索算法</li>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>分代收集算法</li>
<li>CMS算法：Concurrent Mark Sweep/CMS是一款并发、使用标记-清除算法的gc。（<a href="http://www.cnblogs.com/Leo_wl/p/5393300.html" target="_blank" rel="noopener">http://www.cnblogs.com/Leo_wl/p/5393300.html</a> 或者 <a href="http://blog.csdn.net/aibisoft/article/details/27555793）" target="_blank" rel="noopener">http://blog.csdn.net/aibisoft/article/details/27555793）</a></li>
</ul>
<p>【1】<a href="https://blog.csdn.net/wen7280/article/details/54428387" target="_blank" rel="noopener">https://blog.csdn.net/wen7280/article/details/54428387</a></p>
<h3 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a><strong>Linux常用命令</strong></h3><h5 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a><strong>基础命令</strong></h5><p>【1】<a href="http://www.cnblogs.com/laov/p/3541414.html" target="_blank" rel="noopener">http://www.cnblogs.com/laov/p/3541414.html</a></p>
<ul>
<li>回答基本的常用命令</li>
<li>回答具体的使用场景，比如你经常在linux下安装tomcat，jdk，redis，或者说用linux搭建一些集群环境。</li>
<li>回答一些高深的命令，比如管道命令</li>
</ul>
<h5 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a><strong>管道命令</strong></h5><p>【1】<a href="http://www.cnblogs.com/mrzero/p/3985302.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrzero/p/3985302.html</a></p>
<p>【2】<a href="http://blog.csdn.net/morning99/article/details/23753851" target="_blank" rel="noopener">http://blog.csdn.net/morning99/article/details/23753851</a></p>
<p>【3】<a href="http://blog.csdn.net/lgstudyvc/article/details/51916268" target="_blank" rel="noopener">http://blog.csdn.net/lgstudyvc/article/details/51916268</a></p>
<p>管道符号，是unix功能强大的一个地方,符号是一条竖线:”|”，</p>
<p>用法: command 1 | command 2 他的功能是把第一个命令command 1执行的结果作为command 2的输入传给command 2，</p>
<p>例如:</p>
<p>​    ls -l | more</p>
<p>该命令列出当前目录中的任何文档，并把输出送给more命令作为输入，more命令分页显示文件列表。</p>
<p>又如 </p>
<p>​    rpm -aq | less</p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h3><h5 id="Tomcat性能调优"><a href="#Tomcat性能调优" class="headerlink" title="Tomcat性能调优"></a><strong>Tomcat性能调优</strong></h5><ul>
<li>JVM参数调优</li>
<li>NIO协议</li>
<li>线程池和连接数配置</li>
<li>禁用AJP协议</li>
</ul>
<h5 id="Tomcat启动时加载数据到缓存"><a href="#Tomcat启动时加载数据到缓存" class="headerlink" title="Tomcat启动时加载数据到缓存"></a><strong>Tomcat启动时加载数据到缓存</strong></h5><p>【1】<a href="http://lilinhui.iteye.com/blog/808816" target="_blank" rel="noopener">http://lilinhui.iteye.com/blog/808816</a></p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h3><h5 id="git如何回退到某个历史版本"><a href="#git如何回退到某个历史版本" class="headerlink" title="git如何回退到某个历史版本"></a><strong>git如何回退到某个历史版本</strong></h5><p>【1】<a href="http://blog.csdn.net/newjueqi/article/details/49098123" target="_blank" rel="noopener">http://blog.csdn.net/newjueqi/article/details/49098123</a></p>
<h5 id="SVN和Git优缺点比较"><a href="#SVN和Git优缺点比较" class="headerlink" title="SVN和Git优缺点比较"></a><strong>SVN和Git优缺点比较</strong></h5><p>【1】<a href="http://blog.csdn.net/yuwq123/article/details/52748009" target="_blank" rel="noopener">http://blog.csdn.net/yuwq123/article/details/52748009</a></p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a><strong>JDBC</strong></h3><h5 id="Statement与PreparedStatement的区别"><a href="#Statement与PreparedStatement的区别" class="headerlink" title="Statement与PreparedStatement的区别?"></a><strong>Statement与PreparedStatement的区别?</strong></h5><p>【1】<a href="http://blog.csdn.net/haorengoodman/article/details/23995347" target="_blank" rel="noopener">http://blog.csdn.net/haorengoodman/article/details/23995347</a></p>
<ul>
<li><p>创建时的区别： </p>
<p>​Statement statement = conn.createStatement();</p>
<p>​    PreparedStatement preStatement = conn.prepareStatement(sql);</p>
</li>
</ul>
<p>​<br>执行的时候: </p>
<p>​    ResultSet rSet = statement.executeQuery(sql);</p>
<p>​    ResultSet pSet = preStatement.executeQuery();</p>
<p>由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，而 statement 不同，如果执行多变，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些。所以总体而言， 验证  preStatement 的效率 比 Statement 的效率高</p>
<ul>
<li>安全性问题</li>
</ul>
<p>preStatement是预编译的，所以可以有效的防止 SQL注入等问题。所以 preStatement 的安全性 比 Statement 高</p>
<ul>
<li>代码的可读性 和 可维护性 </li>
</ul>
<p>这点也不用多说了，你看老代码的时候  会深有体会preStatement更胜一筹</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h3><h5 id="MyBatis如何唯一标识一个SQL语句"><a href="#MyBatis如何唯一标识一个SQL语句" class="headerlink" title="MyBatis如何唯一标识一个SQL语句"></a><strong>MyBatis如何唯一标识一个SQL语句</strong></h5><h5 id="Hibernate和MyBatis如何映射一对多关系"><a href="#Hibernate和MyBatis如何映射一对多关系" class="headerlink" title="Hibernate和MyBatis如何映射一对多关系"></a><strong>Hibernate和MyBatis如何映射一对多关系</strong></h5><p>【1】<a href="http://www.cnblogs.com/liujiayun/p/5814158.html" target="_blank" rel="noopener">http://www.cnblogs.com/liujiayun/p/5814158.html</a></p>
<p>【2】<a href="http://blog.csdn.net/suwu150/article/details/52896459" target="_blank" rel="noopener">http://blog.csdn.net/suwu150/article/details/52896459</a></p>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端**"></a>前端**</h3><h5 id="ajax原理"><a href="#ajax原理" class="headerlink" title="ajax原理"></a><strong>ajax原理</strong></h5><p>【1】<a href="http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html" target="_blank" rel="noopener">http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html</a></p>
<h3 id="算法面试题"><a href="#算法面试题" class="headerlink" title="算法面试题"></a><strong>算法面试题</strong></h3><p>现在有1000瓶药水，其中至多有1瓶是有剧毒的，现在给你10只狗，在24小时内通过小狗试药的方式，</p>
<p>找出那些药有毒或者全部没毒（小狗服完药20小时之后才能判断是否中毒）。</p>
<p>【1】<a href="http://blog.csdn.net/sancho_lai/article/details/3218786" target="_blank" rel="noopener">http://blog.csdn.net/sancho_lai/article/details/3218786</a></p>
<h3 id="数据库分库分表（重要）"><a href="#数据库分库分表（重要）" class="headerlink" title="数据库分库分表（重要）"></a>数据库分库分表（重要）</h3><p>垂直和水平</p>
<p>下面是笔者整理的jdk自带的常用命令行工具的使用方法，全部原创，转载请注明出处，并贴上链接，谢谢！</p>
<ul>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46319033" target="_blank" rel="noopener"><strong>jps命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46319355" target="_blank" rel="noopener"><strong>jstat命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46336839" target="_blank" rel="noopener"><strong>jinfo命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46337339" target="_blank" rel="noopener"><strong>jmap命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46337535" target="_blank" rel="noopener"><strong>jhat命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46364339" target="_blank" rel="noopener"><strong>jstack命令使用</strong></a></li>
<li><a href="http://blog.csdn.net/winwill2012/article/details/46364849" target="_blank" rel="noopener"><strong>jcmd命令使用</strong></a></li>
</ul>
<h3 id="后台系统怎么防止请求重复提交"><a href="#后台系统怎么防止请求重复提交" class="headerlink" title="后台系统怎么防止请求重复提交"></a><strong>后台系统怎么防止请求重复提交</strong></h3><p>【1】<a href="http://blog.csdn.net/hshl1214/article/details/46635905" target="_blank" rel="noopener">http://blog.csdn.net/hshl1214/article/details/46635905</a></p>
<h3 id="有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。"><a href="#有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。"></a><strong>有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。</strong></h3><p>【1】<a href="http://www.cnblogs.com/children/archive/2012/10/02/2710624.html" target="_blank" rel="noopener">http://www.cnblogs.com/children/archive/2012/10/02/2710624.html</a></p>
<h3 id="反射中，Class-forName-和-ClassLoader-区别"><a href="#反射中，Class-forName-和-ClassLoader-区别" class="headerlink" title="反射中，Class.forName 和 ClassLoader 区别"></a><strong>反射中，Class.forName 和 ClassLoader 区别</strong></h3><h3 id="描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="描述动态代理的几种实现方式，分别说出相应的优缺点。"></a><strong>描述动态代理的几种实现方式，分别说出相应的优缺点。</strong></h3><p>【1】<a href="http://blog.csdn.net/kyi_zhu123/article/details/52644624" target="_blank" rel="noopener">http://blog.csdn.net/kyi_zhu123/article/details/52644624</a></p>
<h3 id="在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。"><a href="#在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。" class="headerlink" title="在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。"></a><strong>在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。</strong></h3><ol>
<li><a href="http://blog.csdn.net/bbirdsky/article/details/8283143" target="_blank" rel="noopener">http://blog.csdn.net/bbirdsky/article/details/8283143</a>  </li>
<li>字符串类(Java.lang.String)是Java中使用最多的类，也是最为特殊的一个类，很多时候，我们对它既熟悉又陌生。在很多面试题中经常用String大做文章，只要掌握了String特性，对付它们就不再是困难了。  </li>
<li>1、从根本上认识java.lang.String类和String池  </li>
<li>首先，我建议先看看String类的源码实现，这是从本质上认识String类的根本出发点。  </li>
<li>从源码中可以看到：  </li>
<li>String类是final的，不可被继承。public final class String。  </li>
<li>String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];  </li>
<li>​</li>
<li>然后打开String类的API文档，从API中可以发现：  </li>
<li>String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。  </li>
<li>String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联，这个后面会讲述。  </li>
<li>Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。  </li>
<li>​</li>
<li>2、创建字符串的方式  </li>
<li>创建字符串的方式很多，归纳起来有三类：  </li>
<li>使用new关键字创建字符串，比如String s1 = new String(“abc”);  </li>
<li>直接指定。比如String s2 = “abc”;  </li>
<li>使用串联生成新的字符串。比如String s3 = “ab” + “c”。  </li>
<li>​</li>
<li>3、String对象的创建的特性  </li>
<li>String对象的创建也很讲究，关键是要明白其原理。  </li>
<li>​</li>
<li>特性1：  </li>
<li>当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个字符串的内容在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。  </li>
<li>​</li>
<li>特性2：  </li>
<li>Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。  </li>
<li>​</li>
<li>特性3：  </li>
<li>使用直接指定、使用纯字符串串联或者在编译期间可以确定结果的变量表达式来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象；  </li>
<li>1、 直接指定，例如：下面代码运行结果为true；  </li>
<li>String str1 = “abc”;  </li>
<li>String str2 = “abc”;  </li>
<li>System.out.println(str1 == str2);  </li>
<li>2、 使用纯字符串串联，例如：下面代码运行结果为true；  </li>
<li>String str1 = “abc”;  </li>
<li>String str2 = “ab” + “c”;  </li>
<li>System.out.println(str1 == str2);  </li>
<li>3、 在编译期间可以确定结果的变量表达式，例如：下面代码运行结果为true。  </li>
<li>final String str1 = “c”; //final类型的变量在编译时当常量处理  </li>
<li>String str2 = “ab” + “c”;  </li>
<li>String str3 = “ab” + str1;  </li>
<li>System.out.println(str2==str3);  </li>
<li>​</li>
<li>否则使用包含编译期间无法确定结果的变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String（由StringBuilder.toString()生成）对象。  </li>
<li>1、普通变量表达式进行创建字符串，例如：下面代码运行结果为false；  </li>
<li>String str1 = “c”;  </li>
<li>String str2 = “ab” + “c”;  </li>
<li>String str3 = “ab” + str1;  </li>
<li>System.out.println(str2==str3);  </li>
</ol>
<h3 id="人事问题（补充）"><a href="#人事问题（补充）" class="headerlink" title="人事问题（补充）"></a><strong>人事问题（补充）</strong></h3><p>在面试过程中，当你技术面试过关之后，通常会有一个HR面试，一般到这里说明你基本已经通过了面试，但是你还是不能松懈的，这一面也是不容小觑的。比如HR经常会问你这些问题：</p>
<ul>
<li>你为什么要离职啊？</li>
<li>你对我们公司还有什么要了解的吗？</li>
<li>你能支持经常出差吗？或者能支持经常加班吗？</li>
<li>你上一家公司的薪资是多少？</li>
<li>你手里拿到多少个offer了？</li>
<li>如果我们公司的薪资达不到你的要求，你会考虑留下来吗？</li>
<li>等等一系列的问题。</li>
</ul>

      
    </div>
    
    
    
	
	<div>
  
    ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.png" alt="郭 琪 wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/06/Java多线程问题总结/" rel="next" title="Java多线程问题总结">
                <i class="fa fa-chevron-left"></i> Java多线程问题总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/09/选择排序原理/" rel="prev" title="选择排序原理">
                选择排序原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        ﻿ <!--MOB SHARE BEGIN-->
                                <div class="-mob-share-ui-button -mob-share-open">分享</div>
                                <div class="-mob-share-ui" style="display: none">
                                    <ul class="-mob-share-list">
                                        <li class="-mob-share-weibo"><p>新浪微博</p></li>
                                        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
                                        <li class="-mob-share-qzone"><p>QQ空间</p></li>
                                        <li class="-mob-share-qq"><p>QQ好友</p></li>
                                        <li class="-mob-share-weixin"><p>微信</p></li>
                                        <li class="-mob-share-douban"><p>豆瓣</p></li>
                                        <li class="-mob-share-renren"><p>人人网</p></li>
                                        <li class="-mob-share-kaixin"><p>开心网</p></li>
                                        <li class="-mob-share-facebook"><p>Facebook</p></li>
                                        <li class="-mob-share-twitter"><p>Twitter</p></li>
                                        <li class="-mob-share-pocket"><p>Pocket</p></li>
                                        <li class="-mob-share-google"><p>Google+</p></li>
                                        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
                                        <li class="-mob-share-mingdao"><p>明道</p></li>
                                        <li class="-mob-share-pengyou"><p>朋友网</p></li>
                                        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
                                        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
                                        <li class="-mob-share-linkedin"><p>LinkedIn</p></li>
                                    </ul>
                                    <div class="-mob-share-close">取消</div>
                                </div>
                                <div class="-mob-share-ui-bg"></div>
                                <script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=25e1879146e04"></script>
                                <!--MOB SHARE END-->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjU4Ny8xMzEyMg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="郭 琪" />
            
              <p class="site-author-name" itemprop="name">郭 琪</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

                        
          </nav>
          
          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/guoqick" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:guoqi303@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/6293906909" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-globe"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/gqhpstar/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/2cd89e69f92a" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.imooc.com/" title="慕课网" target="_blank">慕课网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.csdn.net/" title="CSDN官方" target="_blank">CSDN官方</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String-StringBuffer-与-StringBuilder的区别"><span class="nav-number">1.0.1.</span> <span class="nav-text">String , StringBuffer 与 StringBuilder的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Vector，ArrayList，LinkedList的区别"><span class="nav-number">1.0.2.</span> <span class="nav-text">Vector，ArrayList，LinkedList的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List如何去除重复数据"><span class="nav-number">1.0.3.</span> <span class="nav-text">List如何去除重复数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自己手动实现一个线程池"><span class="nav-number">1.0.4.</span> <span class="nav-text">自己手动实现一个线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java字节流和字符流的区别"><span class="nav-number">1.0.5.</span> <span class="nav-text">Java字节流和字符流的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多线程实现生产者-消费者模式"><span class="nav-number">1.0.6.</span> <span class="nav-text">多线程实现生产者/消费者模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在Java中什么是线程调度？"><span class="nav-number">1.0.7.</span> <span class="nav-text">在Java中什么是线程调度？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程与进程的区别？"><span class="nav-number">1.0.8.</span> <span class="nav-text">线程与进程的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在线程中你怎么处理不可控制异常"><span class="nav-number">1.0.9.</span> <span class="nav-text">在线程中你怎么处理不可控制异常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashTable，HashMap，TreeMap的区别"><span class="nav-number">1.0.10.</span> <span class="nav-text">HashTable，HashMap，TreeMap的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IO-BIO-NIO-AIO编程模型"><span class="nav-number">1.0.11.</span> <span class="nav-text">IO,BIO,NIO,AIO编程模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeMap实现原理"><span class="nav-number">1.0.12.</span> <span class="nav-text">TreeMap实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap实现原理"><span class="nav-number">1.0.13.</span> <span class="nav-text">HashMap实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何判断一棵树-tree-是对称的"><span class="nav-number">1.0.14.</span> <span class="nav-text">如何判断一棵树(tree)是对称的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何生成全局唯一的编码（序列号）"><span class="nav-number">1.0.15.</span> <span class="nav-text">如何生成全局唯一的编码（序列号）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。"><span class="nav-number">1.0.16.</span> <span class="nav-text">关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map实现按照key字典排序，并且按照顺序打印key-和-value"><span class="nav-number">1.0.17.</span> <span class="nav-text">map实现按照key字典排序，并且按照顺序打印key 和 value?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反射"><span class="nav-number">1.0.18.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#syschronized实现原理"><span class="nav-number">1.0.19.</span> <span class="nav-text">syschronized实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#syschronized与重入锁ReenTrantLock的区别"><span class="nav-number">1.0.20.</span> <span class="nav-text">syschronized与重入锁ReenTrantLock的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java多线程"><span class="nav-number">1.0.21.</span> <span class="nav-text">Java多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wait（），notify（）和notifyAll（）"><span class="nav-number">1.0.22.</span> <span class="nav-text">wait（），notify（）和notifyAll（）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#抽象类与接口的区别"><span class="nav-number">1.0.23.</span> <span class="nav-text">抽象类与接口的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equals-hashcode"><span class="nav-number">1.0.24.</span> <span class="nav-text">equals hashcode </span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lambda优点"><span class="nav-number">1.0.25.</span> <span class="nav-text">lambda优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关键字transient"><span class="nav-number">1.0.26.</span> <span class="nav-text">关键字transient</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK-和JRE的区别是什么"><span class="nav-number">1.0.27.</span> <span class="nav-text">JDK 和JRE的区别是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java到底是不是一种纯面向对象语言？"><span class="nav-number">1.0.28.</span> <span class="nav-text">Java到底是不是一种纯面向对象语言？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP请求的header头解析"><span class="nav-number">1.0.29.</span> <span class="nav-text">HTTP请求的header头解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何判断一个对象已经被回收"><span class="nav-number">1.0.30.</span> <span class="nav-text">如何判断一个对象已经被回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。-然后面试官说有了解过重度锁和轻度锁吗"><span class="nav-number">1.0.31.</span> <span class="nav-text">假如有两个线程，一个线程A，一个线程B都会访问一个加锁方法，可能存在并发情况，但是线程B访问频繁，线程A访问次数很少，问如何优化。(然后面试官说有了解过重度锁和轻度锁吗)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有三个线程ID分别是A、B、C-请有多线编程实现，在屏幕上循环打印10次ABCABC…"><span class="nav-number">1.0.32.</span> <span class="nav-text">有三个线程ID分别是A、B、C,请有多线编程实现，在屏幕上循环打印10次ABCABC…</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#将两个有序数组-组合-并为一个-有序数组"><span class="nav-number">1.0.33.</span> <span class="nav-text">将两个有序数组   组合 并为一个 有序数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JAVA值类型和引用类型的区别"><span class="nav-number">1.0.34.</span> <span class="nav-text">JAVA值类型和引用类型的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基本类型转换"><span class="nav-number">1.0.35.</span> <span class="nav-text">基本类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#递归算法笔试题"><span class="nav-number">1.0.36.</span> <span class="nav-text">递归算法笔试题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏和内存溢出区别"><span class="nav-number">1.0.37.</span> <span class="nav-text">内存泄漏和内存溢出区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存溢出和内存泄漏的原因"><span class="nav-number">1.0.38.</span> <span class="nav-text">内存溢出和内存泄漏的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次"><span class="nav-number">1.0.39.</span> <span class="nav-text">子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程循环100次，如此循环50次</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Condition的作用"><span class="nav-number">1.0.40.</span> <span class="nav-text">Condition的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行"><span class="nav-number">1.0.41.</span> <span class="nav-text">现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java多线程中join方法的理解"><span class="nav-number">1.0.42.</span> <span class="nav-text">Java多线程中join方法的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equals-与-hashcode-（重要）"><span class="nav-number">1.0.43.</span> <span class="nav-text">equals() 与 hashcode()  （重要）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Lock接口比synchronized块的优势是什么"><span class="nav-number">1.0.44.</span> <span class="nav-text">Lock接口比synchronized块的优势是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java中-wait-和-sleep-方法的不同"><span class="nav-number">1.0.45.</span> <span class="nav-text">java中 wait 和 sleep 方法的不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是竞争条件？你怎样发现和解决竞争？"><span class="nav-number">1.0.46.</span> <span class="nav-text">什么是竞争条件？你怎样发现和解决竞争？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#你将如何使用thread-dump？你将如何分析Thread-dump"><span class="nav-number">1.0.47.</span> <span class="nav-text">你将如何使用thread dump？你将如何分析Thread dump</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在Java中CycliBarriar和CountdownLatch有什么区别"><span class="nav-number">1.0.48.</span> <span class="nav-text">在Java中CycliBarriar和CountdownLatch有什么区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java并发编程-Executor框架集"><span class="nav-number">1.0.49.</span> <span class="nav-text">Java并发编程-Executor框架集</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对象的四种引用类型"><span class="nav-number">1.0.50.</span> <span class="nav-text">对象的四种引用类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java中Atomic包的原理和分析"><span class="nav-number">1.0.51.</span> <span class="nav-text">Java中Atomic包的原理和分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">2.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态代理实现日志管理"><span class="nav-number">2.0.1.</span> <span class="nav-text">动态代理实现日志管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring框架有哪些主要模块"><span class="nav-number">2.0.2.</span> <span class="nav-text">Spring框架有哪些主要模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#控制反转-IOC-？什么是依赖注入（DI）"><span class="nav-number">2.0.3.</span> <span class="nav-text">控制反转(IOC)？什么是依赖注入（DI）?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IOC-DI-原理（重要）"><span class="nav-number">2.0.4.</span> <span class="nav-text">IOC(DI)原理（重要）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#依然注入三种实现方式"><span class="nav-number">2.0.5.</span> <span class="nav-text">依然注入三种实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-Bean作用域之间的区别"><span class="nav-number">2.0.6.</span> <span class="nav-text">Spring Bean作用域之间的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring有几种配置方式"><span class="nav-number">2.0.7.</span> <span class="nav-text">Spring有几种配置方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请解释Spring-Bean的生命周期"><span class="nav-number">2.0.8.</span> <span class="nav-text">请解释Spring Bean的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自动装配模式的区别"><span class="nav-number">2.0.9.</span> <span class="nav-text">自动装配模式的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何开启基于注解的自动装配"><span class="nav-number">2.0.10.</span> <span class="nav-text">如何开启基于注解的自动装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring框架中有哪些不同类型的事件"><span class="nav-number">2.0.11.</span> <span class="nav-text">Spring框架中有哪些不同类型的事件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanFactory和ApplicationContext有什么区别"><span class="nav-number">2.0.12.</span> <span class="nav-text">BeanFactory和ApplicationContext有什么区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三种较常见的-ApplicationContext-实现方式"><span class="nav-number">2.0.13.</span> <span class="nav-text">三种较常见的 ApplicationContext 实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何用基于Java配置的方式配置Spring"><span class="nav-number">2.0.14.</span> <span class="nav-text">如何用基于Java配置的方式配置Spring</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring中注入一个Java-Collection"><span class="nav-number">2.0.15.</span> <span class="nav-text">Spring中注入一个Java Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileSystemResource和ClassPathResource有何区别"><span class="nav-number">2.0.16.</span> <span class="nav-text">FileSystemResource和ClassPathResource有何区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-框架中都用到了哪些设计模式"><span class="nav-number">2.0.17.</span> <span class="nav-text">Spring 框架中都用到了哪些设计模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot"><span class="nav-number">3.</span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Struts"><span class="nav-number">4.</span> <span class="nav-text">Struts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet"><span class="nav-number">5.</span> <span class="nav-text">Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Post，Get请求区别"><span class="nav-number">5.0.1.</span> <span class="nav-text">Post，Get请求区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session-Cookie区别"><span class="nav-number">5.0.2.</span> <span class="nav-text">Session, Cookie区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet的生命周期"><span class="nav-number">5.0.3.</span> <span class="nav-text">Servlet的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-报文包含内容"><span class="nav-number">5.0.4.</span> <span class="nav-text">HTTP 报文包含内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库"><span class="nav-number">6.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#postgresql数据库比mysql好在哪里？"><span class="nav-number">6.0.1.</span> <span class="nav-text">postgresql数据库比mysql好在哪里？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库的左连接，右连接，内连接，外连接"><span class="nav-number">6.0.2.</span> <span class="nav-text">数据库的左连接，右连接，内连接，外连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库四个范式"><span class="nav-number">6.0.3.</span> <span class="nav-text">数据库四个范式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库事务隔离级别"><span class="nav-number">6.0.4.</span> <span class="nav-text">数据库事务隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#乐观锁和悲观锁"><span class="nav-number">6.0.5.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排他锁、共享锁"><span class="nav-number">6.0.6.</span> <span class="nav-text">排他锁、共享锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据库索引类型及实现方式（重要）"><span class="nav-number">6.0.7.</span> <span class="nav-text">数据库索引类型及实现方式（重要）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SQL优化"><span class="nav-number">6.0.8.</span> <span class="nav-text">SQL优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行计划"><span class="nav-number">6.0.9.</span> <span class="nav-text">执行计划</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事务4大特性"><span class="nav-number">6.0.10.</span> <span class="nav-text">事务4大特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？"><span class="nav-number">6.0.11.</span> <span class="nav-text">在1亿条用户记录里，如何快速查询统计出看了5个电影以上的用户？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#关于数据库where和having的区别，执行顺序、group-by-与having如何使用（重要）"><span class="nav-number">6.0.12.</span> <span class="nav-text">关于数据库where和having的区别，执行顺序、group by 与having如何使用（重要）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">7.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分布式锁的实现（重要）"><span class="nav-number">7.0.1.</span> <span class="nav-text">分布式锁的实现（重要）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5种数据类型"><span class="nav-number">7.0.2.</span> <span class="nav-text">5种数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis两种持久化方式及原理"><span class="nav-number">7.0.3.</span> <span class="nav-text">Redis两种持久化方式及原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis与Memcache区别"><span class="nav-number">7.0.4.</span> <span class="nav-text">Redis与Memcache区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis是多线程还是单线程"><span class="nav-number">7.0.5.</span> <span class="nav-text">redis是多线程还是单线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单进程单线程好处"><span class="nav-number">8.</span> <span class="nav-text">单进程单线程好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单进程单线程弊端"><span class="nav-number">9.</span> <span class="nav-text">单进程单线程弊端</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#redis订阅-发布"><span class="nav-number">9.0.1.</span> <span class="nav-text">redis订阅/发布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis分布式（主从模式）"><span class="nav-number">9.0.2.</span> <span class="nav-text">redis分布式（主从模式）**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式"><span class="nav-number">10.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#门面模式的解释，适用场合"><span class="nav-number">10.0.1.</span> <span class="nav-text">门面模式的解释，适用场合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hibernate"><span class="nav-number">11.</span> <span class="nav-text">Hibernate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM虚拟机"><span class="nav-number">12.</span> <span class="nav-text">JVM虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux常用命令"><span class="nav-number">13.</span> <span class="nav-text">Linux常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基础命令"><span class="nav-number">13.0.1.</span> <span class="nav-text">基础命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#管道命令"><span class="nav-number">13.0.2.</span> <span class="nav-text">管道命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat"><span class="nav-number">14.</span> <span class="nav-text">Tomcat</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Tomcat性能调优"><span class="nav-number">14.0.1.</span> <span class="nav-text">Tomcat性能调优</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Tomcat启动时加载数据到缓存"><span class="nav-number">14.0.2.</span> <span class="nav-text">Tomcat启动时加载数据到缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git"><span class="nav-number">15.</span> <span class="nav-text">Git</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#git如何回退到某个历史版本"><span class="nav-number">15.0.1.</span> <span class="nav-text">git如何回退到某个历史版本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SVN和Git优缺点比较"><span class="nav-number">15.0.2.</span> <span class="nav-text">SVN和Git优缺点比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC"><span class="nav-number">16.</span> <span class="nav-text">JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Statement与PreparedStatement的区别"><span class="nav-number">16.0.1.</span> <span class="nav-text">Statement与PreparedStatement的区别?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis"><span class="nav-number">17.</span> <span class="nav-text">MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyBatis如何唯一标识一个SQL语句"><span class="nav-number">17.0.1.</span> <span class="nav-text">MyBatis如何唯一标识一个SQL语句</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hibernate和MyBatis如何映射一对多关系"><span class="nav-number">17.0.2.</span> <span class="nav-text">Hibernate和MyBatis如何映射一对多关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前端"><span class="nav-number">18.</span> <span class="nav-text">前端**</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ajax原理"><span class="nav-number">18.0.1.</span> <span class="nav-text">ajax原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法面试题"><span class="nav-number">19.</span> <span class="nav-text">算法面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库分库分表（重要）"><span class="nav-number">20.</span> <span class="nav-text">数据库分库分表（重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后台系统怎么防止请求重复提交"><span class="nav-number">21.</span> <span class="nav-text">后台系统怎么防止请求重复提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有没有有顺序的Map-实现类，如果有，他们是怎么保证有序的。"><span class="nav-number">22.</span> <span class="nav-text">有没有有顺序的Map 实现类，如果有，他们是怎么保证有序的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射中，Class-forName-和-ClassLoader-区别"><span class="nav-number">23.</span> <span class="nav-text">反射中，Class.forName 和 ClassLoader 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#描述动态代理的几种实现方式，分别说出相应的优缺点。"><span class="nav-number">24.</span> <span class="nav-text">描述动态代理的几种实现方式，分别说出相应的优缺点。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么。"><span class="nav-number">25.</span> <span class="nav-text">在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#人事问题（补充）"><span class="nav-number">26.</span> <span class="nav-text">人事问题（补充）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      
      
      
    
	</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qi Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

  
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
