<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="郭琪的小站" type="application/atom+xml" />






<meta name="description" content="前言java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。 java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持。">
<meta property="og:type" content="article">
<meta property="og:title" content="BIO与NIO、AIO学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/06/03/BIO,NIO,AIO学习笔记/index.html">
<meta property="og:site_name" content="郭琪的小站">
<meta property="og:description" content="前言java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。 java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-4e46ad888ecd59c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-9ce8520cc3d558a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-480f7ddf1d788db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-ee9dde1900e94c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-096c246f211d008d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-2d7f631076e8ecd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-f7ae6b97e9d8158c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-77cb44a820e56481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-7d7a517d14ca4b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-4f05e0bf6b4092fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-6c12c7fbdf8b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-bc98928415f0e3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-cae64631861a6ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/12253573-0c5dc6435ff44191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-06-03T12:12:50.722Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BIO与NIO、AIO学习笔记">
<meta name="twitter:description" content="前言java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。 java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持。">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/12253573-4e46ad888ecd59c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/03/BIO,NIO,AIO学习笔记/"/>





  <title>BIO与NIO、AIO学习笔记 | 郭琪的小站</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">郭琪的小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人生如逆旅，我亦是行人。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tag/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tag"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/category/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/commonweal/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/BIO,NIO,AIO学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭 琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="郭琪的小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">BIO与NIO、AIO学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T15:03:55+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h4><p>java的核心库java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。Java中IO是以流为基础进行输入输出的，所有数据被串行化写入输出流，或者从输入流读入。</p>
<p>java.nio（java non-blocking IO），nio 是non-blocking的简称，是jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。Sun 官方标榜的特性如下： 为所有的原始类型提供(Buffer)<a href="http://baike.baidu.com/item/%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a>支持。<a href="http://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">字符集</a>编码解码解决方案。 Channel ：一个新的原始I/O 抽象。 支持锁和<a href="http://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">内存映射文件</a>的文件访问接口。 提供多路(non-bloking) 非阻塞式的高伸缩性网络I/O 。</p>
<h6 id="大纲目录"><a href="#大纲目录" class="headerlink" title="大纲目录"></a><strong>大纲目录</strong></h6><ul>
<li>1.总体介绍</li>
<li>2.IO基础知识回顾</li>
<li>3.BIO编程</li>
<li>4.伪异步I/O编程</li>
<li>5.NIO 编程简单介绍</li>
<li>6.通道 Channel</li>
<li>7.缓冲区 Buffer</li>
<li>8.选择器 Selector</li>
<li>9.分散（Scatter）/聚集（Gather）</li>
<li>10.其他通道</li>
<li>11.管道（Pipe）</li>
<li>12.AIO编程</li>
</ul>
<h6 id="IO，NIO，JDK介绍"><a href="#IO，NIO，JDK介绍" class="headerlink" title="IO，NIO，JDK介绍**"></a>IO，NIO，JDK介绍**</h6><p>查看JDK</p>
<h4 id="IO基础知识回顾"><a href="#IO基础知识回顾" class="headerlink" title="IO基础知识回顾"></a><strong>IO基础知识回顾</strong></h4><h6 id="IO流类图结构"><a href="#IO流类图结构" class="headerlink" title="IO流类图结构"></a>IO流类图结构</h6><p><img src="https://upload-images.jianshu.io/upload_images/12253573-4e46ad888ecd59c9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IO流知识图.jpg"></p>
<h6 id="IO流简单例子"><a href="#IO流简单例子" class="headerlink" title="IO流简单例子"></a>IO流简单例子</h6><p>实例一：        </p>
<pre><code>FileInputStream fis=null;
FileOutputStream fos=null;
try {
    fis = new FileInputStream(new File(&quot;D:\\a.txt&quot;));
    fos = new FileOutputStream(new File(&quot;D:\\y.txt&quot;));
    int ch;
    while((ch=fis.read()) != -1){
        System.out.println((char)ch);
        fos.write(ch);
    }
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}finally {
    if(null != fos){
        fos.close();
    }
    if(null != fis){
        fis.close();
    }
}
</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12253573-9ce8520cc3d558a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-480f7ddf1d788db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>实例二：字节流转换成字符流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        BufferedWriter bw = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;D:\\a.txt&quot;)));</span><br><span class="line">            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;D:\\y.txt&quot;)));</span><br><span class="line">            String s;</span><br><span class="line">            StringBuilder sb = new StringBuilder();</span><br><span class="line">            while((s=br.readLine())!=null)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                bw.write(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != bw)&#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实例三：用转换流从控制台上读入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        BufferedReader br = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            String s=br.readLine();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if(null != br)&#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="BIO编程"><a href="#BIO编程" class="headerlink" title="BIO编程"></a>BIO编程</h4><h5 id="传统BIO通信模型图"><a href="#传统BIO通信模型图" class="headerlink" title="传统BIO通信模型图"></a><strong>传统BIO通信模型图</strong></h5><p>​    传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行<strong>同步阻塞式</strong>通信。 服务端提供IP和监听端口，客户端通过连接操作想服务端监听的地址发起连接请求，通过三次握手连接，如果连接成功建立，双方就可以通过套接字进行通信。</p>
<p>​    简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。</p>
<p>​    传统BIO通信模型图：</p>
<p>​    <img src="https://upload-images.jianshu.io/upload_images/12253573-ee9dde1900e94c67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>​    该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，<strong>服务端的线程个数和客户端并发访问数呈1:1的正比关系</strong>，<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java</a>中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p>
<h5 id="传统BIO编程实例"><a href="#传统BIO编程实例" class="headerlink" title="传统BIO编程实例"></a><strong>传统BIO编程实例</strong></h5><p>传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">package com.evada.de;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */</span><br><span class="line">public final class AyTest extends BaseTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //启动线程，运行服务器</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ServerBetter.start();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        //避免客户端先于服务器启动前执行代码</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line"></span><br><span class="line">        //启动线程，运行客户端</span><br><span class="line">        char operators[] = &#123;&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;&#125;;</span><br><span class="line">        Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @SuppressWarnings(&quot;static-access&quot;)</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //随机产生算术表达式</span><br><span class="line">                    String expression = random.nextInt(10) + &quot;&quot; + operators[random.nextInt(4)] + (random.nextInt(10) + 1);</span><br><span class="line">                    Client.send(expression);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.currentThread().sleep(random.nextInt(1000));</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ServerBetter&#123;</span><br><span class="line"></span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_PORT = 12345;</span><br><span class="line">    //单例的ServerSocket</span><br><span class="line">    private static ServerSocket server;</span><br><span class="line"></span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值</span><br><span class="line">    public static void start() throws IOException &#123;</span><br><span class="line">        //使用默认值端口</span><br><span class="line">        start(DEFAULT_PORT);</span><br><span class="line">    &#125;</span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了</span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;</span><br><span class="line">        if(server != null) return;</span><br><span class="line">        try&#123;</span><br><span class="line">            //通过构造函数创建ServerSocket，如果端口合法且空闲，服务端就监听成功</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);</span><br><span class="line">            //通过无线循环监听客户端连接，如果没有客户端接入，将阻塞在accept操作上。</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码</span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路</span><br><span class="line">                new Thread(new ServerHandler(socket)).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(server != null)&#123;</span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);</span><br><span class="line">                server.close();</span><br><span class="line">                server = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ServerHandler implements Runnable&#123;</span><br><span class="line">    private Socket socket;</span><br><span class="line">    public ServerHandler(Socket socket) &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            String expression;</span><br><span class="line">            String result;</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                //通过BufferedReader读取一行</span><br><span class="line">                //如果已经读到输入流尾部，返回null,退出循环</span><br><span class="line">                //如果得到非空值，就尝试计算结果并返回</span><br><span class="line">                if((expression = in.readLine())==null) break;</span><br><span class="line">                System.out.println(&quot;服务器收到消息：&quot; + expression);</span><br><span class="line">                try&#123;</span><br><span class="line">                    result = &quot;123&quot;;//Calculator.cal(expression).toString();</span><br><span class="line">                &#125;catch(Exception e)&#123;</span><br><span class="line">                    result = &quot;计算错误：&quot; + e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一些必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Client &#123;</span><br><span class="line">    //默认的端口号</span><br><span class="line">    private static int DEFAULT_SERVER_PORT = 12345;</span><br><span class="line">    //默认服务器Ip</span><br><span class="line">    private static String DEFAULT_SERVER_IP = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    public static void send(String expression)&#123;</span><br><span class="line">        send(DEFAULT_SERVER_PORT,expression);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void send(int port,String expression)&#123;</span><br><span class="line">        System.out.println(&quot;算术表达式为：&quot; + expression);</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader in = null;</span><br><span class="line">        PrintWriter out = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(DEFAULT_SERVER_IP,port);</span><br><span class="line">            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line">            out = new PrintWriter(socket.getOutputStream(),true);</span><br><span class="line">            out.println(expression);</span><br><span class="line">            System.out.println(&quot;___结果为：&quot; + in.readLine());</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            //一下必要的清理工作</span><br><span class="line">            if(in != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                in = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(out != null)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">                out = null;</span><br><span class="line">            &#125;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="伪异步I-O编程"><a href="#伪异步I-O编程" class="headerlink" title="伪异步I/O编程"></a><strong>伪异步I/O编程</strong></h4><p>我们可以使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（<strong>但是底层还是使用的同步阻塞I/O</strong>），通常被称为“伪异步I/O模型“</p>
<h5 id="伪异步I-O编程模型图"><a href="#伪异步I-O编程模型图" class="headerlink" title="伪异步I/O编程模型图"></a>伪异步I/O编程模型图</h5><p><img src="https://upload-images.jianshu.io/upload_images/12253573-096c246f211d008d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="伪异步io流.png"></p>
<p>  测试运行结果是一样的。</p>
<p>​    我们知道，如果使用CachedThreadPool线程池（不限制线程数量，如果不清楚请参考文首提供的文章），其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用<strong>FixedThreadPool</strong>我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型。</p>
<p>​    但是，正因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。而对Socket的输入流就行读取时，会一直阻塞，直到发生：</p>
<ul>
<li>​    有数据可读</li>
<li>​    可用数据以及读取完毕</li>
<li>​    发生空指针或I/O异常</li>
</ul>
<p>​    所以在读取数据较慢时（比如数据量大、网络传输慢等），大量并发的情况下，其他接入的消息，只能一直等待，这就是最大的弊端。</p>
<p>​    而后面即将介绍的NIO，就能解决这个难题。</p>
<h5 id="伪异步IO编程代码"><a href="#伪异步IO编程代码" class="headerlink" title="伪异步IO编程代码"></a><strong>伪异步IO编程代码</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.anxpp.io.calculator.bio;  </span><br><span class="line">import java.io.IOException;  </span><br><span class="line">import java.net.ServerSocket;  </span><br><span class="line">import java.net.Socket;  </span><br><span class="line">import java.util.concurrent.ExecutorService;  </span><br><span class="line">import java.util.concurrent.Executors;  </span><br><span class="line">/**</span><br><span class="line"> * 描述：传统BIO编程实例</span><br><span class="line"> * @author qi</span><br><span class="line"> * @date 2018/6/02</span><br><span class="line"> */ </span><br><span class="line">public final class ServerBetter &#123;  </span><br><span class="line">    //默认的端口号  </span><br><span class="line">    private static int DEFAULT_PORT = 12345;  </span><br><span class="line">    //单例的ServerSocket  </span><br><span class="line">    private static ServerSocket server;  </span><br><span class="line">    //线程池 懒汉式的单例  </span><br><span class="line">    private static ExecutorService executorService = Executors.newFixedThreadPool(60);  </span><br><span class="line">    //根据传入参数设置监听端口，如果没有参数调用以下方法并使用默认值  </span><br><span class="line">    public static void start() throws IOException&#123;  </span><br><span class="line">        //使用默认值  </span><br><span class="line">        start(DEFAULT_PORT);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //这个方法不会被大量并发访问，不太需要考虑效率，直接进行方法同步就行了  </span><br><span class="line">    public synchronized static void start(int port) throws IOException&#123;  </span><br><span class="line">        if(server != null) return;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            //通过构造函数创建ServerSocket  </span><br><span class="line">            //如果端口合法且空闲，服务端就监听成功  </span><br><span class="line">            server = new ServerSocket(port);  </span><br><span class="line">            System.out.println(&quot;服务器已启动，端口号：&quot; + port);  </span><br><span class="line">            //通过无线循环监听客户端连接  </span><br><span class="line">            //如果没有客户端接入，将阻塞在accept操作上。  </span><br><span class="line">            while(true)&#123;  </span><br><span class="line">                Socket socket = server.accept();  </span><br><span class="line">                //当有新的客户端接入时，会执行下面的代码  </span><br><span class="line">                //然后创建一个新的线程处理这条Socket链路  </span><br><span class="line">                executorService.execute(new ServerHandler(socket));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            //一些必要的清理工作  </span><br><span class="line">            if(server != null)&#123;  </span><br><span class="line">                System.out.println(&quot;服务器已关闭。&quot;);  </span><br><span class="line">                server.close();  </span><br><span class="line">                server = null;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1,同步和异步是针对应用程序和内核的交互而言的。 </li>
<li>2,阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。  </li>
</ul>
<p>由上描述基本可以总结一句简短的话，<strong>同步和异步是目的，阻塞和非阻塞是实现方式</strong>。</p>
<p><strong>同步阻塞：</strong><br>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。 </p>
<p><strong>同步非阻塞：</strong><br>在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。<br><strong>异步：</strong><br>此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。</p>
<p>如果你想吃一份宫保鸡丁盖饭： </p>
<p>同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！ </p>
<p>同步非阻塞（NIO）：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！ </p>
<p>异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。 </p>
<p>异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。</p>
<h4 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h5><p>Java NIO(New IO)是一个可以替代标准Java IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<p>Java NIO 由以下几个核心部分组成： </p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，但Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，我将集中精力在这三个组件上。其它组件会在单独的章节中讲到。 </p>
<p>注意（每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送响应）</p>
<h5 id="非常形象的实例"><a href="#非常形象的实例" class="headerlink" title="非常形象的实例"></a><strong>非常形象的实例</strong></h5><p>小量的线程如何同时为大量连接服务呢，答案就是就绪选择。这就好比到餐厅吃饭，每来一桌客人，都有一个服务员专门为你服务，从你到餐厅到结帐走人，这样方式的好处是服务质量好，一对一的服务，VIP啊，可是缺点也很明显，成本高，如果餐厅生意好，同时来100桌客人，就需要100个服务员，那老板发工资的时候得心痛死了，这就是传统的一个连接一个线程的方式。</p>
<p>老板是什么人啊，精着呢。这老板就得捉摸怎么能用10个服务员同时为100桌客人服务呢，老板就发现，服务员在为客人服务的过程中并不是一直都忙着，客人点完菜，上完菜，吃着的这段时间，服务员就闲下来了，可是这个服务员还是被这桌客人占用着，不能为别的客人服务，用华为领导的话说，就是工作不饱满。那怎么把这段闲着的时间利用起来呢。这餐厅老板就想了一个办法，让一个服务员（前台）专门负责收集客人的需求，登记下来，比如有客人进来了、客人点菜了，客人要结帐了，都先记录下来按顺序排好。每个服务员到这里领一个需求，比如点菜，就拿着菜单帮客人点菜去了。点好菜以后，服务员马上回来，领取下一个需求，继续为别人客人服务去了。这种方式服务质量就不如一对一的服务了，当客人数据很多的时候可能需要等待。但好处也很明显，由于在客人正吃饭着的时候服务员不用闲着了，服务员这个时间内可以为其他客人服务了，原来10个服务员最多同时为10桌客人服务，现在可能10个服务员，就可以负责50桌、100桌。。。。</p>
<p>这种服务方式跟传统的区别有两个：</p>
<p>1、增加了一个角色，要有一个专门负责收集客人需求的人。NIO里对应的就是Selector。</p>
<p>2、由阻塞服务方式改为非阻塞服务了，客人吃着的时候服务员不用一直侯在客人旁边了。传统的IO操作，比如read()，当没有数据可读的时候，线程一直阻塞被占用，直到数据到来。NIO中没有数据可读时，read()会立即返回0，线程不会阻塞。</p>
<p>NIO中，客户端创建一个连接后，先要将连接注册到Selector，相当于客人进入餐厅后，告诉前台你要用餐，前台会告诉你你的桌号是几号，然后你就可能到那张桌子坐下了，SelectionKey就是桌号。当某一桌需要服务时，前台就记录哪一桌需要什么服务，比如1号桌要点菜，2号桌要结帐，服务员从前台取一条记录，根据记录提供服务，完了再来取下一条。这样服务的时间就被最有效的利用起来了。</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h5><p>原理图一：简图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-2d7f631076e8ecd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>原理图二：详图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-f7ae6b97e9d8158c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h5><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stream oriented</td>
<td>Buffer oriented</td>
</tr>
<tr>
<td>Blocking IO</td>
<td>Non blocking IO</td>
</tr>
<tr>
<td></td>
<td>Selectors</td>
</tr>
</tbody>
</table>
<h6 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a><strong>面向流与面向缓冲</strong></h6><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的</p>
<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它<strong>不能前后移动流中的数据</strong>。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的<strong>灵活性</strong>。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 </p>
<h6 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a><strong>阻塞与非阻塞IO</strong></h6><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p>
<h5 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a><strong>NIO和IO如何影响应用程序的设计</strong></h5><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面： </p>
<ul>
<li>对NIO或IO类的API调用。</li>
<li>数据处理。</li>
<li>用来处理数据的线程数。</li>
</ul>
<h5 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h5><h6 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h6><p>Channel 是对数据的源头和数据目标点流经途径的抽象，在这个意义上和 InputStream 和 OutputStream 类似。Channel可以译为“通道、管 道”，而传输中的数据仿佛就像是在其中流淌的水。前面也提到了Buffer，Buffer和Channel相互配合使用，才是Java的NIO。</p>
<h6 id="Java-NIO的通道与流区别"><a href="#Java-NIO的通道与流区别" class="headerlink" title="Java NIO的通道与流区别"></a>Java NIO的通道与流区别</h6><ul>
<li><p>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</p>
</li>
<li><p>通道可以异步地读写。</p>
</li>
<li><p>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</p>
<p>​</p>
</li>
</ul>
<p>我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-77cb44a820e56481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-7d7a517d14ca4b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：通道必须结合Buffer使用，不能直接向通道中读/写数据</p>
<h6 id="Channel主要分类"><a href="#Channel主要分类" class="headerlink" title="Channel主要分类"></a><strong>Channel主要分类</strong></h6><p>广义上来说通道可以被分为两类：File I/O和Stream I/O，也就是文件通道和套接字通道。如果分的更细致一点则是：</p>
<ul>
<li>FileChannel 从文件读写数据</li>
<li>SocketChannel 通过TCP读写网络数据</li>
<li>ServerSocketChannel 可以监听新进来的TCP连接，并对每个链接创建对应的SocketChannel</li>
<li>DatagramChannel 通过UDP读写网络中的数据</li>
<li>Pipe</li>
</ul>
<h6 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a><strong>Channel的实现</strong></h6><p>这些是Java NIO中最重要的通道的实现： </p>
<ul>
<li>FileChannel：从文件中读写数据。</li>
<li>DatagramChannel：能通过UDP读写网络中的数据。</li>
<li>SocketChannel：能通过TCP读写网络中的数据。</li>
<li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
<h6 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h6><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d://nio-data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure>
<h6 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h6><p>调用多个read()方法之一从FileChannel中读取数据。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p>
<p>然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<h6 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h6><p>使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">	channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<h6 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h6><p>用完FileChannel后必须将其关闭。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h6 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h6><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p>
<p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p>
<p>这里有两个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long pos = channel.position();</span><br><span class="line">channel.position(pos +123);</span><br></pre></td></tr></table></figure>
<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</p>
<p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</p>
<h6 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h6><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long fileSize = channel.size();</span><br></pre></td></tr></table></figure>
<h6 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h6><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(1024);</span><br></pre></td></tr></table></figure>
<p>这个例子截取文件的前1024个字节。</p>
<h6 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h6><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。</p>
<p>force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。</p>
<p>下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(true);</span><br></pre></td></tr></table></figure>
<p><strong>transferFrom()</strong></p>
<p>FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>
<p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，</span><br><span class="line">//需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</span><br><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();  </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();   </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure>
<p>transferFrom 方法的输入参数 position 表示从 position 处开始向目标文件写入数据，count 表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 </p>
<p>此外要注意，在 SoketChannel 的实现中，SocketChannel 只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel 可能不会将请求的所有数据(count个字节)全部传输到 FileChannel 中。 </p>
<p><strong>transferTo()</strong></p>
<p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();    </span><br><span class="line">RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);  </span><br><span class="line">FileChannel      toChannel = toFile.getChannel();  </span><br><span class="line">long position = 0;  </span><br><span class="line">long count = fromChannel.size();  </span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。 </p>
<p>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。 </p>
<h6 id="Channel简单实例"><a href="#Channel简单实例" class="headerlink" title="Channel简单实例"></a><strong>Channel简单实例</strong></h6><p>下面是Channel的一个简单的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    	System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<h5 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 Buffer"></a>缓冲区 Buffer</h5><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。 </p>
<h6 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a><strong>Buffer的基本用法</strong></h6><p>使用Buffer读写数据一般遵循以下四个步骤： </p>
<ul>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法</li>
</ul>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从<strong>写模式切换到读模式</strong>。在读模式下，可以读取之前写入到buffer的所有数据。 </p>
<p>一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 <strong>clear() 或 compact() 方法</strong>。clear() 方法会清空整个缓冲区。compact() <strong>方法只会清除已经读过的数据</strong>。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">RandomAccessFile aFile = new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel fileChannel = aFile.getChannel();</span><br><span class="line">//分配缓存区大小</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = fileChannel.read(buf);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">    	System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = fileChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
<h6 id="Buffer的三个属性"><a href="#Buffer的三个属性" class="headerlink" title="Buffer的三个属性"></a><strong>Buffer的三个属性</strong></h6><p>为了理解Buffer的工作原理，需要熟悉它的三个属性： </p>
<ul>
<li><strong>capacity</strong>：作为一个内存块，Buffer 有一个固定的大小值，也叫 “capacity”. 你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。 </li>
<li><strong>position</strong>：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity – 1。 当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position会被重置为 0。当从Buffer的 position 处读取数据时，position 向前移动到下一个可读的位置。 </li>
<li><strong>limit</strong>：在写模式下，Buffer的limit表示你最多能往 Buffer 里写多少数据。 <strong>写模式下</strong>，limit 等于 Buffer 的 capacity 。 当切换Buffer到读模式时， limit 表示你<strong>最多</strong>能读到多少数据。因此，当切换Buffer到读模式时，limit 会被设置成写模式下的 position 值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是 position ）。 </li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-4f05e0bf6b4092fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="buffers-modes.png"></p>
<h6 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a><strong>Buffer的类型</strong></h6><p>Java NIO 有以下Buffer类型： </p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<h6 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a><strong>Buffer的分配</strong></h6><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br></pre></td></tr></table></figure>
<p>这是分配一个可存储1024个字符的CharBuffer： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>
<h6 id="Buffer写数据"><a href="#Buffer写数据" class="headerlink" title="Buffer写数据"></a><strong>Buffer写数据</strong></h6><p>写数据到Buffer有两种方式： </p>
<ul>
<li>从Channel写到Buffer。</li>
<li>通过Buffer的put()方法写到Buffer里。</li>
</ul>
<p>从Channel写到Buffer，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead = inChannel.read(buf); //read into buffer</span><br></pre></td></tr></table></figure>
<p>通过put方法写Buffer的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(127);</span><br></pre></td></tr></table></figure>
<p>put方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。 </p>
<h5 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a><strong>flip()方法</strong></h5><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。 </p>
<p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。 </p>
<h6 id="Buffer中读取数据"><a href="#Buffer中读取数据" class="headerlink" title="Buffer中读取数据"></a><strong>Buffer中读取数据</strong></h6><p>从Buffer中读取数据有两种方式： </p>
<ul>
<li>从Buffer读取数据到Channel。</li>
<li>使用get()方法从Buffer中读取数据。</li>
</ul>
<p>从Buffer读取数据到Channel的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//read from buffer into channel.  </span><br><span class="line">int bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure>
<p>使用get()方法从Buffer中读取数据的例子 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte aByte = buf.get();</span><br></pre></td></tr></table></figure>
<p>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。</p>
<p><strong>rewind()方法</strong> </p>
<p>Buffer.rewind()将 position 设回0，所以你可以重读Buffer中的所有数据。limit 保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）</p>
<p><strong>clear()与compact()方法</strong></p>
<p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。 </p>
<p>如果调用的是 clear() 方法，position将被设回 0，limit被设置成 capacity 的值。换句话说，Buffer 被清空了。</p>
<p>如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。 </p>
<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit 属性依然像 clear() 方法一样，设置成 capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。 </p>
<p><strong>mark()与reset()方法</strong></p>
<p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();  </span><br><span class="line">//set position back to mark.  </span><br><span class="line">buffer.reset();  </span><br><span class="line">equals()与compareTo()方法</span><br></pre></td></tr></table></figure>
<p>可以使用equals()和compareTo()方法两个Buffer。 </p>
<p><strong>equals()</strong></p>
<p>当满足下列条件时，表示两个Buffer相等： </p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的 byte、char 等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ul>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 </p>
<p><strong>compareTo()方法</strong></p>
<p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer “小于” 另一个Buffer： </p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ul>
<h5 id="选择器（-Selector）"><a href="#选择器（-Selector）" class="headerlink" title="选择器（ Selector）"></a>选择器（ Selector）</h5><h6 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h6><p>Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。Selector提供选择<strong>已经就绪的任务的能力</strong>：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过<strong>SelectionKey</strong>可以获取就绪Channel的集合，进行后续的I/O操作。</p>
<p>一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-6c12c7fbdf8b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>要使用Selector，得向 Selector 注册 Channel ，然后调用它的 select() 方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子比如新连接进来，数据接收等。 </p>
<h6 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a><strong>Selector的创建</strong></h6><p>通过调用Selector.open()方法创建一个Selector，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h6 id="Selector注册通道"><a href="#Selector注册通道" class="headerlink" title="Selector注册通道"></a><strong>Selector注册通道</strong></h6><p>为了将 Channel 和 Selector 配合使用，必须将 channel 注册到 selector 上。通过 SelectableChannel.register() 方法来实现，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(false);  </span><br><span class="line">SelectionKey key = channel.register(selector,  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式。而套接字通道都可以。 </p>
<p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件： </p>
<ul>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ul>
<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个 server socket channel 准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。 </p>
<p>这四种事件用 SelectionKey 的四个常量来表示： </p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>如果你对不止一种事件感兴趣，那么可以用 “ 位 或 ” 操作符将常量连接起来，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<h6 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a><strong>SelectionKey</strong></h6><p>在上一小节中，当向Selector注册Channel时，register() 方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性： </p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p>下面我会描述这些属性。</p>
<p><strong>interest集合</strong></p>
<p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过 SelectionKey 读写 interest 集合，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = selectionKey.interestOps();</span><br><span class="line">boolean isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line">boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line">boolean isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line">boolean isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<p>可以看到，用“位与”操作interest 集合和给定的 SelectionKey 常量，<strong>可以确定某个确定的事件是否在 interest 集合中</strong>。</p>
<p><strong>ready集合</strong></p>
<p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个readySet。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>可以用像检测 interest 集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<p><strong>Channel + Selector</strong></p>
<p>从SelectionKey访问Channel和Selector很简单。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<p><strong>附加的对象</strong></p>
<p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<p><strong>通过Selector选择通道</strong></p>
<p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p>
<p>下面是select()方法：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<p>select(long timeout) 和 select() 一样，除了最长会阻塞 timeout 毫秒(参数)。</p>
<p>selectNow() 不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。）。</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p><strong>selectedKeys()</strong></p>
<p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>当向 Selector 注册 Channel 时，Channel.register() 方法会返回一个 SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p>
<p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">while(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    if(key.isAcceptable()) &#123;</span><br><span class="line">        // a connection was accepted by a ServerSocketChannel.</span><br><span class="line">    &#125; else if (key.isConnectable()) &#123;</span><br><span class="line">        // a connection was established with a remote server.</span><br><span class="line">    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">        // a channel is ready for reading</span><br><span class="line">    &#125; else if (key.isWritable()) &#123;</span><br><span class="line">        // a channel is ready for writing</span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。</p>
<p>注意每次迭代末尾的 keyIterator.remove() 调用。Selector不会自己从已选择键集中移除 SelectionKey 实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p>
<p>SelectionKey.channel() 方法返回的通道需要转型成你要处理的类型，如 ServerSocketChannel 或 SocketChannel 等。</p>
<p><strong>wakeUp()</strong></p>
<p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<p><strong>close()</strong></p>
<p>用完 Selector 后调用其 close() 方法会关闭该 Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<p>完整的示例</p>
<p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p>
<pre><code>Selector selector = Selector.open();
channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
while(true) {
  int readyChannels = selector.select();
  if(readyChannels == 0) continue;
  Set selectedKeys = selector.selectedKeys();
  Iterator keyIterator = selectedKeys.iterator();
  while(keyIterator.hasNext()) {
  SelectionKey key = keyIterator.next();
  if(key.isAcceptable()) {
    // a connection was accepted by a ServerSocketChannel.
  } else if (key.isConnectable()) {
    // a connection was established with a remote server.
  } else if (key.isReadable()) {
    // a channel is ready for reading
  } else if (key.isWritable()) {
    // a channel is ready for writing
  }
    keyIterator.remove();
  }
}
</code></pre><h5 id="分散（Scatter）-聚集（Gather）"><a href="#分散（Scatter）-聚集（Gather）" class="headerlink" title="分散（Scatter）/聚集（Gather）"></a>分散（Scatter）/聚集（Gather）</h5><h6 id="分散概念"><a href="#分散概念" class="headerlink" title="分散概念"></a><strong>分散概念</strong></h6><p>分散（scatter）：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-bc98928415f0e3a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序清单 1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>
<p>注意buffer首先被插入到数组，然后再将数组作为 channel.read() 的输入参数。read() 方法按照 buffer 在数组中的顺序将从 channel 中读取的数据写入到buffer，当一个 buffer 被写满后，channel 紧接着向另一个 buffer 中写。 </p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。 </p>
<h6 id="聚集概念"><a href="#聚集概念" class="headerlink" title="聚集概念"></a><strong>聚集概念</strong></h6><p>聚集（gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-cae64631861a6ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例1-1</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(128);  </span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(1024);  </span><br><span class="line">//write data into buffers  </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;  </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>
<p>buffer的一个数组被传递给了 write() 方法，这个方法写他们在数组中遇到的接下来的 buffer 的内容。只是这些数据在 buffer 的 position 和 limit 直接被写。因此，如果一个buffer有一个128字节的容量，但是只包含了58个字节，只有58个字节可以从 buffer 中写到 channel 。因此，一个聚集写操作通过动态可变大小的消息部分会工作的很好，跟分散读取正好相反。</p>
<h6 id="分散-聚集的应用"><a href="#分散-聚集的应用" class="headerlink" title="分散/聚集的应用"></a><strong>分散/聚集的应用</strong></h6><p>scatter / gather经常用于需要将传输的数据分开处理的场合。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容纳正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p>
<h6 id="简单小例子"><a href="#简单小例子" class="headerlink" title="简单小例子"></a><strong>简单小例子</strong></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf1=new RandomAccessFile(&quot;d:\\ay.txt&quot;, &quot;rw&quot;);</span><br><span class="line">//获取通道</span><br><span class="line">FileChannel channel1 = raf1.getChannel();</span><br><span class="line">//设置缓冲区</span><br><span class="line">ByteBuffer buf1=ByteBuffer.allocate(50);</span><br><span class="line">ByteBuffer buf2=ByteBuffer.allocate(1024);</span><br><span class="line">//分散读取的时候缓存区应该是有序的，所以把几个缓冲区加入数组中</span><br><span class="line">ByteBuffer[] bufs=&#123;buf1,buf2&#125;;</span><br><span class="line">//通道进行传输</span><br><span class="line">channel1.read(bufs);</span><br><span class="line">//查看缓冲区中的内容</span><br><span class="line">for (int i = 0; i &lt; bufs.length; i++) &#123;</span><br><span class="line">   //切换为读模式</span><br><span class="line">   bufs[i].flip();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(new String(bufs[0].array(),0,bufs[0].limit()));</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(new String(bufs[1].array(),0,bufs[1].limit()));</span><br><span class="line">//聚集写入</span><br><span class="line">RandomAccessFile  raf2=new RandomAccessFile(&quot;d:\\al.txt&quot;, &quot;rw&quot;);</span><br><span class="line">FileChannel channel2 = raf2.getChannel();</span><br><span class="line">//只能通过通道来进行写入</span><br><span class="line">channel2.write(bufs);</span><br></pre></td></tr></table></figure>
<h5 id="其他通道"><a href="#其他通道" class="headerlink" title="其他通道"></a><strong>其他通道</strong></h5><p>​            </p>
<h6 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a><strong>文件通道</strong></h6><p>略</p>
<h6 id="Socket-通道"><a href="#Socket-通道" class="headerlink" title="Socket 通道"></a>Socket 通道</h6><p>Java NIO中的 SocketChannel 是一个连接到 TCP 网络套接字的通道。可以通过以下2种方式创建 SocketChannel：</p>
<ul>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达 ServerSocketChannel 时，会创建一个 SocketChannel。</li>
</ul>
<p><strong>打开 SocketChannel</strong></p>
<p>下面是SocketChannel的打开方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;,80));</span><br></pre></td></tr></table></figure>
<p><strong>从 SocketChannel 读取数据</strong></p>
<p>要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p>
<p>然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p>
<p><strong>写入 SocketChannel</strong></p>
<p>写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。</p>
<p><strong>非阻塞模式</strong></p>
<p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。</p>
<p><strong>connect()</strong></p>
<p>如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</span><br><span class="line">while(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    //wait, or do something else...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>write()</strong></p>
<p>非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。</p>
<p><strong>read()</strong></p>
<p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
<p><strong>不错的小例子</strong></p>
<p>一下是来自网络的一个小例子，个人觉得很不错，就贴到这里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class NioClient &#123;</span><br><span class="line">    //管道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    public NioClient init(String serverIp, int port) throws IOException&#123;</span><br><span class="line">        //获取socket通道</span><br><span class="line">        SocketChannel channel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        channel.configureBlocking(false);</span><br><span class="line">        //获得通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line"></span><br><span class="line">        //客户端连接服务器，需要调用channel.finishConnect();才能实际完成连接。</span><br><span class="line">        channel.connect(new InetSocketAddress(serverIp, port));</span><br><span class="line">        //为该通道注册SelectionKey.OP_CONNECT事件</span><br><span class="line">        channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;客户端启动&quot;);</span><br><span class="line">        //轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //选择注册过的io操作的事件(第一次为SelectionKey.OP_CONNECT)</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite = selector.selectedKeys().iterator();</span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选的key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                if(key.isConnectable())&#123;</span><br><span class="line">                    SocketChannel channel=(SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    //如果正在连接，则完成连接</span><br><span class="line">                    if(channel.isConnectionPending())&#123;</span><br><span class="line">                        channel.finishConnect();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向服务器发送消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to server.&quot;).getBytes()));</span><br><span class="line"></span><br><span class="line">                    //连接成功后，注册接收服务器消息的事件</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    System.out.println(&quot;客户端连接成功&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123; //有可读数据事件。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;recevie message from server:, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;client.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioClient().init(&quot;127.0.0.1&quot;, 9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class NioServer &#123;</span><br><span class="line">    //通道管理器</span><br><span class="line">    private Selector selector;</span><br><span class="line"></span><br><span class="line">    //获取一个ServerSocket通道，并初始化通道</span><br><span class="line">    public NioServer init(int port) throws IOException&#123;</span><br><span class="line">        //获取一个ServerSocket通道</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(false);</span><br><span class="line">        serverChannel.socket().bind(new InetSocketAddress(port));</span><br><span class="line">        //获取通道管理器</span><br><span class="line">        selector=Selector.open();</span><br><span class="line">        //将通道管理器与通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件，</span><br><span class="line">        //只有当该事件到达时，Selector.select()会返回，否则一直阻塞。</span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void listen() throws IOException&#123;</span><br><span class="line">        System.out.println(&quot;服务器端启动成功&quot;);</span><br><span class="line"></span><br><span class="line">        //使用轮询访问selector</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //当有注册的事件到达时，方法返回，否则阻塞。</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            //获取selector中的迭代器，选中项为注册的事件</span><br><span class="line">            Iterator&lt;SelectionKey&gt; ite=selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            while(ite.hasNext())&#123;</span><br><span class="line">                SelectionKey key = ite.next();</span><br><span class="line">                //删除已选key，防止重复处理</span><br><span class="line">                ite.remove();</span><br><span class="line">                //客户端请求连接事件</span><br><span class="line">                if(key.isAcceptable())&#123;</span><br><span class="line">                    ServerSocketChannel server = (ServerSocketChannel)key.channel();</span><br><span class="line">                    //获得客户端连接通道</span><br><span class="line">                    SocketChannel channel = server.accept();</span><br><span class="line">                    channel.configureBlocking(false);</span><br><span class="line">                    //向客户端发消息</span><br><span class="line">                    channel.write(ByteBuffer.wrap(new String(&quot;send message to client&quot;).getBytes()));</span><br><span class="line">                    //在与客户端连接成功后，为客户端通道注册SelectionKey.OP_READ事件。</span><br><span class="line">                    channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;客户端请求连接事件&quot;);</span><br><span class="line">                &#125;else if(key.isReadable())&#123;//有可读数据事件</span><br><span class="line">                    //获取客户端传输数据可读取消息通道。</span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line">                    //创建读取数据缓冲器</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(10);</span><br><span class="line">                    int read = channel.read(buffer);</span><br><span class="line">                    byte[] data = buffer.array();</span><br><span class="line">                    String message = new String(data);</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;receive message from client, size:&quot; + buffer.position() + &quot; msg: &quot; + message);</span><br><span class="line">//                    ByteBuffer outbuffer = ByteBuffer.wrap((&quot;server.&quot;.concat(msg)).getBytes());</span><br><span class="line">//                    channel.write(outbuffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        new NioServer().init(9981).listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Datagram-通道"><a href="#Datagram-通道" class="headerlink" title="Datagram 通道"></a>Datagram 通道</h6><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<p>Datagram 通道就作为大家自学的内容。</p>
<h5 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h5><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 </p>
<p><img src="https://upload-images.jianshu.io/upload_images/12253573-0c5dc6435ff44191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12253573-9302f20c78103fbf.png"></p>
<h6 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a><strong>创建管道</strong></h6><p>通过Pipe.open()方法打开管道。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure>
<h6 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a><strong>向管</strong>道写数据</h6><p>要向管道写数据，需要访问sink通道。像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br></pre></td></tr></table></figure>
<p>通过调用SinkChannel的write()方法，将数据写入SinkChannel,像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();  </span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">buf.clear();  </span><br><span class="line">buf.put(newData.getBytes());  </span><br><span class="line">buf.flip();  </span><br><span class="line">while(buf.hasRemaining()) &#123;  </span><br><span class="line">   &lt;b&gt;sinkChannel.write(buf);&lt;/b&gt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a><strong>从管道读取数据</strong></h6><p>从读取管道的数据，需要访问source通道，像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure>
<p>调用source通道的read()方法来读取数据，像这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);  </span><br><span class="line">int bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure>
<p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。 </p>
<h6 id="简单完整实例"><a href="#简单完整实例" class="headerlink" title="简单完整实例"></a>简单完整实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//获取管道</span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">//获取Sink 管道</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">//需要写入数据</span><br><span class="line">String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();</span><br><span class="line">//新建缓存区</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(48);</span><br><span class="line">buf.clear();</span><br><span class="line">//缓存区存放数据</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line">while(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br><span class="line">//获取Source 管道</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">ByteBuffer buf2 = ByteBuffer.allocate(48);</span><br><span class="line">int bytesRead = sourceChannel.read(buf2);</span><br><span class="line">while (bytesRead != -1) &#123;</span><br><span class="line">    System.out.println(&quot;Read &quot; + bytesRead);</span><br><span class="line">    //buf.flip()的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据（注：flip：空翻，反转）</span><br><span class="line">    buf.flip();</span><br><span class="line">    //判断是否有剩余（注：Remaining：剩余的）</span><br><span class="line">    while(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((char) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = sourceChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">sourceChannel.close();</span><br><span class="line">sinkChannel.close();</span><br></pre></td></tr></table></figure>
<h4 id="AIO编程"><a href="#AIO编程" class="headerlink" title="AIO编程"></a>AIO编程</h4><h6 id="AIO的特点"><a href="#AIO的特点" class="headerlink" title="AIO的特点"></a><strong>AIO的特点</strong></h6><ul>
<li><p>读完了再通知我</p>
</li>
<li><p>不会加快IO，只是在读完后进行通知</p>
</li>
<li><p>使用回调函数，进行业务处理</p>
<p>​</p>
</li>
</ul>
<p>AIO的相关代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AsynchronousServerSocketChannel类</span><br><span class="line">server = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(PORT));</span><br></pre></td></tr></table></figure>
<p>使用server上的accept方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract &lt;A&gt; void accept(A attachment,CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt; handler);</span><br></pre></td></tr></table></figure>
<p>CompletionHandler为回调接口，当有客户端accept之后，就做handler中的事情。</p>
<h6 id="NIO与AIO区别"><a href="#NIO与AIO区别" class="headerlink" title="NIO与AIO区别"></a>NIO与AIO区别</h6><ul>
<li>NIO是同步非阻塞的，AIO是异步非阻塞的</li>
<li>由于NIO的读写过程依然在应用线程里完成，所以对于那些读写过程时间长的，NIO就不太适合。而AIO的读写过程完成后才被通知，所以AIO能够胜任那些重量级，读写过程长的任务。</li>
</ul>
<p><strong>结束语</strong></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h4><p>【1】<a href="http://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">http://blog.csdn.net/anxpp/article/details/51512200</a></p>
<p>【2】<a href="http://www.iteye.com/magazines/132-Java-NIO" target="_blank" rel="noopener">http://www.iteye.com/magazines/132-Java-NIO</a></p>
<p>【3】<a href="http://www.jb51.net/article/92448.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92448.htm</a></p>
<p>【4】<a href="http://www.cnblogs.com/good-temper/p/5003892.html" target="_blank" rel="noopener">http://www.cnblogs.com/good-temper/p/5003892.html</a></p>
<p>【5】<a href="http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm" target="_blank" rel="noopener">http://www.cnblogs.com/fanzhidongyzby/p/4098546.htm</a></p>
<p>【6】<a href="https://www.ibm.com/developerworks/cn/java/l-niosvr/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/l-niosvr/</a></p>
<p>【7】Netty权威指南</p>
<p>【8】<a href="http://ifeve.com/selectors/" target="_blank" rel="noopener">http://ifeve.com/selectors/</a></p>
<p>【9】<a href="http://ifeve.com/socket-channel/" target="_blank" rel="noopener">http://ifeve.com/socket-channel/</a></p>

      
    </div>
    
    
    
	
	<div>
  
    ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/wechat-qcode.png" alt="郭 琪 wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/30/Typora-快捷键/" rel="next" title="Typora for Markdown 快捷键">
                <i class="fa fa-chevron-left"></i> Typora for Markdown 快捷键
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/04/一种数组去重方法/" rel="prev" title="一种数组去重方法">
                一种数组去重方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        ﻿ <!--MOB SHARE BEGIN-->
                                <div class="-mob-share-ui-button -mob-share-open">分享</div>
                                <div class="-mob-share-ui" style="display: none">
                                    <ul class="-mob-share-list">
                                        <li class="-mob-share-weibo"><p>新浪微博</p></li>
                                        <li class="-mob-share-tencentweibo"><p>腾讯微博</p></li>
                                        <li class="-mob-share-qzone"><p>QQ空间</p></li>
                                        <li class="-mob-share-qq"><p>QQ好友</p></li>
                                        <li class="-mob-share-weixin"><p>微信</p></li>
                                        <li class="-mob-share-douban"><p>豆瓣</p></li>
                                        <li class="-mob-share-renren"><p>人人网</p></li>
                                        <li class="-mob-share-kaixin"><p>开心网</p></li>
                                        <li class="-mob-share-facebook"><p>Facebook</p></li>
                                        <li class="-mob-share-twitter"><p>Twitter</p></li>
                                        <li class="-mob-share-pocket"><p>Pocket</p></li>
                                        <li class="-mob-share-google"><p>Google+</p></li>
                                        <li class="-mob-share-youdao"><p>有道云笔记</p></li>
                                        <li class="-mob-share-mingdao"><p>明道</p></li>
                                        <li class="-mob-share-pengyou"><p>朋友网</p></li>
                                        <li class="-mob-share-tumblr"><p>Tumblr</p></li>
                                        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
                                        <li class="-mob-share-linkedin"><p>LinkedIn</p></li>
                                    </ul>
                                    <div class="-mob-share-close">取消</div>
                                </div>
                                <div class="-mob-share-ui-bg"></div>
                                <script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=25e1879146e04"></script>
                                <!--MOB SHARE END-->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNjU4Ny8xMzEyMg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="郭 琪" />
            
              <p class="site-author-name" itemprop="name">郭 琪</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

                        
          </nav>
          
          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/guoqick" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:guoqi303@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/6293906909" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-globe"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/gqhpstar/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/2cd89e69f92a" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.imooc.com/" title="慕课网" target="_blank">慕课网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.csdn.net/" title="CSDN官方" target="_blank">CSDN官方</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#大纲目录"><span class="nav-number">1.0.1.</span> <span class="nav-text">大纲目录</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IO，NIO，JDK介绍"><span class="nav-number">1.0.2.</span> <span class="nav-text">IO，NIO，JDK介绍**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO基础知识回顾"><span class="nav-number">2.</span> <span class="nav-text">IO基础知识回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#IO流类图结构"><span class="nav-number">2.0.1.</span> <span class="nav-text">IO流类图结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#IO流简单例子"><span class="nav-number">2.0.2.</span> <span class="nav-text">IO流简单例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO编程"><span class="nav-number">3.</span> <span class="nav-text">BIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#传统BIO通信模型图"><span class="nav-number">3.1.</span> <span class="nav-text">传统BIO通信模型图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#传统BIO编程实例"><span class="nav-number">3.2.</span> <span class="nav-text">传统BIO编程实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#伪异步I-O编程"><span class="nav-number">4.</span> <span class="nav-text">伪异步I/O编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#伪异步I-O编程模型图"><span class="nav-number">4.1.</span> <span class="nav-text">伪异步I/O编程模型图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#伪异步IO编程代码"><span class="nav-number">4.2.</span> <span class="nav-text">伪异步IO编程代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-编程"><span class="nav-number">5.</span> <span class="nav-text">NIO 编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#简介"><span class="nav-number">5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非常形象的实例"><span class="nav-number">5.2.</span> <span class="nav-text">非常形象的实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理"><span class="nav-number">5.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java-NIO和IO的主要区别"><span class="nav-number">5.4.</span> <span class="nav-text">Java NIO和IO的主要区别</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#面向流与面向缓冲"><span class="nav-number">5.4.1.</span> <span class="nav-text">面向流与面向缓冲</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#阻塞与非阻塞IO"><span class="nav-number">5.4.2.</span> <span class="nav-text">阻塞与非阻塞IO</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO和IO如何影响应用程序的设计"><span class="nav-number">5.5.</span> <span class="nav-text">NIO和IO如何影响应用程序的设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通道-Channel"><span class="nav-number">5.6.</span> <span class="nav-text">通道 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#简介-1"><span class="nav-number">5.6.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Java-NIO的通道与流区别"><span class="nav-number">5.6.2.</span> <span class="nav-text">Java NIO的通道与流区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Channel主要分类"><span class="nav-number">5.6.3.</span> <span class="nav-text">Channel主要分类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Channel的实现"><span class="nav-number">5.6.4.</span> <span class="nav-text">Channel的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#打开FileChannel"><span class="nav-number">5.6.5.</span> <span class="nav-text">打开FileChannel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#从FileChannel读取数据"><span class="nav-number">5.6.6.</span> <span class="nav-text">从FileChannel读取数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#向FileChannel写数据"><span class="nav-number">5.6.7.</span> <span class="nav-text">向FileChannel写数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#关闭FileChannel"><span class="nav-number">5.6.8.</span> <span class="nav-text">关闭FileChannel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileChannel的position方法"><span class="nav-number">5.6.9.</span> <span class="nav-text">FileChannel的position方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileChannel的size方法"><span class="nav-number">5.6.10.</span> <span class="nav-text">FileChannel的size方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileChannel的truncate方法"><span class="nav-number">5.6.11.</span> <span class="nav-text">FileChannel的truncate方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#FileChannel的force方法"><span class="nav-number">5.6.12.</span> <span class="nav-text">FileChannel的force方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Channel简单实例"><span class="nav-number">5.6.13.</span> <span class="nav-text">Channel简单实例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区-Buffer"><span class="nav-number">5.7.</span> <span class="nav-text">缓冲区 Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer的基本用法"><span class="nav-number">5.7.1.</span> <span class="nav-text">Buffer的基本用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer的三个属性"><span class="nav-number">5.7.2.</span> <span class="nav-text">Buffer的三个属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer的类型"><span class="nav-number">5.7.3.</span> <span class="nav-text">Buffer的类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer的分配"><span class="nav-number">5.7.4.</span> <span class="nav-text">Buffer的分配</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer写数据"><span class="nav-number">5.7.5.</span> <span class="nav-text">Buffer写数据</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flip-方法"><span class="nav-number">5.8.</span> <span class="nav-text">flip()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Buffer中读取数据"><span class="nav-number">5.8.1.</span> <span class="nav-text">Buffer中读取数据</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择器（-Selector）"><span class="nav-number">5.9.</span> <span class="nav-text">选择器（ Selector）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#简单介绍"><span class="nav-number">5.9.1.</span> <span class="nav-text">简单介绍</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Selector的创建"><span class="nav-number">5.9.2.</span> <span class="nav-text">Selector的创建</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Selector注册通道"><span class="nav-number">5.9.3.</span> <span class="nav-text">Selector注册通道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SelectionKey"><span class="nav-number">5.9.4.</span> <span class="nav-text">SelectionKey</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分散（Scatter）-聚集（Gather）"><span class="nav-number">5.10.</span> <span class="nav-text">分散（Scatter）/聚集（Gather）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#分散概念"><span class="nav-number">5.10.1.</span> <span class="nav-text">分散概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#聚集概念"><span class="nav-number">5.10.2.</span> <span class="nav-text">聚集概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#分散-聚集的应用"><span class="nav-number">5.10.3.</span> <span class="nav-text">分散/聚集的应用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#简单小例子"><span class="nav-number">5.10.4.</span> <span class="nav-text">简单小例子</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#其他通道"><span class="nav-number">5.11.</span> <span class="nav-text">其他通道</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#文件通道"><span class="nav-number">5.11.1.</span> <span class="nav-text">文件通道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Socket-通道"><span class="nav-number">5.11.2.</span> <span class="nav-text">Socket 通道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Datagram-通道"><span class="nav-number">5.11.3.</span> <span class="nav-text">Datagram 通道</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#管道（Pipe）"><span class="nav-number">5.12.</span> <span class="nav-text">管道（Pipe）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建管道"><span class="nav-number">5.12.1.</span> <span class="nav-text">创建管道</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#向管道写数据"><span class="nav-number">5.12.2.</span> <span class="nav-text">向管道写数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#从管道读取数据"><span class="nav-number">5.12.3.</span> <span class="nav-text">从管道读取数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#简单完整实例"><span class="nav-number">5.12.4.</span> <span class="nav-text">简单完整实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AIO编程"><span class="nav-number">6.</span> <span class="nav-text">AIO编程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AIO的特点"><span class="nav-number">6.0.1.</span> <span class="nav-text">AIO的特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#NIO与AIO区别"><span class="nav-number">6.0.2.</span> <span class="nav-text">NIO与AIO区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考文章"><span class="nav-number">7.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      
       <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=32685948&auto=1&height=66"></iframe>  
      
    
	</div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qi Guo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

  
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
